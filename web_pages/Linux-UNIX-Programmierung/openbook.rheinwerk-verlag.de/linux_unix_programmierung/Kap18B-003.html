<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap18B-003.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 20:00:27 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – A.4 Fortgeschrittene Ein-/Ausgabe-Funktionen</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap18B-002.html">
<link rel="next" href="Kap18B-004.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap18B-002.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap18B-004.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="Kap18B-000.html#RxxKap18B000040006D31F040100">A Funktionsreferenz</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-000.html#RxxKap18B000040006D31F040103">B.1 ANSI C</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-001.html#RxxKap18B001040006F01F048100">B.2 ANSI C99</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-002.html#RxxKap18B002040006F11F027100">B.3 Elementare E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap18B003040006F21F025100">B.4 Fortgeschrittene Ein-/Ausgabe-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-004.html#RxxKap18B004040006F31F046100">B.5 Verzeichnisse</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-005.html#RxxKap18B005040006F41F034100">B.6 Attribute von Dateien und Verzeichnissen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-006.html#RxxKap18B006040006F51F043100">B.7 Links</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-007.html#RxxKap18B007040006F61F016100">B.8 Prozess und Prozessverwaltungsfunktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-008.html#RxxKap18B008040006F71F017100">B.9 Signale – Das neue Signalkonzept</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-009.html#RxxKap18B009040006F81F04C100">B.10 Interprozesskommunikationen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-010.html#RxxKap18B010040006F91F034100">B.11 Sys-V-Interprozesskommnunikationen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-011.html#RxxKap18B011040006FA1F027100">B.12 Threadprogrammierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-012.html#RxxKap18B012040006FB1F029100">B.13 Netzwerkprogrammierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-013.html#RxxKap18B013040006FC1F04F100">B.14 MySQL C-API</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-014.html#RxxKap18B014040006FD1F049100">B.15 PostgreSQL C-API</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap18B-015.html#RxxKap18B015040006FE1F030100">B.16 Weitere Funktionsreferenzen auf der Buch-CD</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">B.4 Fortgeschrittene Ein-/Ausgabe-Funktionen<a id="RxxKap18B003040006F21F025100" name="RxxKap18B003040006F21F025100"></a> 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t32"></a><h3 class="t3">B.4.1 Multiplexing<a id="Xxx999246" name="Xxx999246"></a> Ein-/Ausgabe – select(<a id="RxxKap18B003040006F21F025101" name="RxxKap18B003040006F21F025101"></a>) 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konform </b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>ANSI C</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>POSIX.1</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>XPG</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>SVR4</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>BSD</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"> 
</td>
<td class="tabellentext" bgcolor="#000000">nein
</td>
<td class="tabellentext" bgcolor="#000000">nein
</td>
<td class="tabellentext" bgcolor="#000000">nein
</td>
<td class="tabellentext" bgcolor="#000000">ja
</td>
<td class="tabellentext" bgcolor="#000000">ja
</td>
</tr>
</table><br>
<p><a id="Xxx999274" name="Xxx999274"></a>Das Lesen und Schreiben von Filedeskriptoren erfolgt meistens &uuml;ber ein einfaches <span class="listing">read()</span> und <span class="listing">write()</span> wie im folgenden Code-Auschnitt demonstriert:</p>
<pre>while(  (n = read(fd_r, buf, BUFSIZ) ) &gt; 0 )
     if( write( fd_w, buf, n ) != n)
         /* Fehler bei write ... */</pre>
<p>Sobald allerdings aus mehr als einem Filedeskriptor auf einmal gelesen werden soll, l&auml;sst sich diese Form nicht mehr sinnvoll einsetzen. Kommen hier bspw. Daten an einem Filedeskriptor an – aber es wird gerade von einem anderen gelesen, bei dem keine Daten anstehen – blockiert <span class="listing">read()</span>. Somit muss der Filedeskriptor, an dem Daten angekommen sind, so lange warten, bis bei dem anderen Filedeskriptor Daten anstehen. Das Blockieren ist die Standardeinstellung von <span class="listing">read()</span>.</p>
<p>Um dieses Problem zu umgehen, steht Ihnen in SVR4 und BSD (und somit auch unter Linux) eine Multiplexing Ein-/Ausgabe mit der Funktion <span class="listing">select()</span> zur Verf&uuml;gung. Das Prinzip ist einfach: Man erstellt eine Liste (Menge) von Filedeskriptoren, die f&uuml;r den Prozess interessant sind und ruft die Funktion <span class="listing">select()</span> auf. Diese Funktion kehrt erst dann zur&uuml;ck, wenn einer der Filedeskriptoren in der Liste (Menge) etwas zu tun hat (spricht die Ein-/Ausgabe bereit ist). Als R&uuml;ckgabewert erh&auml;lt man von <span class="listing">select()</span> den Filedeskriptor, der f&uuml;r die Ein-/Ausgabe bereit ist.</p>
<pre>int select(
  int maxfd,               /* Nr. des gr&ouml;&szlig;ten fd aus der Menge */
  fd_set *fd_read,         /* Deskriptor-Menge zum Lesen       */
  fd_set *fd_write,        /* Deskriptor-Menge zum Schreiben   */
  fd_set *fd_except,       /* Deskriptor-Menge f&uuml;r Exceptions  */
  struct timeval *timeout  /* wie lange soll select() warten   */
  );</pre>
<p>Um auf die Deskriptoren-Menge (den einzelnen Bits) verschiedene Operationen auszuf&uuml;hen, stehen Ihnen folgende Makros zu Verf&uuml;gung.</p>
<pre>FD_ZERO<a id="Xxx999281" name="Xxx999281"></a>(fd_set *fdptr);          /* Alle Bits in fdptr l&ouml;schen */
FD_SET<a id="Xxx999283" name="Xxx999283"></a>(int fd, fd_set *fdptr);   /* Bit fd in fdptr setzen     */  
FD_CLR<a id="Xxx999284" name="Xxx999284"></a>(int fd, fd_set *fdptr);   /* Bit fd in fdptr l&ouml;schen    */
FD_ISSET<a id="Xxx999285" name="Xxx999285"></a>(int fd, fd_set *fdptr); /* Testen, ob Bit fd gesetzt  */</pre>
<p>Wie lange auf <span class="listing">select()</span> gewartet werden soll, geben Sie mit dem letzten Parameter an. Ein <span class="listing">timeout</span> von <span class="listing">NULL</span> bedeutet ewiges Warten. Werden den beiden Strukturvariablen <span class="listing">timeout-&gt;tv_sec</span> und <span class="listing">timeout-&gt;tv_usec</span> jeweils der Wert 0 &uuml;bergeben, findet kein Warten statt und <span class="listing">select()</span> kehrt sofort wieder zur&uuml;ck. In der Praxis wird damit, in einer Schleife, das so genannte Polling (dauerndes Abfragen ohne blockieren) realisiert. Geben Sie hingegen f&uuml;r die Strukturvariablen <span class="listing">timeout-&gt;tv_sec</span> und <span class="listing">timeout-&gt;tv_usec</span> einen positiven Wert ungleich 0 an, wird entsprechend der Angabe(n) eine gewisse Zeit gewartet.</p>
<p>Der R&uuml;ckgabewert von <span class="listing">select()</span> ist entweder die Anzahl der Filedeskriptoren, die bereit sind, oder 0, wenn die Zeitschaltuhr abgelaufen ist. Ansonsten wird bei einem Fehler –1 zur&uuml;ckgegeben.</p>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t33"></a><h3 class="t3">B.4.2 Memory Mapped Ein-/Ausgabe<a id="RxxKap18B003040006F21F025118" name="RxxKap18B003040006F21F025118"></a><a id="Xxx999288" name="Xxx999288"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konform </b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>ANSI C</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>POSIX.1</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>XPG</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>SVR4</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>BSD</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"> 
</td>
<td class="tabellentext" bgcolor="#000000">nein
</td>
<td class="tabellentext" bgcolor="#000000">nein
</td>
<td class="tabellentext" bgcolor="#000000">nein
</td>
<td class="tabellentext" bgcolor="#000000">ja
</td>
<td class="tabellentext" bgcolor="#000000">ja
</td>
</tr>
</table><br>
<p>Neben den Standard-E/A und elementaren E/A-Funktionen stellt Ihnen SVR4 und BSD (somit auch Linux) das Memory Mapped zur Verf&uuml;gung. Dabei handelt es sich um eine fortgeschrittene Methode, welche Ihnen das Abbilden von Dateien in dem Hauptspeicher erm&ouml;glicht. Der Hauptvorteil dieser Methode ist, dass hierbei weniger Kernel-Aktionen wie bei den Systemaufrufen gemacht werden m&uuml;ssen – es muss viel weniger vom User- in den Kernel-Level gewechselt werden. Und das wirkt sich (richtig eingesetzt) positiv auf die Performance aus.</p>
<p>Nat&uuml;rlich sollte man mit Memory Mapped E/A im Auge behalten, dass man hierbei wirklich den Hauptspeicher verwendet (RAM) – was auch bedeutet, dass man diesen mit Memory Mapped falsch eingesetzt, komplett zum&uuml;llen kann. Es empfiehlt sich daher, eine sinnvolle Gr&ouml;&szlig;e des Speicherbereichs zu verwenden. Bspw. beim Kopieren in ein oder zwei Megabyte-Schritten l&auml;uft Memory Mapped E/A erheblich schneller ab als bspw. <span class="listing">read()</span> und <span class="listing">write()</span>.</p>
<p>Mit Memory Mapped hat man quasi einen kompletten Dateiinhalt im Hauptspeicher und kann diesen bequem mittels Zeiger modifizieren – &auml;hnlich wie mit den Funktionen <span class="listing">fseek()</span>/<span class="listing">lseek()</span>.</p>
<p>Das Einrichten eines solchen Memory Mapped Speicherbereichs wird mit der Funktion <span class="listing">mmap()<a id="Xxx999320" name="Xxx999320"></a></span> erledigt.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;<a id="Xxx999322" name="Xxx999322"></a>
void *mmap( void *addr, size_t len, int prot,
            int flags, int fd, off_t offset);</pre>
<p>Mit <span class="listing">addr</span> wird der Anfangsbereich (Adresse) des gemappten Speicherbereichs festgelegt. Gew&ouml;hnlich wird hierbei 0 angegeben, was somit bedeutet, dass sich dass System f&uuml;r uns nach einem geeigneten Platz umschauen soll. Als R&uuml;ckgabewert der Funktion <span class="listing">mmap()</span> erhalten Sie dann die Anfangsadresse dieses Bereiches. Mit <span class="listing">len</span> geben Sie die Anzahl von Bytes an, die der mapped-Speicherbereich umfassen soll (bspw. die komplette Gr&ouml;&szlig;e (Vorsicht bei zu gro&szlig;en Dateien) einer Datei oder nur St&uuml;cke davon).</p>
<p>Mit <span class="listing">prot</span> legen Sie die Schutzart des mapped-Speicherbereichs fest. Hierzu k&ouml;nnen Sie einen oder mehrere (mit dem bitweisen ODER verkn&uuml;pft) der folgenden Angaben verwenden:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle B.29   
    </b>Schutzarten f&uuml;r einen Memory Mapped-Bereich</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PROT_READ
</td>
<td class="tabellentext" bgcolor="#000000">Bereich darf gelesen werden.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PROT_WRITE
</td>
<td class="tabellentext" bgcolor="#000000">Bereich darf beschrieben werden.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PROT_EXEC
</td>
<td class="tabellentext" bgcolor="#000000">Bereich darf ausgef&uuml;hrt werden.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PROT_NONE
</td>
<td class="tabellentext" bgcolor="#000000">Auf diesen Bereich darf nicht zugegriffen werden (nicht BSD).
</td>
</tr>
</table><br>
<p>Nat&uuml;rlich muss auch hierbei die Schutzart mit den entsprechenden Optionen &uuml;bereinstimmten, die beim &Ouml;ffnen mit <span class="listing">open()</span> verwendet wurde – sprich, wurde die Datei zum Lesen ge&ouml;ffnet, kann kein Schreibschutz verwendet werden!</p>
<p>Mit den <span class="listing">flags</span> k&ouml;nnen Sie zus&auml;tzlich Anforderungen an den mapped-Speicherbereich angeben. M&ouml;gliche <span class="listing">flags</span> w&auml;ren hierf&uuml;r (wobei hier die Flags <span class="listing">MAP_SHARED</span> oder <span class="listing">MAP_PRIVATE</span> immer gesetzt sein m&uuml;ssen):</p>
<span class="listing"> MAP_FIXED</span> – Die Anfangsadresse, die <span class="listing">mmap()</span> zur&uuml;ckgibt, muss mit der von <span class="listing">addr </span>&uuml;bereinstimmen. Ohne diesem Flag gilt <span class="listing">addr </span>nur als Vorschlag und darf vom System auch ignoriert werden.
<span class="listing"> MAP_SHARED</span> – Jede Modifikation im mapped-Bereich wirkt sich auf die Orginal-Datei aus. Ohne diesem Flag w&uuml;rde erst an einer Kopie gearbeitet. Nat&uuml;rlich bedeutet dies auch, dass alle anderen Prozesse, die denselben mapped-Speicherbereich verwenden, ebenfalls diese Ver&auml;nderung erkennen.
<span class="listing"> MAP_PRIVATE</span> – Das Gegenteil von <span class="listing">MAP_SHARED</span>. Alle Arbeiten finden auf einer Kopie statt und die anderen Prozesse erfahren nichts davon.
<span class="listing"> MAP_ANONYMOUS</span> – Damit kann ein anonymer Speicherbereich angelegt werden, der f&uuml;r keinen anderen Prozess sichtbar ist. Wenn Sie schon mal STRACE verwendet haben, wird Ihnen sicherlich aufgefallen sein, dass beim Reservieren eines Speichers mittels <span class="listing">malloc()</span> die Funktion <span class="listing">mmap()</span> und zum Freigeben mittels <span class="listing">free()</span>,<span class="listing"> munmap()</span> verwendet wurde. Daraus k&ouml;nnen Sie schlie&szlig;en, dass <span class="listing">malloc()</span> mithilfe von <span class="listing">mmap()</span> realisiert wurde. Sie k&ouml;nnen damit auch Ihr eigenes <span class="listing">malloc()</span> implementieren. Das Argument <span class="listing">fd</span> wird mit dem Setzen dieses Flags ignoriert.
<span class="listing"> MAP_DENYWRITE</span> – Haben Sie bspw. beim Speicherschutz <span class="listing">PROT_EXEC</span> verwendet, so dass dieser Speicherbereich ausgef&uuml;hrt werden darf, k&ouml;nnen Sie mit diesem Flag daf&uuml;r sorgen, dass dies weiterhin m&ouml;glich ist – aber ein Schreiben von au&szlig;erhalb in den mapped-Bereich wird untersagt (nur Linux).
<span class="listing"> MAP_GROWSDOWN</span> – Findet ein Zugriff au&szlig;erhalb eines gemappten Speicherbereichs statt, wird durch das Setzen von diesem Flag nicht das Signal <span class="listing">SIGSEGV</span> gesendet und der Prozess somit auch nicht beendet. Stattdessen wird ein neuer anonymer Bereich alloziiert, worin der entsprechende Prozess seine Ausf&uuml;hrung fortsetzt. Zwangsl&auml;ufig w&auml;chst mit dieser Methode allerdings auch der Stack an! (nur Linux)
<span class="listing"> MAP_LOCKED</span> – Der mapped-Speicherbereich kann nicht ausgelagert werden. Dies wird unbedingt f&uuml;r Echtzeitanwendungen ben&ouml;tigt. Dieses Flag ist nur dem Superuser vorbehalten.
<p>Mit dem Argument <span class="listing">fd</span> der Funktion <span class="listing">mmap()</span> geben Sie den Filedeskriptor der Datei an, die im mapped-Speicherbereich abgebildet werden soll. Logischerweise haben Sie diese Datei bis dato schon ge&ouml;ffnet! Mit <span class="listing">offset</span> geben Sie das Offset des Datenbereichs an. Das Offset ist der Bereich, der vom Anfang der Datei ausgelassen werden soll. Ist <span class="listing">MAP_FIXED</span> angegeben, m&uuml;ssen die Werte f&uuml;r <span class="listing">offset</span> und <span class="listing">addr</span> das Vielfache einer Page-Gr&ouml;&szlig;e sein. Die Page-Gr&ouml;&szlig;e k&ouml;nnen Sie mit der Funktion <span class="listing">getpagesize()</span>, welche in der Headerdatei <span class="listing">&lt;unistd. h.&gt;</span> definiert ist, ermitteln.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Der mapped-Bereich wird beim Erzeugen eines neuen Prozesses mittels <span class="listing">fork()</span> weitervererbt, da dieser Bereich teil vom Adressraum des Prozesses ist.</p>
</td>
</tr>
</table><br>
<p>Freigeben k&ouml;nnen Sie einen Speicherbereich wieder mit der Funktion <span class="listing">munmap()<a id="Xxx999368" name="Xxx999368"></a></span>:</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
int munmap(void *addr, size_t len);</pre>
<p>Damit heben Sie den von <span class="listing">mmap()</span> zur&uuml;ckgegebenen Speicherbereich <span class="listing">addr</span> mit <span class="listing">len</span> Bytes wieder auf.</p>
<p>Jetzt k&ouml;nnten Sie bspw. mit der Funktion <span class="listing">memcpy()</span> einen zum Lesen und einen zum Schreiben angelegten mapped-Speicherbereich kopieren. Damit eine Ver&auml;nderung im mapped-Speicherbereich jetzt auch in die dazugeh&ouml;rende Datei &uuml;bertragen wird, ben&ouml;tigten Sie die Funktion <span class="listing">msync()<a id="Xxx999373" name="Xxx999373"></a></span>.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
int msync(void *addr, size_t len, int flags);</pre>
<p>Die ersten beiden Argumente legen wieder den Speicherbereich fest, auf den die Aktion ausgef&uuml;hrt werden soll (Sie k&ouml;nnen also auch nur Teile synchronisieren). Die Art der Synchronisation legen Sie mit <span class="listing">flags</span> fest. Folgende Angaben, welche sich auch mit dem bitweisen ODER verkn&uuml;pfen lassen, sind hierf&uuml;r m&ouml;glich:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> MS_ASYNC</span> – Ge&auml;nderter mapped-Bereich soll sobald wie m&ouml;glich synchronisiert werden.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> MS_SYNC</span> – Ge&auml;nderter mapped-Bereich soll sofort synchronisiert werden (somit schlie&szlig;en sich <span class="listing">MS_ASYNC</span> und <span class="listing">MS_SYNC</span> gegenseitig aus).</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> MS_INVALIDATE</span> – Der Kernel soll selbst entscheiden, wann und ob &uuml;berhaupt synchronisiert wird – dies eignet sich f&uuml;r &Auml;nderungen, die nicht zwingend in die Datei &uuml;bernommen werden m&uuml;ssen.</td>
</tr>
</table>
<p>Hierzu ein Beispiel, welches Ihnen mit der selbst geschriebenen <span class="listing">write3()</span>-Funktion zeigen soll, wie Sie das Kopieren einer ganzen Datei mithilfe von zwei eingerichteten mapped-Speicherbereichen realisieren k&ouml;nnen:</p>
<pre><a id="Xxx999380" name="Xxx999380"></a>/* cpy_file_mmap.c */
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
static void write3 (int fd_quelle, int fd_ziel) {
   struct stat statptr;
   char *quelle, *ziel;
   /* Gr&ouml;&szlig;e der Quelldatei ermitteln */
   if (fstat (fd_quelle, &amp;statptr) &lt; 0) {
      perror ("stat");
      exit (EXIT_FAILURE);
   }
   /* Dateigr&ouml;&szlig;e f&uuml;r Ziel */
   if (lseek (fd_ziel, statptr.st_size - 1, SEEK_SET) == -1) {
      perror ("lseek");
      exit (EXIT_FAILURE);
   }
    /* Am Ende der neuen Datei(gr&ouml;&szlig;e) ein Byte schreiben */
   write (fd_ziel, " ", 1);
    /* mapped-Bereich f&uuml;r Quelldatei einrichten  */
   if ((quelle =
        mmap (0, statptr.st_size, PROT_READ, MAP_SHARED,
              fd_quelle, 0)) == -1) {
      perror ("mmap");
      exit (EXIT_FAILURE);
   }
    /* mapped-Bereich f&uuml;r Zieldatei einrichten */
   if ((ziel =
        mmap (0, statptr.st_size, PROT_READ | PROT_WRITE,
              MAP_SHARED, fd_ziel, 0)) == -1) {
      perror ("mmap");
      exit (EXIT_FAILURE);
   }
   /* Daten vom Hauptspeicherbereich quelle in den */
   /* Hauptspeicherbereich ziel kopieren           */
   memcpy (ziel, quelle, statptr.st_size);
   /* Denn neu kopierten mapped-Bereich auch f&uuml;r   */
   /* die Datei aktuallisieren                     */
   if ((msync (ziel, statptr.st_size, MS_ASYNC)) == -1) {
      perror ("msync");
      exit (EXIT_FAILURE);
   }
    /* mapped-Bereich wieder freigeben */
   munmap (quelle, statptr.st_size);
   munmap (ziel, statptr.st_size);
}
int main (int argc, char **argv) {
   int fd_r, fd_w;      /* Filedeskriptoren */
   /* Zugriffsrechte f&uuml;r die neue Datei: -rw-rw-r-- */
   mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;
   char *read_file, *write_file;
   /* Alle Zugriffsrechte der Dateikreierungsmaske erlauben */
   umask (0);
   if (argc &lt; 3) {
      fprintf (stderr, "Usage: %s quelle ziel\n", argv[0]);
      return EXIT_FAILURE;
   }
   read_file = argv[1];
   write_file = argv[2];
   fd_r = open (read_file, O_RDONLY);
   fd_w = open (write_file, O_RDWR | O_EXCL | O_CREAT, mode);
   if ((fd_r == -1) || (fd_w == -1)) {
      perror ("Fehler bei open : ");
      return EXIT_FAILURE;
   }    
   write3 (fd_r, fd_w);    
   close(fd_r);
   close(fd_w);
   return EXIT_SUCCESS;
}</pre>
<p>Neben den eben gezeigten Funktionen sind dem Superuser auch mapped-Funktionen an die Hand gegeben, womit das Auslagern von Speicherbereichen, bei Ermangelung des Hauptspeichers, in einen so genannten Swap-Bereich auf die Festplatte verhindert werden kann. Damit k&ouml;nnen Sie bis max. <span class="listing">RLIMIT_MEMLOCK</span> Bytes (siehe Ressourcen-Limits) sperren. Folgende Funktionen sind dabei f&uuml;r das Sperren und wieder Aufheben von Speicherbereichen vorhanden.</p>
<pre>#include &lt;sys/mman.h&gt;
int mlock<a id="Xxx999384" name="Xxx999384"></a>(void *addr, size_t len);
int memlockall<a id="Xxx999385" name="Xxx999385"></a>(int flags);
int munlock<a id="Xxx999386" name="Xxx999386"></a>(void *addr, size_t len);
int munlockall<a id="Xxx999387" name="Xxx999387"></a>(void);</pre>
<p>Mit <span class="listing">mlock()</span> k&ouml;nnen Sie einen Speicherbereich der Adresse <span class="listing">addr</span> mit <span class="listing">len</span> Bytes Gr&ouml;&szlig;e sperren. Wobei immer nur ganze Pages (Speicherseiten) gesperrt werden k&ouml;nnen. Bei Dateien unter der Page-Gr&ouml;&szlig;e wird automatisch die komplette Datei gesperrt.</p>
<p>Mit <span class="listing">mlockall()</span> wird der gesamte Adressraum des Prozesses gesperrt. Als Flags k&ouml;nnen Sie zus&auml;tzlich <span class="listing">MCL_CURRENT</span> angeben, womit alle Seiten (Pages) gesperrt werden, die sich im Augenblick im Hauptspeicher befinden. Mit <span class="listing">MCL_FUTURE</span> werden alle Pages gesperrt, die in Zukunft noch zum Adressraum hinzugef&uuml;gt werden. Beide Flags mit dem bitweisen ODER verkn&uuml;pft garantieren Ihnen, dass die komplette Datei (auch bei Gr&ouml;&szlig;en&auml;nderung) sich immer im Hauptspeicher befindet und niemals ausgelagert wird. Mit den beiden Funktionen <span class="listing">munlockall()</span> und <span class="listing">munlock()</span> heben Sie die jeweils mit <span class="listing">mlockall()</span> und <span class="listing">mlock()</span> gesetzten Sperren wieder auf.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap18B-002.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap18B-004.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap18B-003.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 20:00:27 GMT -->
</html>
