<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap02-004.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:57:10 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – 2.5 Mit Verzeichnissen arbeiten</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap02-003.html">
<link rel="next" href="Kap02-005.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap02-003.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap02-005.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="Kap02-000.html#RxxKap02000040000AE1F02D100">2 E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-000.html#RxxKap02000040000AE1F02D107">2.1 Elementare E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-001.html#RxxKap02001040000CB1F04C100">2.2 Filedeskriptor</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-001.html#RxxKap02001040000CB1F04C115">2.2.1 Verwaltung f&uuml;r offene Deskriptoren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-002.html#RxxKap02002040000CC1F023100">2.3 Funktionen, die den Filedeskriptor verwenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F023102">2.3.1 Datei &ouml;ffnen – open()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0231D2">2.3.2 Anlegen einer neuen Datei – creat()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0231D7">2.3.3 Datei schlie&szlig;en – close()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0231DB">2.3.4 Schreiben von Dateien – write()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0231EF">2.3.5 Lesen von Dateien – read()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0231FA">2.3.6 Schreib-/Lesezeiger positionieren – lseek()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F023214">2.3.7 Duplizieren von Filedeskriptoren – dup() und dup2()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F023220">2.3.8 &Auml;ndern oder Abfragen der Eigenschaften eines Filedeskriptors – fcntl()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F023259">2.3.9 Record Locking – Sperren von Dateien einrichten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0232AF">2.3.10 Multiplexing E/A – select()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0232C4">2.3.11 Unterschiedliche Operationen – ioctl()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0232CD">2.3.12 Lesen und Schreiben mehrerer Puffer – writev() und readv()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-002.html#RxxKap02002040000CC1F0232DA">2.3.13 &Uuml;bersicht zu weiteren Funktionen, die den Filedeskriptor verwenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-003.html#RxxKap02003040000CD1F024100">2.4 Standard-E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024103">2.4.1 Der FILE-Zeiger</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024115">2.4.2 &Ouml;ffnen und Schlie&szlig;en von Dateien</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0241DC">2.4.3 Formatierte Ausgabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0241FD">2.4.4 Formatierte Eingabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F02420E">2.4.5 Bin&auml;res Lesen und Schreiben</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024212">2.4.6 Zeichen- und zeilenweise Ein-/Ausgabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024259">2.4.7 Status der Ein-/Ausgabe &uuml;berpr&uuml;fen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F02425D">2.4.8 Stream positionieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024282">2.4.9 Puffer kontrollieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0242A1">2.4.10 Datei l&ouml;schen und umbenennen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0242A7">2.4.11 Tempor&auml;re Dateien erstellen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap02004040000CE1F049100">2.5 Mit Verzeichnissen arbeiten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F049102">2.5.1 Ein neues Verzeichnis anlegen – mkdir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F04910C">2.5.2 In ein Verzeichnis wechseln – chdir(), fchdir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F049175">2.5.3 Ein leeres Verzeichnis l&ouml;schen – rmdir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F04917B">2.5.4 Format eines Datei-Eintrags in struct dirent</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F04918E">2.5.5 Einen Verzeichnisstream &ouml;ffnen – opendir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F04919C">2.5.6 Lesen aus dem DIR-Stream – opendir() und Schlie&szlig;en des DIR-Streams – closedir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F0491AF">2.5.7 Positionieren des DIR-Streams</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F0491B9">2.5.8 Komplettes Verzeichnis einlesen – scandir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02004040000CE1F0491CF">2.5.9 Ganze Verzeichnisb&auml;ume durchlaufen – ftw()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-005.html#RxxKap02005040000CF1F011100">2.6 Fehlerbehandlung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-006.html#RxxKap02006040000D01F01A100">2.7 Ausblick</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">2.5 <a id="RxxKap02437MitVerzeichnissenarbeiten" name="RxxKap02437MitVerzeichnissenarbeiten"></a>Mit Verzeichnissen arbeite<a id="RxxKap02004040000CE1F049100" name="RxxKap02004040000CE1F049100"></a>n 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p><a id="Xxx999235" name="Xxx999235"></a>In gewisser Weise stellen die Aktionen auf Verzeichnisse auch eine Art Ein-/Ausgabe dar. Sie k&ouml;nnen ein neues Verzeichnis anlegen oder l&ouml;schen, in ein Verzeichnis wechseln oder daraus lesen. Da Linux (und UNIX) ja in gewisser Weise nicht zwischen Dateien und Verzeichnisse unterscheidet, gelten hier auch &auml;hnliche Zugriffsrechte, wie Sie diese schon bei den Dateien kennen gelernt haben. Nur hat man mit den Zugriffsrechten f&uuml;r ein Verzeichnis »vier Rechte« (<span class="listing">rwxt</span>), eine Datei nur zwei »<span class="listing">rw</span>« (das »<span class="listing">x</span>« von der Datei kann man sich immer selbst hinzuf&uuml;gen - au&szlig;er SUID-Dateien -, indem man die Datei ins Homeverzeichnis kopiert. Beim Verzeichnis haben Sie: lesen (<span class="listing">r</span>), Datei anlegen/l&ouml;schen (<span class="listing">w</span>), ins Verzeichnis reingehen (<span class="listing">x</span>), Datei bedingt l&ouml;schen (<span class="listing">t</span>/<span class="listing">!t</span>). Lesen ist nur m&ouml;glich, wenn man in ein Verzeichnis eintreten kann, weshalb oben »<span class="listing">rx</span>« steht.</p>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t32"></a><h3 class="t3">2.5.1 Ein neues Verzeichnis anlegen – mkdir()<a id="RxxKap02004040000CE1F049102" name="RxxKap02004040000CE1F049102"></a><a id="Xxx999237" name="Xxx999237"></a> 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999239" name="Xxx999239"></a>Um ein neues Verzeichnis anzulegen, k&ouml;nnen Sie die Funktion <span class="listing">mkdir()</span> verwenden.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
int mkdir(const char *pfadname, mode_t modus);</pre>
<p>Damit legen Sie ein neues Verzeichnis mit dem Namen <span class="listing">pfadnamen</span> und dem Modus <span class="listing">mode</span> (abz&uuml;glich aktuelle umask) an (»<span class="listing">.</span>« und »<span class="listing">..</span>« sind sowieso Pseudo-Eintr&auml;ge und daher immer pr&auml;sent; sie m&uuml;ssen also nicht erstellt werden). Sehr wichtig ist es auch, dass Sie beim Modus entsprechende Execute-Bits setzen (m&uuml;ssen), um &uuml;berhaupt auf das Verzeichnis zugreifen zu k&ouml;nnen. Hierzu nun ein kleines Listing zur Demonstration:</p>
<pre><a id="Xxx999243" name="Xxx999243"></a>/* mymkdir.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
int main(int argc, char **argv) {
   mode_t mode = S_IRWXU;
   if(argc &lt; 2) {
         printf("USAGE: %s neues_verzeichnis\n",*argv);
         return EXIT_FAILURE;
      }
   // Alle Zugriffsrechte der Einschr&auml;nkungsmaske erlauben
   umask(0);
   if( (mkdir( argv[1], mode)) != -1 )
      printf("Verzeichnis \"%s\" erfolgreich erstellt\n",
         argv[1]);
   else
      printf("Konnte Verzeichnis nicht erstellen (%s)\n",
         strerror(errno));
   return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o mymkdir mymkdir.c
$ ./mymkdir
usage: mymkdir neues_verzeichnis
$ ./mymkdir test
Verzeichnis "test" erfolgreich erstellt
$ ls -ld test
drwx------    2 tot      users          48 2003–10–28 23:31 test
$ ./mymkdir test
Konnte Verzeichnis nicht erstellen (File exists)</pre>
<p>Sofern versucht wird, ein Verzeichnis zu erstellen, das bereits existiert, wird dies fehlschlagen (wie Sie bei der Ausf&uuml;hrung des Programms sehen konnten). <span class="listing">errno</span> wird dann auf einen entsprechenden Wert gesetzt. Mehr zu <span class="listing">errno</span> erfahren Sie am Ende des Kapitels.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Wollen Sie beim Erstellen eines Verzeichnisses bestimmte Zugriffsrechte vergeben, m&uuml;ssen Sie nat&uuml;rlich auch hier, wie bei den Dateien, die Einschr&auml;nkungsmaske ber&uuml;cksichtigen bzw. entsprechend setzen (siehe <span class="listing">umask()</span>).</p>
</td>
</tr>
</table><br>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t33"></a><h3 class="t3">2.5.2 In ein Verzeichnis wechseln – chdir(), fchdir()<a id="RxxKap02004040000CE1F04910C" name="RxxKap02004040000CE1F04910C"></a> 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999253" name="Xxx999253"></a><a id="Xxx999254" name="Xxx999254"></a><a id="Xxx999255" name="Xxx999255"></a>Wollen Sie w&auml;hrend der Programmausf&uuml;hrung in ein anderes Verzeichnis wechseln, so l&auml;sst sich dies mit den Funktionen <span class="listing">chdir()</span> bzw. <span class="listing">fchdir()</span> bewerkstelligen.</p>
<pre>#include &lt;unistd. h.&gt;
int chdir(const char *pfad);
int fchdir(int fd);</pre>
<p>Bei Erfolg geben beide Funktionen 0, ansonsten bei einem Fehler -1 zur&uuml;ck. <span class="listing">fchdir()</span> erwartet im Gegensatz zu <span class="listing">chdir()</span>, anstatt eines relativen oder absoluten Pfadnamens, einen Filedeskriptor. Mit diesen Funktionen kann allerdings nur immer das aktuelle Arbeitsverzeichnis des Prozesses gewechselt werden. Sobald sich das Programm beendet, wird automatisch wieder in das Elternverzeichnis zur&uuml;ck gewechselt, von wo der Prozess gestartet wurde.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b><span class="listing">fchdir()</span> ist kein Standard von POSIX und wird nur von SVR4 und 4.4BSD angeboten. F&uuml;r »wird nur von … angeboten« gilt jedoch, dass es auch in der GNU C-Bibliothek (GLIBC) und somit auch f&uuml;r Linux verf&uuml;gbar ist ...!</p>
</td>
</tr>
</table><br>
<p>Hierzu, erweitert, das Beispiel des vorherigen Abschnitts. Es soll in das neu erstellte Verzeichnis mit <span class="listing">chdir()</span> gewechselt werden.</p>
<pre><a id="Xxx999264" name="Xxx999264"></a>/* mychdir.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#define MAX 256
int main(int argc, char **argv) {
   mode_t mode = S_IRWXU;
   char wd[MAX];
   if(argc &lt; 2) {
         printf("USAGE: %s neues_verzeichnis\n",*argv);
         return EXIT_FAILURE;
      }
   // Alle Zugriffsrechte der Einschr&auml;nkungsmaske erlauben
   umask(0);
   if( (mkdir( argv[1], mode)) != -1 )
      printf("Verzeichnis \"%s\" erfolgreich erstellt\n",
         argv[1]);
   else
      printf("Konnte Verzeichnis nicht erstellen (%s)\n",
         strerror(errno));
   if( (chdir(argv[1]) ) == -1)
      printf("Konnte das Verzeichnis nicht wechseln\n");
   if( NULL != getcwd(wd, MAX) )
      printf("Neues Arbeitsverzeichnis: %s\n",wd);
   return EXIT_SUCCESS;
}</pre>
<p>Das Beispiel im Einsatz:</p>
<pre>$ gcc -o mychdir mychdir.c
$ ./mychdir test
Verzeichnis "test" erfolgreich erstellt
Neues Arbeitsverzeichnis: /home/tot/test
$ pwd
/home/tot</pre>
<p><a id="Xxx999268" name="Xxx999268"></a>In diesem Beispiel wurde auch gleich die Funktion <span class="listing">getcwd()<a id="Xxx999269" name="Xxx999269"></a></span> verwendet. Damit l&auml;sst sich ermitteln, in welchem Arbeitsverzeichnis sich der laufende Prozess gerade befindet. Gleiches erreichen Sie in der Kommandozeile mit <span class="listing">pwd</span>, wie eben demonstriert. Hier die Syntax zu <span class="listing">getcwd()</span>:</p>
<pre>#include &lt;unistd. h.&gt;
char *getcwd(char *puffer, size_t size);</pre>
<p>Damit wird an die Speicheradresse <span class="listing">puffer</span> der Pfadname des aktuellen Arbeitsverzeichnisses geschrieben. Die Gr&ouml;&szlig;e des Puffers wird mit <span class="listing">size</span> angegeben. Bei einem Fehler gibt diese Funktion den <span class="listing">NULL</span>-Zeiger zur&uuml;ck.</p>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t34"></a><h3 class="t3">2.5.3 Ein leeres Verzeichnis l&ouml;schen – rmdir()<a id="RxxKap02004040000CE1F049175" name="RxxKap02004040000CE1F049175"></a> 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999274" name="Xxx999274"></a>Zum L&ouml;schen eines bereits leeren Verzeichnisses k&ouml;nnen Sie die Funktion <span class="listing">rmdir()<a id="Xxx999275" name="Xxx999275"></a></span> verwenden.</p>
<pre>#include &lt;unistd. h.&gt;
int rmdir(const char *pfadname);</pre>
<p>Konnte das Verzeichnis <span class="listing">pfadname</span> gel&ouml;scht werden, gibt diese Funktion 0, ansonsten bei einem Fehler –1 zur&uuml;ck. Wenn Grundkenntnisse unter Linux/UNIX vorhanden sind, wissen Sie, dass das Verzeichnis erst dann gel&ouml;scht werden kann, wenn es leer ist. Absolut »leer« hei&szlig;t, es d&uuml;rfen nur noch die Eintr&auml;ge <span class="listing">.</span> und <span class="listing">..</span> enthalten sein. L&ouml;schen Sie ein Verzeichnis mit der Funktion <span class="listing">rmdir()</span>, w&auml;hrend ein anderer Prozess auf dieses Verzeichnis zugreift und eine Datei anlegen will, so schl&auml;gt das Anlegen der Datei fehl (trotzdem aber existiert das Verzeichnis immer noch auf der Festplatte, da ja ein Programm drauf zugreift). Denn wenn der Linkz&auml;hler des Verzeichnisses auf 0 steht, sind die beiden Verzeichnislinks <span class="listing">.</span> und <span class="listing">..</span> bereits gel&ouml;scht. Daher ist es nicht mehr m&ouml;glich, eine Datei anzulegen. Dennoch kann ein Prozess immer noch Dateien aus dem einen Verzeichnis namens /tmp/abc/* offen haben, w&auml;hrend /tmp/abc schon l&auml;ngst mit rm -Rf gel&ouml;scht wurde!</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis am Rande zu ».« und »..«</b>  Es sind Pseudo-Eintr&auml;ge, die nicht gel&ouml;scht werden k&ouml;nnen. </p>
</td>
</tr>
</table><br>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t35"></a><h3 class="t3">2.5.4 Format eines Datei-Eintrags in struct dirent<a id="RxxKap02004040000CE1F04917B" name="RxxKap02004040000CE1F04917B"></a> 
      <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Nachdem Sie erfahren haben, wie Sie ein Verzeichnis erstellen, in dieses wechseln und dieses wieder l&ouml;schen k&ouml;nnen, werden Sie sich wohl gefragt haben, wie so ein Eintrag einer Datei in einem Verzeichnis aussieht. POSIX schreibt diese Struktur vor und sollte in der Headerdatei <span class="listing">dirent.h</span> definiert sein. Diese Struktur ben&ouml;tigen Sie, wenn Sie Informationen zu einem Verzeichniseintrag ben&ouml;tigen. Die Struktur k&ouml;nnte folgenderma&szlig;en aussehen:</p>
<pre>struct dirent {
   ino_t d_ino;
   unsigned char d_type;
   unsigned char d_namlen;
   char d_name[NAME_MAX+1];
};</pre>
<p>Wobei die einzige Komponente, die auf wirklich jedem POSIX-System vorhanden ist, die Strukturvariable <span class="listing">d_name</span> ist. Diese Komponente ist ein <span class="listing">\0</span>-terminierter Dateiname mit einer Gr&ouml;&szlig;e von <span class="listing">NAME_MAX+1</span> Zeichen. Die Konstante <span class="listing">NAME_MAX</span> ist in der Regel mit einem Wert von mindestens 255 definiert. Dies h&auml;ngt davon ab, welche L&auml;nge f&uuml;r Dateinamen auf dem System zul&auml;ssig ist.</p>
<p>Bei der Strukturvariablen <span class="listing">d_ino</span> handelt es sich um die Inode-Nummer (darauf wird noch eingegangen), und <span class="listing">d_namlen</span> (wie gesagt, nicht POSIX) beinhaltet die aktuelle L&auml;nge des Eintrags in <span class="listing">d_name</span> ohne das Stringendezeichen.</p>
<p>Die Strukturvariable <span class="listing">d_type</span> beinhaltet die Art der Datei. Dabei sind folgende Konstanten m&ouml;glich:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_UNKNOWN<a id="Xxx999289" name="Xxx999289"></a></span> – unbekannt</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_REG<a id="Xxx999291" name="Xxx999291"></a></span> – normale Datei</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_DIR<a id="Xxx999293" name="Xxx999293"></a></span> – ein Verzeichnis</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_FIFO<a id="Xxx999295" name="Xxx999295"></a></span> – eine benannte Pipe oder ein FIFO</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_SOCK<a id="Xxx999297" name="Xxx999297"></a></span> – ein Socket</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_CHR<a id="Xxx999299" name="Xxx999299"></a></span> – zeichenorientierte Ger&auml;tedatei</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> DT_BLK<a id="Xxx999301" name="Xxx999301"></a></span> – blockorientierte Ger&auml;tedatei</td>
</tr>
</table>
<p>Diese symbolischen Konstanten sind bis jetzt nur unter BSD vorhanden. Dies k&ouml;nnen Sie am besten selbst mit einer bedingten Kompilierung wie folgt &uuml;berpr&uuml;fen:</p>
<pre>#include &lt;dirent.h&gt;
#ifdef _DIRENT_HAVE_D_TYPE
   #define HAVE_D_TYPE 1  /* Let's rock */
#else 
   #define HAVE_D_TYPE 0  /* ansonsten bleibt nur struct stat */
#endif</pre>
<p>Ist die symbolische Konstante <span class="listing">_DIRENT_HAVE_D_TYPE</span> gesetzt, k&ouml;nnen Sie die Strukturvariable <span class="listing">d_type</span> verwenden. Ansonsten m&uuml;ssen Sie die Art der Datei wie &uuml;blich &uuml;ber <span class="listing">st_mode</span> aus der <span class="listing">struct</span> <span class="listing">stat</span> ermitteln (siehe Kapitel 3). Kann die Art der Datei nicht mit <span class="listing">d_type</span> ermittelt werden, wird die Strukturvariable auf <span class="listing">DT_UNKNOWN</span> gesetzt. In absehbarer Zukunft d&uuml;rften aber alle Systeme auf <span class="listing">d_type</span> zugreifen k&ouml;nnen (Ausnahme: Old-Timer-Betriebssysteme, die nicht mehr mit Updates erneuert werden k&ouml;nnen).</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>M&uuml;ssen Sie die Strukturvariable <span class="listing">d_type</span> in einen <span class="listing">st_mode</span>-Wert der Struktur <span class="listing">stat</span> konvertieren oder umgekehrt, dann sollten Sie sich die Makros <span class="listing">IFTODT()<a id="Xxx999309" name="Xxx999309"></a></span> und <span class="listing">DTTOIF()<a id="Xxx999310" name="Xxx999310"></a></span> ansehen, die ebenfalls in der Headerdatei <span class="listing">&lt;dirent.h&gt;<a id="Xxx999311" name="Xxx999311"></a></span> definiert sind.</p>
</td>
</tr>
</table><br>
<p>Ben&ouml;tigen Sie au&szlig;erdem weitere Attribute, wie z. B. die Gr&ouml;&szlig;e oder die letzte Ver&auml;nderung einer Datei, so m&ouml;chte ich Sie hierzu auf das Kapitel der Dateiattribute verweisen (Kapitel 3).</p>
<a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t36"></a><h3 class="t3">2.5.5 Einen Verzeichnisstream &ouml;ffnen – opendir()<a id="RxxKap02004040000CE1F04918E" name="RxxKap02004040000CE1F04918E"></a> 
      <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999315" name="Xxx999315"></a>Um einen Stream zu einem Verzeichnis zu erhalten, schreibt POSIX vor, den <span class="listing">DIR</span>-Datentyp zu verwenden, der eine interne Struktur darstellt, auf den die noch folgenden Funktionen ebenfalls zugreifen. Wer hier &Auml;hnlichkeiten mit dem <span class="listing">FILE</span>-Stream oder einem Filedeskriptor sieht, liegt gar nicht so falsch. Fr&uuml;her wurden Verzeichnisse auch auf diese Art gelesen. Man verwendete z. B. <span class="listing">open()</span> oder <span class="listing">fopen()</span> zum &Ouml;ffnen des Arbeitsverzeichnisses (<span class="listing">.</span>) und hatte anschlie&szlig;end die Struktur <span class="listing">dirent</span> mit <span class="listing">read()</span> oder <span class="listing">fread()</span> ausgelesen. Dies hat dann in etwa wie folgt ausgesehen:</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(void) {
    FILE *fp;
    struct dirent *dir;
    int n;
    /* Veraltete Methode–sollte nicht mehr funktionieren! */
    if ((fp = fopen(".", "r")) == NULL) {
           perror("current directory");
           exit(EXIT_FAILURE);
        }
    while((n=fread(dir, sizeof(struct dirent), 1, fp)) &gt;0) {
           if (dir-&gt;d_ino == 0)
               continue;
           printf("%.*s\n", NAME_MAX+1, dir-&gt;d_name);
        }
    fclose(fp);
    return EXIT_SUCCESS;
}</pre>
<p>Da allerdings mit der Zeit immer mehr neue Systeme und somit auch immer unterschiedlichere und systemabh&auml;ngigere Verzeichnisformate entwickelt wurden, musste man sich eine einheitlichere L&ouml;sung suchen. Kurzum, es sprang POSIX ein und schrieb die Funktionen <span class="listing">opendir()</span>, <span class="listing">readdir()</span>, <span class="listing">rewinddir()</span> und <span class="listing">closedir()</span> vor. Neu hinzugekommen sind auch die Funktionen <span class="listing">telldir()</span> und <span class="listing">seekdir()</span>. Wobei die letzten beiden Funktionen »nur« BSD-konform sind. Sicherlich h&auml;tte man sich diesbez&uuml;glich einen ANSI C-Standard gew&uuml;nscht, aber dies ist, wegen der vielen unterschiedlichen Verzeichnisformate auf den Systemen, ein recht hoffnungsloses Unterfangen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Hoffnungslos hei&szlig;t nat&uuml;rlich nicht aussichtslos. Entweder schreibt man f&uuml;r jedes System den entsprechenden Code oder nutzt eine plattform&uuml;bergreifende Bibliothek, z. B. die HXdir-Implementation von libHX, die einen <span class="listing">opendir()</span>-&auml;hnlichen Layer nebst Linux auch f&uuml;r DOS und Win 32 bereitstellt. Auf der Webseite des Fachgutachters (http://linux01.org:2222/prog-libHX.php) dieses Buches findet man einen solchen <span class="listing">opendir()</span>-Style-Layer.</p>
</td>
</tr>
</table><br>
<p>Hier die Syntax zur Funktion <span class="listing">opendir()<a id="Xxx999323" name="Xxx999323"></a></span>:</p>
<pre>#include &lt;dirent.h&gt;
#include  &lt;sys/types.h&gt;
DIR *opendir(const char *dirname);</pre>
<p>Die Funktion gibt bei Erfolg den <span class="listing">DIR<a id="Xxx999326" name="Xxx999326"></a></span>-Zeiger auf das ge&ouml;ffnete Verzeichnis <span class="listing">dirname</span> zur&uuml;ck. Bei einem Fehler wird der <span class="listing">NULL</span>-Zeiger zur&uuml;ckgegeben. Welcher Fehler aufgetreten ist, k&ouml;nnen Sie mit der Fehlervariablen <span class="listing">errno</span> auswerten.</p>
<p>Der Typ <span class="listing">DIR</span> ist intern als Filedeskriptor implementiert, und die <span class="listing">opendir()</span>-Funktion stellt im Prinzip nichts anderes als die elementare Funktion <span class="listing">open()</span> dar. Sicherlich ist Ihnen ein paar Seiten zuvor die Funktion <span class="listing">fchdir()</span> aufgefallen, die einen Filedeskriptor als Argument erwartet. Um aus einem <span class="listing">DIR</span>-Zeiger einen Filedeskriptor zu machen, bietet Ihnen die GNU C Library die Funktion <span class="listing">dirfd()<a id="Xxx999329" name="Xxx999329"></a></span> an.</p>
<pre>int dirfd(DIR *dirstream);</pre>
<p>Diese Funktion gibt den Filedeskriptor des <span class="listing">DIR</span>-Streams zur&uuml;ck, den Sie zuvor mit <span class="listing">opendir()</span> ge&ouml;ffnet haben:</p>
<pre>DIR *dp;
int fd;
dp = opendir( dirname );
if( dp != NULL ) {
      fd = dirfd( dp );
      if( fd == -1 )
         exit(EXIT_FAILURE);
   }
if( (fchdir(fd) ) == -1)
     printf("Konnte das Verzeichnis nicht wechseln\n");</pre>
<p>Bei einem Fehler gibt die Funktion <span class="listing">dirfd()</span> den Wert -1 zur&uuml;ck. <span class="listing">dirfd()</span> ist nicht Bestandteil von POSIX, sondern lediglich von BSD und SVR4.</p>
<a name="t36"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t37"></a><h3 class="t3">2.5.6 Lesen aus dem DIR-Stream – opendir()
und Schlie&szlig;en des DIR-Streams – closedir(<a id="RxxKap02004040000CE1F04919C" name="RxxKap02004040000CE1F04919C"></a>) 
      <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999335" name="Xxx999335"></a><a id="Xxx999336" name="Xxx999336"></a>Wenn Sie jetzt den <span class="listing">DIR</span>-Stream zuvor mit <span class="listing">opendir()</span> ge&ouml;ffnet haben, k&ouml;nnen Sie aus diesem mit der Funktion <span class="listing">readdir()</span> lesen. Hier die Syntax dazu<a id="Xxx999338" name="Xxx999338"></a><a id="Xxx999339" name="Xxx999339"></a>:</p>
<pre>#include &lt;dirent.h&gt;
#include  &lt;sys/types.h&gt;
struct dirent *readdir(DIR *dirstream);</pre>
<p>Damit wird immer der n&auml;chste Eintrag der Verzeichnisdatei vom <span class="listing">DIR</span>-Stream gelesen. Bei Erfolg wird ein Zeiger auf die Struktur <span class="listing">dirent</span> zur&uuml;ckgegeben oder bei einem Fehler <span class="listing">NULL</span>. Gew&ouml;hnlich wird die Funktion <span class="listing">readdir()</span> in einer Schleife eingesetzt, die so lange durchlaufen wird, bis nichts mehr zum Lesen vorhanden ist, also <span class="listing">NULL</span>.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Beachten Sie bitte, dass nicht auf jedem System das Arbeitsverzeichnis (<span class="listing">.</span>) und das Elternverzeichnis (<span class="listing">..</span>) mit ausgegeben werden. Linux f&auml;llt nicht darunter, denn was zu viel ist, kann man noch im Programm wegfiltern, was zu wenig ist, kann man sich nicht holen.</p>
</td>
</tr>
</table><br>
<p>Hierzu ein einfaches Listing, womit das aktuelle Arbeitsverzeichnis ausgelesen und ausgegeben wird. Des Weiteren wird versucht, sofern die symbolische Konstante <span class="listing">_DIRENT_HAVE_D_TYPE</span> gesetzt ist, zu ermitteln, ob es sich dabei um eine normale Datei oder um ein Verzeichnis handelt. Sofern bei Ihrem System <span class="listing">_DIRENT_HAVE_D_TYPE</span> gesetzt ist, aber (noch) nicht unterst&uuml;tzt wird, ist die Strukturvariable <span class="listing">d_type</span> auf <span class="listing">DT_UNKNOWN</span> gesetzt. Zum Ermitteln von Dateitypen und weiteren Attributen folgt extra ein Kapitel (Kapitel 3).</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b><span class="listing">readdir()</span> gibt nicht alphabetisch zur&uuml;ck, auch wenn das bei einer Ausgabe mit folgendem Listing so erscheinen mag. Zur&uuml;ckgegeben wird es so, wie das Dateisystem es abgelegt hat. Wer nat&uuml;rlich Dateien in alphabetischer Reihenfolge anlegt, kann sie durchaus auch im alphabetischen Zustand wieder holen. »ls« ist Ausnahme, da das Programm immer sortiert (Ausnahme: Option <span class="listing">-f</span>).</p>
</td>
</tr>
</table><br>
<pre><a id="Xxx999351" name="Xxx999351"></a>/* list_wd.c */
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
int main (void) {
  DIR *dp;
  struct dirent *ep;
  static int files = 0;
  dp = opendir (".");
  if (dp != NULL) {
      while ((ep = readdir (dp)) != NULL) {
#ifdef _DIRENT_HAVE_D_TYPE
           switch(ep-&gt;d_type) {
              case DT_REG     : printf("Normale Datei : ");
                                break;
              case DT_DIR     : printf("Verzeichnis   : ");
                                break;
              /* ... */
              case DT_UNKNOWN : printf("???       : ");
                                break;
              }  
#endif
           printf("%s\n", ep-&gt;d_name);
           files++;
        }
      closedir (dp);
    }
  else
      perror ("Kann Verzeichnis nicht &ouml;ffnen");
  printf("--- Insg. %d Dateien im Verzeichnis ---\n",files);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o list_wd list_wd.c
$ ./list_wd
???       : .
???       : ..
???       : .qt
???       : .ddd
???       : .kde
???       : .xim
???       : dir1
???       : dir2
???       : .netscape
???       : test
???       : Documents
...
...
??       : projects
???       : .xtalkrc
???       : out.txt
???       : Verzeichnisse.doc
???       : evolution
???       : .xsession-errors
--- Insg. 116 Dateien im Verzeichnis ---</pre>
<p>In diesem Fall ist die symbolische Konstante <span class="listing">_DIRENT_HAVE_D_TYPE</span> zwar gesetzt, aber immer auf <span class="listing">DT_UNKNOWN</span>.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Dateien, die mit einem Punkt beginnen, sind unter Linux/UNIX in der Regel nicht sichtbar (also mit »ls«), werden aber mit <span class="listing">readdir()</span> nat&uuml;rlich gelesen. Umsteiger von Windows k&ouml;nnen dies mit dem Attribut »Hidden -&gt; Versteckt« vergleichen.</p>
<p class="BStandard"><b>Hinweis   </b>Die Funktion <span class="listing">readdir()</span> eignet sich nicht zur Programmierung von Threads, da mehrere Threads, die denselben Verzeichnisstream verwenden, den R&uuml;ckgabewert &uuml;berschreiben. Bei den Threads werden die Funktion <span class="listing">readdir_r()<a id="Xxx999360" name="Xxx999360"></a></span> oder eben das libHX-Pendant empfohlen.</p>
</td>
</tr>
</table><br>
<p>Um einen <span class="listing">DIR</span>-Stream ordnungsm&auml;&szlig;ig nach der Verwendung wieder freizugeben, wird die Funktion <span class="listing">closedir()<a id="Xxx999363" name="Xxx999363"></a></span> eingesetzt.</p>
<pre>#include &lt;dirent.h&gt;
#include  &lt;sys/types.h&gt;
int closedir( DIR *dirstream );</pre>
<p>Konnte der Stream erfolgreich geschlossen werden, wird 0, ansonsten bei einem Fehler   -1 zur&uuml;ckgegeben.</p>
<a name="t37"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t38"></a><h3 class="t3">2.5.7 Positionieren des DIR-Streams<a id="RxxKap02004040000CE1F0491AF" name="RxxKap02004040000CE1F0491AF"></a> 
      <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999367" name="Xxx999367"></a>Ebenfalls wie schon bei den elementaren und Standard-E/A-Funktionen gibt es auch f&uuml;r den <span class="listing">DIR</span>-Zeiger eine M&ouml;glichkeit, die Position zu ver&auml;ndern.</p>
<p>Wollen Sie den <span class="listing">DIR</span>-Stream wieder an den Anfang setzen, so dass <span class="listing">readdir()</span> wieder beim ersten Verzeichniseintrag anf&auml;ngt zu lesen, k&ouml;nnen Sie die Funktion <span class="listing">rewinddir()</span> benutzen<a id="Xxx999370" name="Xxx999370"></a>.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
void rewinddir( DIR *dirstream );</pre>
<p>Die aktuelle Position des <span class="listing">DIR</span>-Streams k&ouml;nnen Sie mit der Funktion <span class="listing">telldir()</span> ermitteln.<a id="Xxx999372" name="Xxx999372"></a></p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
off_t telldir (DIR *dirstream) ;</pre>
<p>Es wird empfohlen, den R&uuml;ckgabewert sp&auml;ter wieder mit der Funktion <span class="listing">seekdir()</span> zum Zur&uuml;cksetzen dieser Position zu verwenden. Die Syntax zu <span class="listing">seekdir()</span>:<a id="Xxx999376" name="Xxx999376"></a></p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
void seekdir (DIR *dirstream, off_t pos);</pre>
<p>Damit setzen Sie den <span class="listing">DIR</span>-Zeiger auf die Position von <span class="listing">pos</span>. <span class="listing">pos</span> muss ein Wert sein, den Sie zuvor mit der Funktion <span class="listing">telldir()</span> ermittelt haben oder der im G&uuml;ltigkeitsbereich liegt. Welche Werte jedoch g&uuml;ltig sind, verr&auml;t uns auch nicht die Man-Page.</p>
<p>Beide Funktionen, <span class="listing">telldir()</span> und <span class="listing">seekdir()</span>, sind nicht POSIX-konform und nur in BSD4.3 vorhanden.</p>
<a name="t38"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t39"></a><h3 class="t3">2.5.8 Komplettes Verzeichnis einlesen – scandir()<a id="RxxKap02004040000CE1F0491B9" name="RxxKap02004040000CE1F0491B9"></a> 
      <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999381" name="Xxx999381"></a>Eine Funktion auf einer etwas h&ouml;heren Ebene ist <span class="listing">scandir()</span>. Wobei man gleich anmerken muss, dass diese Funktion auch nicht dem POSIX-Standard entspricht. Aber da diese doch auf jedem Linux-System vorhanden ist, sollte sie hier erw&auml;hnt werden. Hierzu die Syntax:<a id="Xxx999383" name="Xxx999383"></a></p>
<pre>#include &lt;dirent.h&gt;
int scandir( const char *dirname, struct dirent **namelist, 
             int (*selector) (const struct dirent *), 
             int (*cmp) (const void *, const void *)   ) ;</pre>
<p>Mit dieser Funktion lesen Sie die Eintr&auml;ge des Verzeichnisses <span class="listing">dirname</span> ein. Als Ergebnis finden Sie alle Eintr&auml;ge eines Verzeichnisses in <span class="listing">*namelist</span>, einem Array von Zeigern des Typs <span class="listing">struct</span> <span class="listing">dirent</span>. Die Funktion nimmt die dynamische Speicherreservierung f&uuml;r <span class="listing">*namelist</span> automatisch vor. Freigeben m&uuml;ssen Sie den Speicherplatz allerdings wieder selbst mittels <span class="listing">free()</span>. Bei einem Programm, das sich nach dem Einlesen der Verzeichniseintr&auml;ge gleich wieder beendet, ist es nicht so schlimm, wenn Sie den Speicher nicht mehr freigeben, da dieser bei Beendigung automatisch wieder freigegeben wird (verfallen Sie aber blo&szlig; nicht in diese Gewohnheit bei Programmen, die l&auml;nger als »trivial« sind!). Bei dauerhaft laufenden Programmen schaffen Sie ein klassisches Speicherleck (engl. Memory Leak), wenn Sie den zugeteilten Speicher nicht wieder freigeben.</p>
<p>Die Eintr&auml;ge in <span class="listing">*namelist</span> werden au&szlig;erdem von der Funktion <span class="listing">cmp</span> sortiert. Da diese Funktion zwei Argumente vom Typ <span class="listing">struct</span> <span class="listing">dirent</span> <span class="listing">**</span> vergleichen muss, sind die Funktionen <span class="listing">strcmp()</span> oder <span class="listing">strcoll()</span> nicht direkt daf&uuml;r geeignet. Sie sollten stattdessen die implementierten Funktionen <span class="listing">alphasort()<a id="Xxx999387" name="Xxx999387"></a></span> oder <span class="listing">versionsort()<a id="Xxx999388" name="Xxx999388"></a></span> verwenden. Mehr zu den Sortierfunktionen finden Sie in den entsprechenden Manual-Pages. Im anschlie&szlig;enden Beispiel werden Sie <span class="listing">alphasort()</span> verwenden, womit die einzelnen Eintr&auml;ge alphabetisch sortiert werden.</p>
<p>Wollen Sie nur bestimmte Verzeichniseintr&auml;ge bearbeiten oder ausgeben lassen, k&ouml;nnen Sie mit der Funktion <span class="listing">selector</span> eine eigene Funktion verwenden und selbst entscheiden, welche Eintr&auml;ge ausgew&auml;hlt werden. Es werden dabei nur die Eintr&auml;ge ausgew&auml;hlt, bei denen nicht 0 zur&uuml;ckgegeben wird. Diese Eintr&auml;ge befinden sich dann ebenfalls in <span class="listing">*namelist</span>. Nat&uuml;rlich m&uuml;ssen Sie sich auch hierbei keine Gedanken bez&uuml;glich der Speicherreservierung machen, aber wiederum schon um das Freigeben des Speichers!</p>
<p>Der R&uuml;ckgabewert der Funktion <span class="listing">scandir()</span> ist die Anzahl der erfolgreichen Eintr&auml;ge, die in <span class="listing">*namelist</span> platziert wurden. Bei einem Fehler wird -1 zur&uuml;ckgegeben. Da hier mehrere Fehler auftreten k&ouml;nnen (wie z. B. kein Zugriff auf das Verzeichnis oder keine Speicherreservierung mit <span class="listing">malloc</span> ... m&ouml;glich), sollten Sie die globale Fehlervariable <span class="listing">errno</span> abfragen.</p>
<p>Genug der gro&szlig;en Worte. Lassen Sie uns zur Tat schreiten. Das folgende Beispiel demonstriert, wie Sie mit der Funktion <span class="listing">scandir()</span> ein komplettes Verzeichnis mit nur einem Funktionsaufruf einlesen k&ouml;nnen. Nach dem Funktionsaufruf befinden sich alle Verzeichniseintr&auml;ge in <span class="listing">namelist</span>. Wenn Sie das Programm ohne Argumente aufrufen, wird das aktuelle Arbeitsverzeichnis eingelesen. Ansonsten k&ouml;nnen Sie als zweites Argument das Verzeichnis angeben, das Sie stattdessen einlesen wollen. Anschlie&szlig;end werden die eingelesenen Eintr&auml;ge ausgegeben und der Speicher ordentlich wieder freigegeben. Hier das Beispiel:</p>
<pre><a id="Xxx999392" name="Xxx999392"></a>/* scan_dir.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;unistd. h.&gt;
#define MAX 255
int main (int argc, char **argv) {
   int num_entries, i;
   struct dirent **namelist, **list;
   const char *ptr = NULL;
   char wd[MAX];
   if (argc &lt; 2)
      ptr = ".";
   else
      ptr = argv[1];
   if ( (  num_entries = 
           scandir( ptr, &amp;namelist, 0, alphasort)) &lt; 0) {
      fprintf (stderr, "Unerwarteter Fehler\n");
      exit (EXIT_FAILURE);
    }
   chdir (ptr);
   getcwd (wd, MAX);
   printf ("Anzahl der Eintr&auml;ge in %s: %d\n",
      wd, num_entries);
   if (num_entries) {
      printf ("Die Eintr&auml;ge:\n");
      for(i=0, list=namelist; i&lt;num_entries; i++, *list++) {
         printf (" %s\n", (*list)-&gt;d_name);
         free (*list);
      }
      free (namelist);
      printf ("\n");
   }
   printf ("\n");
   return EXIT_SUCCESS;
}</pre>
<p>Oder mit einem WP (Walking Pointer):</p>
<pre>    ...
    if(num_entries &gt; 0) {
        struct dirent **travp = list;
        printf("Die Eintr&auml;ge:\n");
        while(num_entries--) {
            printf("\t" "%s\n", (**travp).d_name);
            free(*travp);
            ++travp;
        }
        free(namelist);
    }
...</pre>
<p>Das Programm im Einsatz:</p>
<pre>$ gcc -o scan_dir scan_dir.c
$ ./scan_dir /usr
Anzahl der Eintr&auml;ge in /usr: 14
Die Eintr&auml;ge:
 .
 ..
 X11
 X11R6
 bin
 games
 i486-suse-linux
 include
 lib
 local
 sbin
 share
 src
 tmp</pre>
<p>Und jetzt noch die zweite M&ouml;glichkeit! Sie w&auml;hlen selbst aus, welche Verzeichniseintr&auml;ge ausgegeben werden sollen. Hierzu habe ich mir erlaubt, die von POSIX zur Verf&uuml;gung gestellten Funktionen der Headerdatei <span class="listing">&lt;regex.h&gt;<a id="Xxx999399" name="Xxx999399"></a></span> zu verwenden. Diese Funktionen k&ouml;nnen zum Suchen von regul&auml;ren Ausdr&uuml;cken verwendet werden.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Mehr zum Thema regul&auml;re Ausdr&uuml;cke oder gar, wie man diese selbst programmiert, finden Sie in meinem Buch »C von A bis Z«, das sich auch auf der Buch-CD befindet.</p>
</td>
</tr>
</table><br>
<p><a id="Xxx999404" name="Xxx999404"></a><a id="Xxx999405" name="Xxx999405"></a><a id="Xxx999406" name="Xxx999406"></a><a id="Xxx999407" name="Xxx999407"></a><a id="Xxx999408" name="Xxx999408"></a>In der Headerdatei <span class="listing">&lt;regex.h&gt;</span> werden Ihnen folgende vier Funktionen zur Verf&uuml;gung gestellt: <span class="listing">regcomp()</span>, <span class="listing">regexec()</span>, <span class="listing">regerror()</span> und <span class="listing">regfree()</span>. Mit der Funktion <span class="listing">regcomp()</span> m&uuml;ssen Sie die Zeichenkette (den regul&auml;ren Ausdruck) erst in die Variable <span class="listing">regex_t</span> &uuml;bersetzen. Anschlie&szlig;end k&ouml;nnen Sie diesen regul&auml;ren Ausdruck mit der Funktion <span class="listing">regexec()</span> und dem zu durchsuchenden Text (hier Verzeichniseintr&auml;ge) anwenden. Am Ende wird die nicht mehr ben&ouml;tigte Variable <span class="listing">regex_t</span> mit <span class="listing">regfree()</span> wieder freigegeben. Mit <span class="listing">regerror()</span> k&ouml;nnen Sie eventuelle Fehlermeldungen zu den Funktionen <span class="listing">regcomp()</span> und <span class="listing">regexec()</span> ausgeben lassen. Ich hoffe, Sie verzeihen mir, dass ich dieses Kapitel ein wenig schneller abgehandelt habe, aber die regul&auml;ren Ausdr&uuml;cke sind hier nicht das Thema.</p>
<p>Mit dem nun folgenden Beispiel k&ouml;nnen Sie als drittes Argument einen regul&auml;ren Ausdruck angeben, der auf das Verzeichnis, das Sie als zweites Argument angeben, verwendet wird. Stimmt der regul&auml;re Ausdruck mit einem Eintrag im Verzeichnis &uuml;berein, wird dieser mit der eigenen Selector-Funktion wieder (automatisch) dynamisch in <span class="listing">*namelist</span> geschrieben. Wichtig ist dabei, dass nur die Eintr&auml;ge in <span class="listing">*namelist</span> geschrieben werden, wo die Funktion (im Beispiel: <span class="listing">my_select</span>) einen Wert gr&ouml;&szlig;er als 0 zur&uuml;ckliefert. Hierzu das Listing:</p>
<pre><a id="Xxx999411" name="Xxx999411"></a>/* find_dir.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;regex.h&gt;
#include &lt;unistd. h.&gt;
#define MAX 255
static int search = 0;
static regex_t regexpr;
static int my_select (const struct dirent *dp) {
   if(search == 0)
      return 1;
   if (regexec(&amp;regexpr, dp-&gt;d_name, 0, NULL, 0) == 0)
      return 1;
   else
      return 0;
}
int main (int argc, char **argv) {
   int num_entries, i;
   struct dirent **namelist, **list;
   const char *ptr = NULL;
   char wd[MAX];
   if (argc &lt; 2)
      ptr = ".";
   else
      ptr = argv[1];
   if(argc == 3) {
     if (regcomp(&amp;regexpr, argv[2], REG_EXTENDED)) {
        printf("Problem beim Ausdruck %sn", argv[2]);
        return EXIT_FAILURE;
     }
     search = 1;
    }
   if ( ( num_entries =
          scandir(ptr, &amp;namelist, my_select, 0)) &lt; 0) {
      fprintf (stderr, "Unerwarteter Fehler\n");
      exit (EXIT_FAILURE);
   }
   chdir (ptr);
   getcwd (wd, MAX);
   printf ("Anzahl der Eintr&auml;ge in %s: %d\n",
      wd, num_entries);
   if (num_entries) {
      printf ("Die Eintr&auml;ge:\n");
      for(i=0, list=namelist; i&lt;num_entries; i++, *list++){
         printf (" %s\n", (*list)-&gt;d_name);
         free (*list);
      }
      free (namelist);
      printf ("\n");
   }
   printf ("\n");
   regfree(&amp;regexpr);
   return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o find_dir find_dir.c
$ ./find_dir /usr/include ^std
Anzahl der Eintr&auml;ge in /usr/include: 4
Die Eintr&auml;ge:
 stdio.h
 stdio_ext.h
 stdint.h
 stdlib.h</pre>
<p>Hier wurden zum Beispiel alle Eintr&auml;ge im Verzeichnis <span class="listing">/usr/include</span> ausgegeben, die mit der Zeichenkette std beginnen. Das Zeichen <span class="listing">^</span> bedeutet dabei so viel wie »beginne am Anfang«.</p>
<a name="t39"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t310"></a><h3 class="t3">2.5.9 Ganze Verzeichnisb&auml;ume durchlaufen – ftw()<a id="RxxKap02004040000CE1F0491CF" name="RxxKap02004040000CE1F0491CF"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999417" name="Xxx999417"></a><a id="Xxx999418" name="Xxx999418"></a>Manches Mal reicht es nicht aus, in nur einem Verzeichnis etwas auszulesen bzw. etwas zu suchen. Wollen Sie tiefer in die Verzeichnisse vordringen, k&ouml;nnen Sie entweder eine rekursive Funktion mit den bereits bekannten Funktionen <span class="listing">opendir()</span> und <span class="listing">readdir()</span> schreiben oder aber auf die XPG4-konforme Funktion, die auf vielen Linux-Systemen vorhanden ist, n&auml;mlich <span class="listing">ftw()</span> (file tree walk), zur&uuml;ckgreifen. Zwar ruft sich die Funktion <span class="listing">ftw()</span> intern ebenfalls mehrmals rekursiv auf, aber es handelt sich immerhin um eine erprobte Bibliotheksfunktion.</p>
<p>Sofern Sie nat&uuml;rlich m&ouml;glichst portabel bleiben m&uuml;ssen, bleibt Ihnen nichts anderes &uuml;brig, als <span class="listing">opendir()</span> und <span class="listing">readdir()</span> zu verwenden, da der POSIX-Standard eben weiter verbreitet ist als der XPG4-Standard.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Wer auf einem *BSD-System arbeitet, findet hier mit <span class="listing">fts()<a id="Xxx999423" name="Xxx999423"></a></span> (traverse a file hierarchy) eine – man mag fast schon sagen – interessantere Routine als <span class="listing">ftw()</span>. Es wird gar erwartet, dass diese Routinen zuk&uuml;nftig in POSIX.1 aufgenommen werden. Mehr dazu finden *BSD-Anh&auml;nger in der entsprechenden Manual Page von <span class="listing">fts()</span>.</p>
</td>
</tr>
</table><br>
<p>Wie dem auch sei, im Gegensatz zu vielen anderen B&uuml;chern will ich hier nicht den &uuml;blichen Weg vorstellen, sondern die Funktion <span class="listing">ftw()</span>.</p>
<p>Hier die Syntax von <span class="listing">ftw()</span>:</p>
<pre>#include &lt;ftw.h&gt;
int ftw( const char *dir, 
         int (*fn)(const char *file, const  struct stat *sb, 
         int flag), int nopenfd   );</pre>
<p>Mit dieser Funktion beginnen Sie mit dem Durchforsten eines kompletten Verzeichnisbaums, angefangen bei <span class="listing">dir</span>. F&uuml;r jeden gefundenen Eintrag im Verzeichnis <span class="listing">dir</span> (und allen Unterverzeichnissen) wird die Funktion <span class="listing">fn()</span> mit dem kompletten Pfadnamen, einem Zeiger auf die Struktur <span class="listing">stat</span> (siehe Kapitel 3) und einem Flag, das folgenden Wert haben kann:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> FTW_F<a id="Xxx999430" name="Xxx999430"></a></span> – Eintrag ist eine normale Datei.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> FTW_D<a id="Xxx999432" name="Xxx999432"></a></span> – Eintrag ist ein Verzeichnis.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> FTW_DNR<a id="Xxx999434" name="Xxx999434"></a></span> – Eintrag ist ein nicht lesbares Verzeichnis (meist mangelnde Zugriffsrechte).</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> FTW_SL<a id="Xxx999436" name="Xxx999436"></a></span> – Eintrag ist ein symbolischer Link.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> FTW_NS<a id="Xxx999438" name="Xxx999438"></a></span> – Fehler bei <span class="listing">stat</span>, obwohl der Eintrag kein symbolischer Link ist.</td>
</tr>
</table>
<p>Damit die Funktion <span class="listing">ftw()</span> nicht alle f&uuml;r einen Prozess vorhandenen Filedeskriptoren f&uuml;r die offenen Verzeichnisse verwendet, k&ouml;nnen Sie mit dem Argument <span class="listing">nopenfd</span> die maximale Anzahl gleichzeitig ge&ouml;ffneter Verzeichnisse angeben. Sobald die Suchtiefe dann h&ouml;her ist als <span class="listing">nopenfd</span>, bremst <span class="listing">ftw()</span>, da es einige Verzeichnisse schlie&szlig;t, um neue zu &auml;ndern. Diese m&uuml;ssen hinterher wieder ge&ouml;ffnet werden, um an der Stelle, an der <span class="listing">ftw()</span> aufgeh&ouml;rt an, weiterzumachen.</p>
<p>Die Funktion <span class="listing">ftw()</span> k&ouml;nnen Sie stoppen, indem Sie bei der Funktion <span class="listing">fn()</span> einen Wert ungleich 0 zur&uuml;ckgeben. 0 hei&szlig;t weitermachen und ungleich 0 stopp. Ansonsten macht <span class="listing">ftw()</span> so lange weiter, bis alle Verzeichnisse und deren Eintr&auml;ge durchforstet sind. Tritt ein Fehler auf, wird -1 zur&uuml;ckgegeben.</p>
<p>In dem folgenden Listing soll ein komplettes Verzeichnis mitsamt seinen Unterverzeichnissen ausgegeben werden. Es werden dabei alle Eintr&auml;ge angezeigt. Das Programm wurde mit Absicht relativ einfach und kurz gehalten. Tritt z. B. das Flag <span class="listing">FTW_F</span> in Erscheinung, sollten Sie die Strukturvariable <span class="listing">st_mode</span> von <span class="listing">stat</span> abfragen, ob es sich denn um eine normale Datei (<span class="listing">S_IFREG</span>), eine zeichenorientierte Ger&auml;tedatei (<span class="listing">S_IFCHR</span>), eine blockorientierte Ger&auml;tedatei (<span class="listing">S_IFBLK</span>), ein FIFO (<span class="listing">S_IFIFO</span>), einen symbolischen Link (<span class="listing">S_IFLNK</span>) oder ein Socket (<span class="listing">S_IFSOCK</span>) handelt. Nat&uuml;rlich k&ouml;nnen Sie auch weitere Attribute der einzelnen Eintr&auml;ge von der Struktur <span class="listing">stat</span> abfragen. Mehr zu <span class="listing">stat</span> im n&auml;chsten Kapitel. Hier das komplette Listing:</p>
<pre><a id="Xxx999443" name="Xxx999443"></a>/* ftwalk.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;ftw.h&gt;
#include &lt;dirent.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
static int dir_deep(const char *);
static int dir_deep(const char *pfad) {
   int deep = 0;
   char *ptr = (char *)pfad;
   while(ptr=strchr(ptr, '/')) {
      ptr++;
      deep++;
   }
   return deep;
} 
static int
fn(const char *pfadname, struct stat *attribut, int flag) {
   static int first = 1;
   static int deep;
   int i;
   const char *ptr = pfadname;
  
   if(!first) {
      for( i = 1; i&lt;=dir_deep(pfadname) - deep; i++)
         printf("%2c|"' ');
      printf("---[%s",strrchr(pfadname, '/')+1);
   }
   else {
      deep=dir_deep(pfadname);   
      printf("[%s",pfadname);
      first = 0;
   }
   switch(flag) {
      case FTW_F   : printf("]\n");    break;
      case FTW_D   : printf("/]\n");   break;
      case FTW_DNR : printf("/-]\n");  break;
      default      : printf("???]\n"); break;
   }
   return 0;
   /* Wollen Sie ftw() stoppen, geben Sie 1 zur&uuml;ck */
   //return 1;
}
int main(int argc, char **argv) {
   const char *ptr = NULL;
   if(argc &lt; 2)
      ptr = ".";
   else
      ptr = argv[1];
   if( ftw( ptr, fn, 16) == 0 )
      return EXIT_SUCCESS;
   else
      printf("Fehler bei ftw() ...!\n");
   return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o ftwalk ftwalk.c
$ ./ftwalk /home | less
[/home/]
  |  |---[tot/]
  |  |  |---[.qt/]
  |  |  |  |---[qtrc]
  |  |  |  |---[qt_plugins_3.1rc]
  |  |  |  |---[.qt_plugins_3.1rc.lock]
  |  |  |  |---[.qtrc.lock]
  |  |  |---[.ddd/]
  |  |  |  |---[log]
  |  |  |  |---[init]
  |  |  |  |---[tips]
  |  |  |  |---[themes/]
  |  |  |  |---[history]
  |  |  |  |---[sessions/]
  |  |  |---[.kde/]
...
...
  |  |  |  |---[private/]
  |  |  |  |  |---[config.xmldb]
  |  |  |---[.xsession-errors]
  |  |  |---[.xsession]
  |  |  |---[.xserverrc.secure]
  |  |  |---[.dvipsrc]
  |  |  |---[.mailcap]
  |  |  |---[.fonts.cache-1]</pre>
<p>Da die Ausgabe kompletter Verzeichnisse recht umfangreich werden kann, wurde hier eine Pipe durch less verwendet. Damit wird die Ausgabe des Programms <span class="listing">ftwalk</span> auf less umgeleitet, und Sie k&ouml;nnen bequem die Ausgabe nach unten und oben scrollen. Mit »<span class="listing">q</span>« k&ouml;nnen Sie less vorzeitig wieder beenden.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap02-003.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap02-005.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap02-004.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:57:10 GMT -->
</html>
