<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap05-005.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:57:10 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – 5.6 Ger&auml;tedateien in der Praxis einsetzen</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap05-004.html">
<link rel="next" href="Kap06-000.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap05-004.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap06-000.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="Kap05-000.html#RxxKap05000040001591F023100">5 Devices – eine einfache Verbindung zur Hardware</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap05-000.html#RxxKap05000040001591F023103">5.1 Die Ger&auml;tedateitypen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap05-001.html#RxxKap05001040001761F01B100">5.2 Die Ger&auml;tedateinummern</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap05-002.html#RxxKap05002040001771F027100">5.3 Zugriff auf die Ger&auml;tedateien</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap05-003.html#RxxKap05003040001781F04F100">5.4 Ger&auml;tenamen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap05-004.html#RxxKap05004040001791F04B100">5.5 Spezielle Ger&auml;tedateien</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap050050400017A1F038100">5.6 Ger&auml;tedateien in der Praxis einsetzen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap050050400017A1F03810B">5.6.1 CD auswerfen und wieder schlie&szlig;en</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap050050400017A1F038111">5.6.2 CD-ROM-F&auml;higkeiten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap050050400017A1F038114">5.6.3 Audio-CD abspielen – komplett und einzelne Tracks – Pause, Fortfahren und Stopp</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap050050400017A1F038186">5.6.4 Aktuellen Status der Audio-CD ermitteln</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap050050400017A1F03818E">5.6.5 Das komplette Listing</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">5.6 <a id="RxxKap0550GeratedateieninderPraxiseinsetzen" name="RxxKap0550GeratedateieninderPraxiseinsetzen"></a>Ger&auml;tedateien in der Praxis einsetze<a id="RxxKap050050400017A1F038100" name="RxxKap050050400017A1F038100"></a>n 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p>Auf den folgenden Seiten will ich Ihnen nun zeigen, wie Sie die Ger&auml;tedatei in der Praxis einsetzen k&ouml;nnen; also neben dem Lesen und Schreiben auch das Steuern des Treibers durch die Ger&auml;tedatei. Das Ziel des Abschnitts ist es, Ihnen ein Gef&uuml;hl daf&uuml;r zu geben, wie Sie die entsprechenden Informationen ermitteln k&ouml;nnen, um den un&uuml;bersichtlichen Haufen von Ger&auml;tedateien steuern zu k&ouml;nnen.</p>
<p>Als Beispiel wird das CD-ROM-Laufwerk verwendet, da zum einen fast jeder Leser so etwas besitzen d&uuml;rfte, und zum anderen l&auml;sst es sich damit relativ leicht nachvollziehen, da hierf&uuml;r keine speziellen Hardware-Kenntnisse n&ouml;tig sind. Es soll hierbei ein Listing erstellt werden, womit Sie die Lade &ouml;ffnen k&ouml;nnen, um eine Musik-CD einzulegen. Weiterhin soll es m&ouml;glich sein, die Track-Informationen einzulesen und auch wieder auszugeben. Die Musik soll ebenfalls wiedergegeben werden, mitsamt der Anzeige, welcher Track gerade l&auml;uft und wo gerade gelesen wird (zeitm&auml;&szlig;ig gesehen).</p>
<p>Das Ganze h&ouml;rt sich schlimmer an, als es ist, und l&auml;sst sich relativ einfach mit den Treiberbefehlen der Ger&auml;tedatei &uuml;ber <span class="listing">ioctl()</span> steuern. Das CD-ROM-Laufwerk l&auml;sst sich gew&ouml;hnlich von Haus aus &uuml;ber den Mountpoint <span class="listing">/dev/cdrom</span> oder auch <span class="listing">/media/cdrom</span> ansprechen. Wenn dies bei Ihnen nicht der Fall ist, w&auml;re es sinnvoll, selbst einen symbolischen Link zum CD-ROM-Laufwerk zu legen. In der Tabelle zu den Ger&auml;tedateien k&ouml;nnen Sie das Verzeichnis f&uuml;r Ihr CD-ROM-Laufwerk herauslesen.</p>
<p>Au&szlig;erdem ben&ouml;tigen Sie mindestens Leserechte auf das CD-ROM-Laufwerk. Sofern diese bei Ihnen nicht vorhanden sind, sollten Sie dieses Recht mittels <span class="listing">chmod</span> <span class="listing">a+r</span> <span class="listing">/dev/hdc</span> (<span class="listing">/dev/hdc/</span> sei hier der Pfad zur Ger&auml;tedatei) setzen oder von Ihrem Administrator setzen lassen.</p>
<p>Zuerst m&uuml;ssen Sie die Informationen zu den Treiberbefehlen des CD-ROM-Laufwerks suchen. Einen ersten &Uuml;berblick hierzu k&ouml;nnen Sie sich, wie schon erw&auml;hnt, unter man ioctl_list verschaffen. Folgende Informationen k&ouml;nnen hierbei schon ermittelt werden:</p>
<pre>$ man ioctl_list
...
// &lt;include/linux/cdrom.h&gt;
0x00005301  CDROMPAUSE          void
0x00005302  CDROMRESUME         void
0x00005303  CDROMPLAYMSF        const struct cdrom_msf *
0x00005304  CDROMPLAYTRKIND     const struct cdrom_ti *
0x00005305  CDROMREADTOCHDR     struct cdrom_tochdr *
0x00005306  CDROMREADTOCENTRY   struct cdrom_tocentry * 
0x00005307  CDROMSTOP           void
0x00005308  CDROMSTART          void
0x00005309  CDROMEJECT          void
0x0000530A  CDROMVOLCTRL        const struct cdrom_volctrl *
0x0000530B  CDROMSUBCHNL        struct cdrom_subchnl * 
0x0000530C  CDROMREADMODE2      const struct cdrom_msf * 
...
0x00005312  CDROMRESET          void
0x00005313  CDROMVOLREAD        struct cdrom_volctrl *
0x00005314  CDROMREADRAW        const struct cdrom_msf * 
0x00005315  CDROMREADCOOKED     const struct cdrom_msf * 
0x00005316  CDROMSEEK           const struct cdrom_msf *
...</pre>
<p>In der ersten Spalte finden Sie den Hexwert f&uuml;r den Treiber. Als Mensch liest man gerne, und daher finden Sie in der zweiten Spalte die symbolische Konstante dazu. In der dritten Spalte finden Sie au&szlig;erdem den entsprechenden Datentyp oder die Struktur, worauf sich der Befehl bezieht – sprich das dritte Argument f&uuml;r die Funktion <span class="listing">ioctl()</span>. Dies ist schon ein guter &Uuml;berblick. Aber um einen Blick in die Headerdatei f&uuml;r den Linux CD-ROM-Treiber kommen Sie nicht mehr herum, wenn Sie die einzelnen Strukturvariablen verwenden wollen. Wo Sie diese finden k&ouml;nnen, ist gleich zu Beginn bei der Manual Page mit <span class="listing">&lt;include/linux/cdrom.h&gt;</span> angegeben. Sie m&uuml;ssen also ins Verzeichnis Ihrer <span class="listing">include</span>-Dateien gehen. Meistens ist dies <span class="listing">/usr/include</span> oder <span class="listing">/usr/local/include</span>. Darin finden Sie jetzt au&szlig;er den Befehlen noch alles, was Sie f&uuml;r die weitere Verwendung ben&ouml;tigen – vor allem auch eine kurze Beschreibung der einzelnen Befehle, was man ja bei man ioctl_list schmerzlich vermisst.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Das folgende Beispiel l&auml;sst sich nur mit einem Linux-Rechner &uuml;bersetzen und ausf&uuml;hren. Sofern Sie ein &auml;hnliches Beispiel auf Systemen wie SunOS, NetBSD, OpenBSD oder FreeBSD erstellen wollen, ben&ouml;tigen Sie hierzu die Headerdatei <span class="listing">sys/cdio.h</span> anstatt <span class="listing">linux/cdrom.h</span>. </p>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard">Leider gibt es hierbei einige (geringf&uuml;gige) Differenzen, so dass ich mir hier nicht mit einer bedingten Kompilierung behelfen kann. Nat&uuml;rlich finden Sie als BSD-Leser auf der Buch-CD ein entsprechendes Listing (<span class="listing">bsd_cdrom.c</span>), das auf allen BSD- und eventuell (ungetestet) auch auf SunOS-Systemen laufen sollte.</p>
</td>
</tr>
</table><br>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t32"></a><h3 class="t3">5.6.1 CD auswerfen und wieder schlie&szlig;en<a id="RxxKap050050400017A1F03810B" name="RxxKap050050400017A1F03810B"></a> 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Bevor Sie das CD-ROM-Laufwerk steuern k&ouml;nnen, m&uuml;ssen Sie die entsprechende Ger&auml;tedatei zum Lesen &ouml;ffnen. Der &Uuml;bersichtlichkeit halber wurden die einzelnen Aktionen in kleine Routinen gepackt, womit Sie diese jederzeit f&uuml;r Ihre Zwecke verwenden k&ouml;nnen. Am Ende des Kapitels finden Sie die einzelnen Routinen nochmals als komplettes Listing wieder.</p>
<pre>...
#define CDROM "/dev/cdrom"
...
static int open_cdrom (void) {
   int fd = open (CDROM, O_RDONLY | O_NONBLOCK);
   if (fd == -1) {
      if (errno == ENOMEDIUM)
         printf ("Keine CD im Laufwerk!\n");
      else
         perror ("Fehler bei open()");
      exit (EXIT_FAILURE);
   }
   return fd;
}</pre>
<p>Damit die Funktion <span class="listing">open()</span> nicht blockiert, wenn Sie mal keine CD im Laufwerk haben, muss das Flag <span class="listing">O_NONBLOCK</span> verwendet werden. Die Funktion gibt den Filedeskriptor <span class="listing">cdrom</span> f&uuml;r die anschlie&szlig;ende weitere Steuerung mit <span class="listing">ioctl()</span> zur&uuml;ck.</p>
<p>Nachdem Sie die Ger&auml;tedatei zum Lesen ge&ouml;ffnet haben, k&ouml;nnen Sie die ersten Steuerbefehle ausf&uuml;hren. Hierzu werden erst einmal die einfachsten Kommandos, die keine weiteren Parameter in <span class="listing">ioctl()</span> mehr ben&ouml;tigen, verwendet, zum einen das Auswerfen der CD, zum anderen – falls technisch m&ouml;glich – das Einfahren des Caddys. Gerade bei Laptops ist das Zur&uuml;ckfahren des CD-Fachs nicht m&ouml;glich. Daf&uuml;r bekommen Sie – wenn technisch nicht m&ouml;glich – eine Meldung zur&uuml;ck, dies doch selbst zu tun.</p>
<pre>static void open_tray (int cdrom) {
   if (ioctl (cdrom, CDROMEJECT) == -1) {
      perror ("Eject yourself");
      exit (EXIT_FAILURE);
   }
}
/* Funktioniert nicht &uuml;berall */
static void close_tray (int cdrom) {
   if (ioctl (cdrom, CDROMCLOSETRAY) == -1) {
      printf ("CD-Tray bitte von Hand schlie&szlig;en\n");
   }
}</pre>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t33"></a><h3 class="t3">5.6.2 CD-ROM-F&auml;higkeiten<a id="RxxKap050050400017A1F038111" name="RxxKap050050400017A1F038111"></a> 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Ben&ouml;tigen Sie die F&auml;higkeiten des CD-ROM-Laufwerks, dann k&ouml;nnen Sie dies mithilfe des Kommandos <span class="listing">CDROM_GET_CAPABILITY</span> ermitteln. In diesem Fall liefert <span class="listing">ioctl()</span> als R&uuml;ckgabewert einen Integer zur&uuml;ck, dessen einzelne Bit-Werte es gilt auszulesen. In unserem Beispiel ermitteln wir zwar nur, um was f&uuml;r ein Laufwerk es sich handelt – sprich CD-R, CD-RW, DVD etc. –, aber Sie k&ouml;nnen gerne weitere F&auml;higkeiten, die alle mit dem Pr&auml;fix <span class="listing">CDC_</span> beginnen, zur &Uuml;berpr&uuml;fung verwenden und auswerten. Sie m&uuml;ssen lediglich den R&uuml;ckgabewert von <span class="listing">ioctl()</span> mit dem bitweisen UND-Operator und der entsprechenden symbolischen <span class="listing">CDC_</span>-Konstante als Bedingung verwenden. Ist die Bedingung wahr, dann trifft Entsprechendes zu.</p>
<pre>static void capability_cdrom (int cdrom) {
   const char *j[] = {"nein", "ja"};
   int caps = ioctl (cdrom, CDROM_GET_CAPABILITY);
   if (caps == -1) {
      perror ("CDROM_GET_CAPABILITY");
      return;
   }
   printf ("CDROM-F&auml;higkeiten:\n"
      "\tCD-R    : %s\n"
      "\tCD-RW   : %s\n"
      "\tDVD     : %s\n"
      "\tDVD-R   : %s\n"
      "\tDVD-RAM : %s\n",
      j[!!(caps &amp; CDC_CD_R)],
      j[!!(caps &amp; CDC_CD_RW)],
      j[!!(caps &amp; CDC_DVD)],
      j[!!(caps &amp; CDC_DVD_R)],
      j[!!(caps &amp; CDC_DVD_RAM)]);
}</pre>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t34"></a><h3 class="t3">5.6.3 Audio-CD abspielen – komplett und einzelne Tracks – Pause, Fortfahren und Stopp<a id="RxxKap050050400017A1F038114" name="RxxKap050050400017A1F038114"></a> 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Um das Inhaltsverzeichnis der CD einzulesen, k&ouml;nnen Sie die Kommandos <span class="listing">CDROMTOCHDR</span> und <span class="listing">CDROMREADTOCENTRY</span> verwenden (TOC = Table Of Contents). Verwenden Sie <span class="listing">ioctl()</span> mit <span class="listing">CDROMTOCHDR</span>, wird als dritter Parameter eine Adresse vom Typ <span class="listing">struct</span> <span class="listing">cdrom_tochdr</span> erwartet. Diese Struktur sieht in der Headerdatei <span class="listing">cdrom.h</span> wie folgt aus:</p>
<pre>/* Struktur wird bei CDROMREADTOCHDR mit ioctl() erwartet */
struct cdrom_tochdr {
   __u8   cdth_trk0;   /* start track */
   __u8   cdth_trk1;   /* end track */
};</pre>
<p>Wenn Sie das Kommando mit <span class="listing">ioctl()</span> verwenden, wird in der Struktur <span class="listing">cdrom_tochdr</span> der erste (<span class="listing">cdth_trk0</span>) und der letzte (<span class="listing">cdth_trk1</span>) Track eingetragen. Somit k&ouml;nnen Sie mit dem Auslesen des letzten Tracks schon ermitteln, wie viele Tracks sich auf der Audio-CD befinden.</p>
<p>Das zweite Kommando <span class="listing">CDROMREADTOCENTRY</span> hingegen ben&ouml;tigt als dritten Parameter f&uuml;r <span class="listing">ioctl()</span> eine Struktur vom Typ <span class="listing">cdrom_tocentry</span>, die folgenderma&szlig;en in der Headerdatei <span class="listing">cdrom.h</span> definiert ist.</p>
<pre>/* Struktur wird bei CDROMREADTOCENTRY mit ioctl() erwartet */
struct cdrom_tocentry {
   __u8   cdte_track;
   __u8   cdte_adr  : 4;
   __u8   cdte_ctrl : 4;
   __u8   cdte_format;
   union  cdrom_addr cdte_addr;
   __u8   cdte_datamode;
};</pre>
<p>Auf jeden Fall angeben m&uuml;ssen Sie in dieser Struktur den Track (<span class="listing">cdte_track</span>) und das Format der Ausgabe (<span class="listing">cdte_format</span>). Beim Format geben Sie <span class="listing">CDROM_MSF</span> (MSF = Minute, Sekunde, Frame) an. M&ouml;glich w&auml;re auch <span class="listing">CDROM_LBA</span> (Logical Block Address), was eine Adresse, die durch eine Integerzahl dargestellt wird, zur&uuml;ckgeben w&uuml;rde. <span class="listing">cdte_ctrl</span> k&ouml;nnen Sie z. B. verwenden, um herauszufinden, ob es sich bei dem Track um einen Audio- oder Datentrack handelt. Hierzu m&uuml;ssen Sie nur wieder den bitweisen UND-Operator mit der Konstante <span class="listing">CDROM_DATA_TRACK</span> &uuml;berpr&uuml;fen. Ist der Ausdruck wahr, handelt es sich um einen Datentrack, ansonsten ist es ein Audiotrack.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Eine Sekunde besteht aus 75 Frames. Ein Frame ist 2352 Bytes lang.</p>
</td>
</tr>
</table><br>
<p>Da wir uns f&uuml;r die Minuten, Sekunden und Framel&auml;nge der CD-ROM mit <span class="listing">CDROM_MSF</span> interessieren, ben&ouml;tigen Sie <span class="listing">union</span> <span class="listing">cdrom_addr</span> <span class="listing">cdte_addr</span> – was allerdings nicht mehr auf den ersten Blick ersichtlich ist. Die Union <span class="listing">cdrom_addr</span> wiederum beinhaltet eine Struktur mit dem Namen <span class="listing">struct</span> <span class="listing">cdrom_msf</span> <span class="listing">msf</span>, die das beinhaltet, wonach Sie suchen. Hier die beiden Strukturen:</p>
<pre>union cdrom_addr {
   struct cdrom_msf0 msf;
   int lba;
};
struct cdrom_msf0 {
   __u8 minute;
   __u8 second;
   __u8 frame;
};</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Sofern Ihnen die Dokumentation der Ger&auml;tedatei nicht mehr weiterhilft, m&uuml;ssen Sie, ausgehend von den Angaben des Kommandos in <span class="listing">ioctl()</span>, die Angaben einer Struktur selbst systematisch absuchen. Ein Greenhorn verf&auml;ngt sich bei umfangreicheren Ger&auml;tedateien dabei recht schnell im Netz der Spinne.</p>
</td>
</tr>
</table><br>
<p>Hier die Funktion, die das Inhaltsverzeichnis einer Audio-CD auslesen soll.</p>
<pre>static void content_cdrom (int cdrom) {
   struct cdrom_tochdr tochdr;
   struct cdrom_tocentry tocentry;
   int track;
   if (ioctl (cdrom, CDROMREADTOCHDR, &amp;tochdr) == -1) {
      perror ("Kann den Header nicht holen");
      exit (EXIT_FAILURE);
   }
   printf ("\nInhalt %d Tracks:\n", tochdr.cdth_trk1);
   track = tochdr.cdth_trk0;
   while (track &lt;= tochdr.cdth_trk1) {
      tocentry.cdte_track = track;
      tocentry.cdte_format = CDROM_MSF;
      if (ioctl (cdrom, CDROMREADTOCENTRY, &amp;tocentry)==-1) {
         perror ("Kann Inhalt der CD nicht ermitteln");
         exit (EXIT_FAILURE);
      }
      printf ("%3d: %02d:%02d:%02d (%06d) %s%s\n",
         tocentry.cdte_track,
         tocentry.cdte_addr.msf.minute,
         tocentry.cdte_addr.msf.second,
         tocentry.cdte_addr.msf.frame,
         tocentry.cdte_addr.msf.frame +
         tocentry.cdte_addr.msf.second * 75 +
         tocentry.cdte_addr.msf.minute * 75 * 60 - 150,
         (tocentry.cdte_ctrl &amp; CDROM_DATA_TRACK)
            ? "data " : "audio",
         CDROM_LEADOUT == track ? " (leadout)" : "");
      track++;
   }
}</pre>
<p>Im n&auml;chsten Schritt soll die Audio-CD abgespielt werden. Zur Auswahl steht, entweder die komplette CD oder nur einen bestimmten Track abzuspielen. Auch hierzu ben&ouml;tigen Sie das Kommando <span class="listing">CDROMREADTOCENTRY</span>, um den Inhalt der CD bzw. bestimmte Tracks abzuspielen. Die Struktur <span class="listing">cdrom_tocentry</span> ben&ouml;tigen Sie, um den Anfang des ersten Tracks (<span class="listing">cdte_track</span>), das Format (<span class="listing">CDROM_MSF</span>) und das Ende des letzten bzw., im Falle einer Einzelauswahl, das Ende des n&auml;chsten Tracks anzuzeigen. Den letzten Track k&ouml;nnen Sie &uuml;brigens auch mit der symbolischen Konstante <span class="listing">CDROM_LEADOUT</span> angeben.</p>
<p>Abgespielt wird diese Position dann mit dem Kommando <span class="listing">CDROMPLAYMSF</span> und der Struktur <span class="listing">cdrom_msf</span> als dritten Parameter von <span class="listing">ioctl()</span>.</p>
<pre>/* Struktur wird bei CDROMPLAYMSF mit ioctl() erwartet */
struct cdrom_msf {
   __u8   cdmsf_min0;    /* start minute */
   __u8   cdmsf_sec0;    /* start second */
   __u8   cdmsf_frame0;  /* start frame  */
   __u8   cdmsf_min1;    /* end minute   */
   __u8   cdmsf_sec1;    /* end second   */
   __u8   cdmsf_frame1;  /* end frame    */
};</pre>
<p>Bevor Sie also <span class="listing">ioctl()</span> und das Kommando <span class="listing">CDROMPLAYMSF</span> auf die Struktur loslassen, m&uuml;ssen Sie zuerst die Anfangsposition an den einzelnen Strukturvariablen &uuml;bergeben – was alle Strukturvariablen mit der <span class="listing">..0</span> am Ende beinhaltet (<span class="listing">cdmsf_min0</span>, <span class="listing">cdmsf_sec0</span>, <span class="listing">cdmsf_frame0</span>) – und die Endposition, was alle Strukturvariablen (wer h&auml;tte das gedacht) mit einer <span class="listing">..1</span> am Ende beinhaltet (<span class="listing">cdmsf_min1</span>, <span class="listing">cdmsf_sec1</span>, <span class="listing">cdmsf_frame1</span>). Hier die Funktion dazu:</p>
<pre>static void play_cdrom ( int cdrom, int flag ) {
   struct cdrom_tocentry tocentry;
   struct cdrom_msf play;
   int track = flag;
   int lead  = flag;
   
   if(flag == FULL) {
      track = 1;
      lead  = CDROM_LEADOUT;
   }
   else {
      track = flag;
      lead  = flag+1;
   }
   /* Anfang des ersten Liedes */
   tocentry.cdte_track = track;
   tocentry.cdte_format = CDROM_MSF;
   if (ioctl (cdrom, CDROMREADTOCENTRY, &amp;tocentry) == -1) {
      perror ("Kann den Inhalt der CD nicht ermitteln\n");
      exit (EXIT_FAILURE);
   }
   play.cdmsf_min0   = tocentry.cdte_addr.msf.minute;
   play.cdmsf_sec0   = tocentry.cdte_addr.msf.second;
   play.cdmsf_frame0 = tocentry.cdte_addr.msf.frame;
   /* Ende des letzten Liedes */
   tocentry.cdte_track  = lead;
   tocentry.cdte_format = CDROM_MSF;
   if (ioctl (cdrom, CDROMREADTOCENTRY, &amp;tocentry) == -1) {
      perror ("Kann den Inhalt der CD nicht ermitteln\n");
      exit (EXIT_FAILURE);
   }
   play.cdmsf_min1   = tocentry.cdte_addr.msf.minute;
   play.cdmsf_sec1   = tocentry.cdte_addr.msf.second;
   play.cdmsf_frame1 = tocentry.cdte_addr.msf.frame;
   if (ioctl (cdrom, CDROMPLAYMSF, &amp;play) == -1) {
      perror ("Kann CD nicht abspielen");
      exit (EXIT_FAILURE);
   }
}</pre>
<p>Wollen Sie die CD stoppen, eine Pause einbauen und den Track wieder aufnehmen, so m&uuml;ssen Sie nur die Kommandos <span class="listing">CDROMSTOP</span>, <span class="listing">CDROMPAUSE</span> und <span class="listing">CDROMRESUME</span> ohne weitere Parameter mit <span class="listing">ioctl()</span> aufrufen.</p>
<pre>static void stop_cdrom (int cdrom) {
   if (ioctl (cdrom, CDROMSTOP) == -1) {
      perror ("Kann CD nicht anhalten");
      return;
   }
}
static void pause_cdrom (int cdrom) {
   if (ioctl (cdrom, CDROMPAUSE) == -1) {
      perror ("Kann PAUSE nicht setzen");
      return;
   }
}
static void resume_cdrom (int cdrom) {
   if (ioctl (cdrom, CDROMRESUME) == -1) {
      perror ("Kann CD nicht mehr fortfahren");
      return;
   }
}</pre>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t35"></a><h3 class="t3">5.6.4 Aktuellen Status der Audio-CD ermitteln<a id="RxxKap050050400017A1F038186" name="RxxKap050050400017A1F038186"></a> 
      <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Nachdem Sie eventuell die Audio-CD gestartet haben, m&ouml;chten Sie sicherlich auch wissen, welcher Track gerade abgespielt wird oder wie lange der Track oder die CD insgesamt schon abgespielt wurde – oder ob die CD &uuml;berhaupt gerade gespielt wird, falls jemand gerade Pause gedr&uuml;ckt hat, etc.</p>
<p>Den Status einer laufenden Audio-CD k&ouml;nnen Sie mit dem Kommando <span class="listing">CDROMSUBCHNL</span> und der Struktur <span class="listing">cdrom_subchnl</span> als dritten Parameter f&uuml;r <span class="listing">ioctl()</span> ermitteln.</p>
<pre>/* Struktur wird bei CDROMSUBCHNL mit ioctl() erwartet */
struct cdrom_subchnl {
   __u8  cdsc_format;
   __u8  cdsc_audiostatus;
   __u8  cdsc_adr:   4;
   __u8  cdsc_ctrl:  4;
   __u8  cdsc_trk;
   __u8  cdsc_ind;
   union cdrom_addr cdsc_absaddr;
   union cdrom_addr cdsc_reladdr;
};</pre>
<p>Bevor Sie <span class="listing">ioctl()</span> aufrufen, sollten Sie zuvor noch das Format (<span class="listing">cdsc_format=CDROM_MSF</span>) angeben. Nach dem Aufruf von <span class="listing">ioctl()</span> beinhaltet <span class="listing">cdsc_audiostatus</span> den aktuellen Status der Audio-CD. Dies k&ouml;nnen folgende symbolische Konstanten sein:</p>
<pre>/* Audio-Status ermitteln wird nicht unterst&uuml;tzt */
#define CDROM_AUDIO_INVALID 0x00 
/* Audio-CD wird gerade abgespielt */
#define CDROM_AUDIO_PLAY 0x11 
/* Audio-CD wurde angehalten (Pause) */
#define CDROM_AUDIO_PAUSED 0x12
/* Audio-CD wurde komplett abgespielt */
#define CDROM_AUDIO_COMPLETED 0x13
/* Audio-CD abspielen wurde wegen Fehler unterbrochen */
#define CDROM_AUDIO_ERROR 0x14
/* Kein besonderer Status vorhanden */
#define CDROM_AUDIO_NO_STATUS 0x15</pre>
<p>&Uuml;ber die Strukturvariable <span class="listing">cdsc_absaddr</span> k&ouml;nnen Sie dann die absolute Zeit und &uuml;ber <span class="listing">cdsc_reladdr</span> die relative Zeit der Audio-CD ermitteln. Auch hier finden Sie wieder die entsprechenden Werte &uuml;ber den Umweg zur Union <span class="listing">cdrom_addr</span>. Hier die Funktion daf&uuml;r:</p>
<pre>static void get_audio_status (int cdrom) {
   struct cdrom_subchnl sub;
   printf ("Audio status: ");
   fflush (stdout);
   sub.cdsc_format = CDROM_MSF;
   if (ioctl (cdrom, CDROMSUBCHNL, &amp;sub))
      printf ("FAILED\n");
   else {
      switch (sub.cdsc_audiostatus) {
      case CDROM_AUDIO_INVALID:
         printf ("invalid\n");
         break;
      case CDROM_AUDIO_PLAY:
         printf ("playing");
         break;
      case CDROM_AUDIO_PAUSED:
         printf ("paused");
         break;
      case CDROM_AUDIO_COMPLETED:
         printf ("completed\n");
         break;
      case CDROM_AUDIO_ERROR:
         printf ("error\n");
         break;
      case CDROM_AUDIO_NO_STATUS:
         printf ("no status\n");
         break;
      default:
         printf ("Oops: unknown\n");
      }
      if (sub.cdsc_audiostatus == CDROM_AUDIO_PLAY ||
          sub.cdsc_audiostatus == CDROM_AUDIO_PAUSED) {
         printf (" at: %02d:%02d abs/ %02d:%02d track %d\n",
            sub.cdsc_absaddr.msf.minute,
            sub.cdsc_absaddr.msf.second,
            sub.cdsc_reladdr.msf.minute,
            sub.cdsc_reladdr.msf.second, sub.cdsc_trk);
      }
   }
}</pre>
<a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t36"></a><h3 class="t3">5.6.5 Das komplette Listing<a id="RxxKap050050400017A1F03818E" name="RxxKap050050400017A1F03818E"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Sie haben nun gesehen, wie einfach es ist, mit <span class="listing">ioctl()</span> und den entsprechenden Kommandos auf die Treiberschnittstelle der Hardware &uuml;ber die Ger&auml;tedatei zuzugreifen. Allerdings haben Sie leider auch gemerkt, dass dies recht m&uuml;hsam werden kann, wenn man den ganzen Strukturen folgen muss. Aber so, wie Sie hierbei vorgegangen sind, werden Sie in der Regel immer vorgehen m&uuml;ssen. Aufgrund des enormen Umfangs der Ger&auml;tedateien ist das immer noch eine recht undokumentierte Geschichte.</p>
<p>Hier nun nochmals die einzelnen Funktionen, eingebaut in einem kompletten Listing:</p>
<pre><a id="Xxx999294" name="Xxx999294"></a>/* cdrom.c */
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;linux/cdrom.h&gt;
#include &lt;errno.h&gt;
/* Bitte ggf. Anpassen */
#define CDROM "/dev/cdrom"
#define FULL   0 /* komplette Audio-CD abspielen */
static int open_cdrom (void) {
   int fd = open (CDROM, O_RDONLY | O_NONBLOCK);
   if (fd == -1) {
      if (errno == ENOMEDIUM)
         printf ("Keine CD im Laufwerk!\n");
      else
         perror ("Fehler bei open()");
      exit (EXIT_FAILURE);
   }
   return fd;
}
static void open_tray (int cdrom) {
   if (ioctl (cdrom, CDROMEJECT) == -1) {
      perror ("Eject yourself");
      exit (EXIT_FAILURE);
   }
}
/* Funktioniert nicht &uuml;berall */
static void close_tray (int cdrom) {
   if (ioctl (cdrom, CDROMCLOSETRAY) == -1) {
      printf ("CD-Tray bitte von Hand schlie&szlig;en\n");
   }
}
static void capability_cdrom (int cdrom) {
   const char *j[] = {"nein", "ja"};
   int caps = ioctl (cdrom, CDROM_GET_CAPABILITY);
   if (caps == -1) {
      perror ("CDROM_GET_CAPABILITY");
      return;
   }
   printf ("CDROM-F&auml;higkeiten:\n"
      "\tCD-R    : %s\n"
      "\tCD-RW   : %s\n"
      "\tDVD     : %s\n"
      "\tDVD-R   : %s\n"
      "\tDVD-RAM : %s\n",
      j[!!(caps &amp; CDC_CD_R)],
      j[!!(caps &amp; CDC_CD_RW)],
      j[!!(caps &amp; CDC_DVD)],
      j[!!(caps &amp; CDC_DVD_R)],
      j[!!(caps &amp; CDC_DVD_RAM)]);
}
static void get_audio_status (int cdrom) {
   struct cdrom_subchnl sub;
   printf ("Audio-Status: ");
   fflush (stdout);
   sub.cdsc_format = CDROM_MSF;
   if (ioctl (cdrom, CDROMSUBCHNL, &amp;sub))
      printf ("FAILED\n");
   else {
      switch (sub.cdsc_audiostatus) {
      case CDROM_AUDIO_INVALID:
         printf ("invalid\n");
         break;
      case CDROM_AUDIO_PLAY:
         printf ("playing");
         break;
      case CDROM_AUDIO_PAUSED:
         printf ("paused");
         break;
      case CDROM_AUDIO_COMPLETED:
         printf ("completed\n");
         break;
      case CDROM_AUDIO_ERROR:
         printf ("error\n");
         break;
      case CDROM_AUDIO_NO_STATUS:
         printf ("no status\n");
         break;
      default:
         printf ("Oops: unknown\n");
      }
      if (sub.cdsc_audiostatus == CDROM_AUDIO_PLAY ||
          sub.cdsc_audiostatus == CDROM_AUDIO_PAUSED) {
         printf (" at: %02d:%02d abs/ %02d:%02d track %d\n",
            sub.cdsc_absaddr.msf.minute,
            sub.cdsc_absaddr.msf.second,
            sub.cdsc_reladdr.msf.minute,
            sub.cdsc_reladdr.msf.second, sub.cdsc_trk);
      }
   }
}
static void content_cdrom (int cdrom) {
   struct cdrom_tochdr tochdr;
   struct cdrom_tocentry tocentry;
   int track;
   if (ioctl (cdrom, CDROMREADTOCHDR, &amp;tochdr) == -1) {
      perror ("Kann den Header nicht holen");
      exit (EXIT_FAILURE);
   }
   printf ("\nInhalt %d Tracks:\n", tochdr.cdth_trk1);
   track = tochdr.cdth_trk0;
   while (track &lt;= tochdr.cdth_trk1) {
      tocentry.cdte_track = track;
      tocentry.cdte_format = CDROM_MSF;
      if (ioctl (cdrom, CDROMREADTOCENTRY, &amp;tocentry)==-1) {
         perror ("Kann den Inhalt der CD nicht ermitteln");
         exit (EXIT_FAILURE);
      }
      printf ("%3d: %02d:%02d:%02d (%06d) %s%s\n",
          tocentry.cdte_track,
          tocentry.cdte_addr.msf.minute,
          tocentry.cdte_addr.msf.second,
          tocentry.cdte_addr.msf.frame,
          tocentry.cdte_addr.msf.frame +
          tocentry.cdte_addr.msf.second * 75 +
          tocentry.cdte_addr.msf.minute * 75 * 60 - 150,
         (tocentry.cdte_ctrl &amp; CDROM_DATA_TRACK) ?
         "data " : "audio",
         CDROM_LEADOUT == track ? " (leadout)" : "");
      track++;
   }
}
static void play_cdrom ( int cdrom, int flag ) {
   struct cdrom_tocentry tocentry;
   struct cdrom_msf play;
   int track = flag;
   int lead  = flag;
   
   if(flag == FULL) {
      track = 1;
      lead  = CDROM_LEADOUT;
   }
   else {
      track = flag;
      lead  = flag+1;
   }
   /* Anfang des ersten Liedes */
   tocentry.cdte_track = track;
   tocentry.cdte_format = CDROM_MSF;
   if (ioctl (cdrom, CDROMREADTOCENTRY, &amp;tocentry) == -1) {
      perror ("Kann den Inhalt der CD nicht ermitteln\n");
      exit (EXIT_FAILURE);
   }
   play.cdmsf_min0 = tocentry.cdte_addr.msf.minute;
   play.cdmsf_sec0 = tocentry.cdte_addr.msf.second;
   play.cdmsf_frame0 = tocentry.cdte_addr.msf.frame;
   /* Ende des letzten Liedes */
   tocentry.cdte_track = lead;
   tocentry.cdte_format = CDROM_MSF;
   if (ioctl (cdrom, CDROMREADTOCENTRY, &amp;tocentry) == -1) {
      perror ("Kann den Inhalt der CD nicht ermitteln\n");
      exit (EXIT_FAILURE);
   }
   play.cdmsf_min1 = tocentry.cdte_addr.msf.minute;
   play.cdmsf_sec1 = tocentry.cdte_addr.msf.second;
   play.cdmsf_frame1 = tocentry.cdte_addr.msf.frame;
   if (ioctl (cdrom, CDROMPLAYMSF, &amp;play) == -1) {
      perror ("Kann CD nicht abspielen");
      exit (EXIT_FAILURE);
   }
}
static void stop_cdrom (int cdrom) {
   if (ioctl (cdrom, CDROMSTOP) == -1) {
      perror ("Kann CD nicht anhalten");
      return;
   }
}
static void pause_cdrom (int cdrom) {
   if (ioctl (cdrom, CDROMPAUSE) == -1) {
      perror ("Kann PAUSE nicht setzen");
      return;
   }
}
static void resume_cdrom (int cdrom) {
   if (ioctl (cdrom, CDROMRESUME) == -1) {
      perror ("Kann CD nicht mehr fortfahren");
      return;
   }
}
int main (void) {
   int fd_cdrom;
   int select;
   int track;
   
   fd_cdrom = open_cdrom();   
   do{
      printf("-1- CD-Tray &ouml;ffnen\n");
      printf("-2- CD-Tray schlie&szlig;en\n");
      printf("-3- CDROM-F&auml;higkeiten\n");
      printf("-4- Audio-CD abspielen (komplett)\n");
      printf("-5- Einzelnen Track abspielen\n");
      printf("-6- &lt;PAUSE&gt; Audio-CD abspielen\n");
      printf("-7- &lt;FORTFAHREN&gt; Audio-CD abspielen\n");
      printf("-8- &lt;STOP&gt; Audio-CD abspielen\n");
      printf("-9- Aktuellen Status ermitteln\n");
      printf("-10- CD-Inhalt ausgeben\n");
      printf("-11- Programmende\n");
      printf("\nIhre Auswahl : ");
      scanf("%d",&amp;select);
      switch( select ) {
         case 1: open_tray( fd_cdrom ); break;
         case 2: close_tray( fd_cdrom ); break;
         case 3: capability_cdrom (fd_cdrom); break;
         case 4: play_cdrom (fd_cdrom, FULL); break;
         case 5: printf("Welchen Track wollen Sie h&ouml;ren: ");
                 scanf("%d",&amp;track);
                 play_cdrom( fd_cdrom, track); break;
         case 6: pause_cdrom( fd_cdrom ); break;
         case 7: resume_cdrom( fd_cdrom ); break;
         case 8: stop_cdrom( fd_cdrom ); break;
         case 9: get_audio_status( fd_cdrom );break;
         case 10: content_cdrom( fd_cdrom ); break;
         case 11: printf("Bye\n"); break;         
         default : printf("H&auml;h!\n");         
      }      
   } while( select != 11 );
   stop_cdrom( fd_cdrom );
   close (fd_cdrom);
   return 0;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o cdrom cdrom.c
$ ./cdrom
-1- CD-Tray &ouml;ffnen
-2- CD-Tray schlie&szlig;en
-3- CDROM-F&auml;higkeiten
-4- Audio-CD abspielen (komplett)
-5- Einzelnen Track abspielen
-6- &lt;PAUSE&gt; Audio-CD abspielen
-7- &lt;FORTFAHREN&gt; Audio-CD abspielen
-8- &lt;STOP&gt; Audio-CD abspielen
-9- Aktuellen Status ermitteln
-10- CD-Inhalt ausgeben
-11- Programmende
Ihre Auswahl : ...</pre>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap05-004.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap06-000.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap05-005.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:57:10 GMT -->
</html>
