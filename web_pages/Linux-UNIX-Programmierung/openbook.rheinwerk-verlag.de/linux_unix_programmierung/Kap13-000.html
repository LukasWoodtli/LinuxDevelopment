<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap13-000.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:56:52 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – 13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap12-008.html">
<link rel="next" href="Kap13-001.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap12-008.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap13-001.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a class="navh2" href="#RxxKap13000040004691F01E100">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap13000040004691F01E103">13.1 termios</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap13000040004691F01E111">13.1.1 Terminalattribute bearbeiten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap13000040004691F01E1FF">13.1.2 Flags setzen und l&ouml;schen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap13000040004691F01E214">13.1.3 Terminalidentifizierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap13000040004691F01E224">13.1.4 Geschwindigkeitskontrolle – Baudrate von Terminals einstellen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap13-001.html#RxxKap13001040004861F025100">13.2 terminfo</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-001.html#RxxKap13001040004861F025108">13.2.1 terminfo verwenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-001.html#RxxKap13001040004861F0251A8">13.2.2 terminfo initialisieren – setupterm()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-001.html#RxxKap13001040004861F0251AC">13.2.3 Eigenschaften eines Terminals (Finden von capnames) – tigetflag(), tigetnum() und tigetstr()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-001.html#RxxKap13001040004861F0251D7">13.2.4 Mit terminfo-Eigenschaften arbeiten – putp(), tputs(), tparm()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap13-002.html#RxxKap13002040004871F010100">13.3 ncurses – Halbgrafik</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F010105">13.3.1 ncurses initialisieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F010110">13.3.2 Tastaturmodus und Ein- und Ausgabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F0101BB">13.3.3 Eigenschaft der Fenster</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F0101CD">13.3.4 Scrolling</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F0101DB">13.3.5 Attribute und Farben setzen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F010219">13.3.6 Fensterroutinen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap13-002.html#RxxKap13002040004871F010243">13.3.7 Mausprogrammierung mit ncurses</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<h1 class="t1">Kapitel 13 <a id="RxxKap132TerminalEAundBenutzerschnittstellenfurdieKonsole" name="RxxKap132TerminalEAundBenutzerschnittstellenfurdieKonsole"></a>Terminal E/A und Benutzerschnittstellen f&uuml;r die Konso<a id="RxxKap13000040004691F01E100" name="RxxKap13000040004691F01E100"></a>le</h1>
<p class="anleser"><i>Das Thema der Benutzerschnittstelle wird leider in vielen B&uuml;chern wenig bis gar nicht behandelt. Aber es ist gerade die Bedienung eines Programms, die zwischen einer brauchbaren und unbrauchbaren Anwendung unterscheidet. Dies gilt vor allem auch f&uuml;r die Kommandozeilenanwendungen – wo keine grafische Oberfl&auml;che f&uuml;r die Interaktion zwischen dem Benutzer und PC vorhanden ist.</i></p>
<p><a id="Xxx999237" name="Xxx999237"></a>Eines gleich zu Beginn. Bei diesem Kapitel handelt es sich lediglich um eine Einf&uuml;hrung zu den Themen rund um das Terminal und deren Ein- und Ausgabe. Eine umfangreichere Abhandlung zu den Themen termios, terminfo und curses w&uuml;rde ein ganzes Buch f&uuml;llen. Dennoch sind diese Grundlagen ausreichend, um anschlie&szlig;end mithilfe der entsprechenden Manual Pages sinnvoll damit arbeiten zu k&ouml;nnen.</p>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">13.1 <a id="RxxKap135termios" name="RxxKap135termios"></a>termi<a id="RxxKap13000040004691F01E103" name="RxxKap13000040004691F01E103"></a>os 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p><a id="Xxx999242" name="Xxx999242"></a><a id="Xxx999243" name="Xxx999243"></a>In diesem Kapitel erfahren Sie, wie Sie ein Terminal kontrollieren k&ouml;nnen. Dabei werden Sie auf einer sehr tiefen Ebene, der API termios, die von POSIX.1 standardisiert wurde, zugreifen. Terminals sind &uuml;ber serielle Schnittstellen mit Linux-Rechnern verbunden. Um Sie jetzt nicht zu verwirren, wenn Sie eine Konsole verwenden, arbeiten Sie in gleicher Weise wie mit einer Terminalleitung, auch wenn keine Verbindung &uuml;ber die serielle Schnittstelle vorliegt. Somit ist die Grundlage eines auf dem Bildschirm konfigurierten Terminals gleichwertig zu einem externen angeschlossenen Terminal.</p>
<p>Die Ein-/Ausgabe eines Terminals ist in der Grundeinstellung immer zeilengepuffert. Ein <span class="listing">read()</span> wird somit erst beendet, wenn die <b>(ENTER)</b>-Taste gedr&uuml;ckt wurde. Dr&uuml;cken Sie stattdessen die Tastenkombination <b>(STRG)</b>+<b>(D)</b>, liefert <span class="listing">read()</span> 0 (EOF) zur&uuml;ck.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Beim Editor vi bedeutet <b>(STRG)</b>+<b>(D)</b> z. B. eine halbe Seite weiterbl&auml;ttern. Nat&uuml;rlich wird hierbei auch kein zeilengepufferter Terminalmodus mehr verwendet (dazu in K&uuml;rze mehr).</p>
</td>
</tr>
</table><br>
<p>Zugegeben, in der Zeit der GUIs (Graphical User Interfaces) mag dieses Thema (Terminal  E/A) altert&uuml;mlich erscheinen, aber wenn es um Netzwerkprogrammierung geht, sind Terminals immer noch unschlagbar. Das Kapitel Terminal E/A handelt u. a. von solchen Themen:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann ich ein Zeichen von der Tastatur lesen?</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann man den Standardzeichensatz von Linux ver&auml;ndern?</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann ich herausfinden, welche Terminals gerade offen sind?</td>
</tr>
</table>
<p><a id="Xxx999254" name="Xxx999254"></a>F&uuml;r ein Terminal stehen Ihnen zwei verschiedene Modi zur Verf&uuml;gung:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Der so genannte kanonische Modus: Hier erfolgt das Lesen und Schreiben zeilenorientiert. Das hei&szlig;t, eine Eingabe wird erst weitergereicht, wenn ein Zeilenabschluss (Linefeed, NL) oder Carriage Return (CR) &uuml;bertragen wurde. F&uuml;r diesen Modus ben&ouml;tigt man die Steuerzeichen des <span class="listing">c_cc</span>-Arrays der <span class="listing">termios</span>-Struktur. Der Nachteil ist, dass ein Programm beim Lesen in diesem Modus so lange wartet (CPU-Zeit vergeudet), bis tats&auml;chlich eine Zeile &uuml;bertragen wurde. Wird kein Zeilenabschluss gelesen, so wird f&uuml;r immer gewartet. Die Aufgabe des Zwischenspeicherns &uuml;bernimmt der Kernel in speziellen Puffern. Es gibt einen Eingabe- und einen Ausgabepuffer. Steuerzeichen regeln, wann welche Puffer entleert werden und somit ihren Inhalt an das Ger&auml;t oder das Programm weitergeben.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Beim nicht kanonischen Modus erfolgt das Lesen oder Schreiben entweder nach einer bestimmten Anzahl an Bytes (was auch nur ein Byte und somit ein Zeichen sein kann), oder es kann eine gewisse Zeit daf&uuml;r angegeben werden. Hierf&uuml;r k&ouml;nnen folgende zwei Felder des Arrays <span class="listing">c_cc</span> gesetzt werden. In <span class="listing">c_cc[VTIME]</span> wird die entsprechende Zeit in Zehntelsekunden und in <span class="listing">c_cc[VMIN]</span> das Minimum der zu lesenden Bytes angegeben.</td>
</tr>
</table>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>So toll sich das hier anh&ouml;ren mag, Sie sollten immer bedenken, dass hierbei doch ein nicht ganz unbedeutender Rechenaufwand betrieben wird, um etwa ein einzelnes Zeichen einzulesen. Mit Aufwand spreche ich hier die CPU-Zeit an, die f&uuml;r Terminal E/A ben&ouml;tigt wird. Bedenken Sie, dass diese API ein Relikt aus recht alten Zeiten ist, wo man mit dem Begriff »Multitasking« in der Praxis noch nichts anfangen konnte.</p>
</td>
</tr>
</table><br>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t32"></a><h3 class="t3">13.1.1 Terminalattribute bearbeiten<a id="RxxKap13000040004691F01E111" name="RxxKap13000040004691F01E111"></a> 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999263" name="Xxx999263"></a>Alle Attribute, die Sie bei einem Terminal setzen bzw. abfragen k&ouml;nnen, sind in der Struktur <span class="listing">termios</span> in der Headerdatei <span class="listing">&lt;termios.h&gt;<a id="Xxx999265" name="Xxx999265"></a></span> definiert.<a id="Xxx999266" name="Xxx999266"></a></p>
<pre>struct termios {
   tcflag_t c_iflag;       /*Eingabeflag*/
   tcflag_t c_oflag;       /*Ausgabeflag*/
   tcflag_t c_cflag;       /*Kontrollflag*/
   tcflag_t c_lflag;       /*Lokale Flags*/
   cc_t c_cc[NCCS];        /*Steuerzeichen*/
};</pre>
<p>Jede dieser Strukturvariablen k&ouml;nnen Sie mit einem bestimmten Terminalflag besetzen bzw. erfragen, ob ein bestimmtes Flag gesetzt ist. Mit der Strukturvariablen <span class="listing">c_iflag</span> k&ouml;nnen die Abl&auml;ufe f&uuml;r die Eingabeoptionen gesetzt oder erfragt werden. Dies beinhaltet den ganzen Terminalablauf, wie der Terminaltreiber die Eingabe noch vor dem Senden an das Programm behandeln soll.</p>
<p>Den Ablauf zur Ausgabe behandeln Sie mit dem Flag <span class="listing">c_oflag</span>. Damit k&ouml;nnen Sie einstellen, wann und wie der Terminaltreiber die Ausgabe behandelt, bevor etwas auf dem Bildschirm ausgegeben wird.</p>
<p>Verschiedene Kontrollflags, die vorwiegend die Merkmale der Hardware vom Terminalger&auml;t ber&uuml;cksichtigen, k&ouml;nnen Sie mit dem Flag <span class="listing">c_cflag</span> setzen.</p>
<p>Mit <span class="listing">c_lflag</span> k&ouml;nnen Sie Terminaleigenschaften setzen bzw. abfragen, wie z. B. ob etwas bei der Eingabe von der Tastatur auf dem Bildschirm ausgegeben werden soll.</p>
<p>Im Array <span class="listing">c_cc</span> finden Sie spezielle Zeichensequenzen (Steuerzeichen) wie <span class="listing">^\</span> (Quit).</p>
<p>Im Folgenden sind die einzelnen Flags und deren Bedeutung aufgelistet, die bei den eben aufgez&auml;hlten Strukturvariablen in der Struktur <span class="listing">termios</span> gesetzt bzw. erfragt werden k&ouml;nnen. Aufgelistet sind nur die Flags, die von POSIX.1 vorgeschrieben sind. In BSD und SVR4 finden Sie hierzu noch einige erweiterte Flags, worauf hier verzichtet wurde – da diese in der Praxis auch nicht allzu h&auml;ufig anzutreffen sind. Einen &Uuml;berblick und noch mehr Details aller m&ouml;glichen Flags finden Sie in der Manual Page zu <span class="listing">termios</span> (man termios).</p>
<p>Folgende symbolische Konstanten k&ouml;nnen f&uuml;r das Eingabeflag <span class="listing">tcflag_t</span> <span class="listing">c_iflag</span> verwendet werden:<a id="Xxx999275" name="Xxx999275"></a></p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 13.1   
    </b>Angaben f&uuml;r das Eingabeflag c_iflag</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">BRKINT
</td>
<td class="tabellentext" bgcolor="#000000">Generieren von SIGINT bei Tastendruck auf (BREAK)
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ICRNL
</td>
<td class="tabellentext" bgcolor="#000000">Umwandeln von CR (Carriage Return) in NL (Newline) bei der Eingabe
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">IGNBRK
</td>
<td class="tabellentext" bgcolor="#000000">Break ignorieren
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">IGNCR
</td>
<td class="tabellentext" bgcolor="#000000">CR (Carriage Return) ignorieren
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">IGNPAR
</td>
<td class="tabellentext" bgcolor="#000000">Bytes mit Parit&auml;tspr&uuml;fung ignorieren
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">INLCR
</td>
<td class="tabellentext" bgcolor="#000000">Umwandeln von NL (Newline) in CR (Carriage Return) – bei CR ignorieren der Eingabe
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">INPCK
</td>
<td class="tabellentext" bgcolor="#000000">Einschalten der Eingabeparit&auml;tspr&uuml;fung
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ISTRIP
</td>
<td class="tabellentext" bgcolor="#000000">Abschneiden des 8. Bits bei Eingabezeichen
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">IXOFF
</td>
<td class="tabellentext" bgcolor="#000000">Einschalten des START-/STOPP-Eingabeprotokolls
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">IXON
</td>
<td class="tabellentext" bgcolor="#000000">Einschalten des START-/STOPP-Ausgabeprotokolls
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PARMRK
</td>
<td class="tabellentext" bgcolor="#000000">Markieren von Parit&auml;tsfehlern
</td>
</tr>
</table><br>
<p>Au&szlig;er den beiden Flags <span class="listing">IXOFF</span> und <span class="listing">IXON</span> sollte Ihnen die Bedeutung der einzelnen Flags recht verst&auml;ndlich sein. Zu <span class="listing">IXOFF</span> und <span class="listing">IXON</span> folgt hierf&uuml;r noch eine genauere Erl&auml;uterung.</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> IXOFF</span> – Wird <span class="listing">IXOFF</span> gesetzt, dann ist das START-/STOPP-Eingabeprotokoll gesetzt. Dies wird wie folgt ben&ouml;tigt. Wenn ein Terminalger&auml;tetreiber feststellt, dass der Eingabepuffer voll ist, wird das Zeichen STOPP an den Terminal ausgegeben. Das sendende Ger&auml;t soll dadurch feststellen, dass es seine &Uuml;bertragung kurz anhalten soll. Ist wieder Platz im Eingabepuffer, wird das START-Zeichen ausgegeben, und der Sender kann mit dem Senden von Daten fortfahren. Dieses Flag wird nur bei seriellen Terminals verwendet, da es hierbei im Gegensatz zu Netzwerkterminals und lokalen Terminals keine eigene Form der Flusskontrolle gibt.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> IXON</span> – Hiermit wird, falls gesetzt, dass START-/STOPP-Ausgabeprotokoll gesetzt. Erh&auml;lt der Terminaltreiber ein STOPP-Zeichen, dann wird die Ausgabe angehalten. Bei einem START-Zeichen wird wieder mit der Ausgabe fortgefahren.</td>
</tr>
</table>
<p>Jetzt zu den Werten des Ausgabeflags <span class="listing">tcflag_t</span> <span class="listing">c_oflag</span>:<a id="Xxx999336" name="Xxx999336"></a></p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 13.2   
    </b>Angaben f&uuml;r das Ausgabeflag c_oflag</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">OPOST
</td>
<td class="tabellentext" bgcolor="#000000">Eine implementierungsdefinierte Ausgabeart einschalten
</td>
</tr>
</table><br>
<p>Als N&auml;chstes folgt ein &Uuml;berblick zu den Kontrollflags <span class="listing">tcflag_t</span> <span class="listing">c_cflag</span>:<a id="Xxx999355" name="Xxx999355"></a></p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 13.3   
    </b>Angaben f&uuml;r das Kontrollflag c_cflag</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">CLOCAL
</td>
<td class="tabellentext" bgcolor="#000000">Ausschalten der Modemsteuerung
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">CREAD
</td>
<td class="tabellentext" bgcolor="#000000">Aktivieren des Empf&auml;ngers
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">CSIZE
</td>
<td class="tabellentext" bgcolor="#000000">Bitanzahl f&uuml;r ein Zeichen (CS5 bis CS8)
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">CSTOPB
</td>
<td class="tabellentext" bgcolor="#000000">Zwei Stopp-Bits anstelle von einem senden
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">HUPCL
</td>
<td class="tabellentext" bgcolor="#000000">Verbindungsabbruch bei Beendigung des letzten Prozesses
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PARENB
</td>
<td class="tabellentext" bgcolor="#000000">Einschalten von Parit&auml;tspr&uuml;fung
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">PARODD
</td>
<td class="tabellentext" bgcolor="#000000">Ungerade Parit&auml;t, sonst gerade
</td>
</tr>
</table><br>
<p>Zum Schluss folgt der &Uuml;berblick zu den lokalen Flags (<span class="listing">tcflag_t</span> <span class="listing">c_lflag</span>):<a id="Xxx999398" name="Xxx999398"></a></p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 13.4   
    </b>Angaben f&uuml;r das lokale Flag c_lflag</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ECHO
</td>
<td class="tabellentext" bgcolor="#000000">Einschalten der ECHO-Funktion
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ECHOE
</td>
<td class="tabellentext" bgcolor="#000000">Gel&ouml;schte Zeichen mit Leerzeichen &uuml;berschreiben
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ECHOK
</td>
<td class="tabellentext" bgcolor="#000000">Zeichen l&ouml;schen oder zur Neueingabe in neue Zeile positionieren
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ECHONL
</td>
<td class="tabellentext" bgcolor="#000000">Ausgabe von NL
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ICANON
</td>
<td class="tabellentext" bgcolor="#000000">Zeilenorientierter Eingabemodus
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">IEXTEN
</td>
<td class="tabellentext" bgcolor="#000000">Einschalten des erweiterten Zeichensatzes f&uuml;r die Eingabe
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">ISIG
</td>
<td class="tabellentext" bgcolor="#000000">Sonderbedeutung von Terminal-Sonderzeichen einschalten
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">NOFLSH
</td>
<td class="tabellentext" bgcolor="#000000">Abschalten des Leerens von Puffern bei INTR oder QUIT
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">TOSTOP
</td>
<td class="tabellentext" bgcolor="#000000">Senden des Signals SIGTTOU bei der Ausgabe durch Hintergrundprozesse
</td>
</tr>
</table><br>
<p>Die Funktionen, womit Sie auf die eben aufgelisteten Flags der Struktur <span class="listing">termios</span> und ihre Mitglieder zugreifen k&ouml;nnen, sind:<a id="Xxx999450" name="Xxx999450"></a><a id="Xxx999451" name="Xxx999451"></a></p>
<pre>#include &lt;termios.h&gt;
#include &lt;unistd. h.&gt;
int tcgetattr(int fd, struct termios *terminal_zeiger);
int tcsetattr( int fd, int option,
               struct termios *terminal_zeiger);</pre>
<p>Wie man aus den Namen der Funktionen herauslesen kann, dient <span class="listing">tc</span>get<span class="listing">attr()</span> dazu, die Attribute eines Terminals zu ermitteln, und <span class="listing">tc</span>set<span class="listing">attr()</span> dazu, die Attribute zu setzen. F&uuml;r den Dateideskriptor <span class="listing">fd</span> geben Sie den Filedeskriptor an, den Sie ver&auml;ndern bzw. abfragen wollen – 0 bzw. <span class="listing">STDIN_FILENO</span> (Standardeingabe) oder 1 bzw. <span class="listing">SDTOUT_FILENO</span> (Standardausgabe). Die Funktionen liefern beide bei einem Fehler –1, ansonsten, wenn alles planm&auml;&szlig;ig verlief, 0 zur&uuml;ck. Mit dem Argument <span class="listing">option</span> bei <span class="listing">tcsetattr()</span> k&ouml;nnen Sie angeben, wann die Ver&auml;nderungen aktiv werden sollen. Folgende Flags k&ouml;nnen dabei verwendet werden:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> TCSANOW<a id="Xxx999454" name="Xxx999454"></a></span> – &Auml;nderung wird sofort aktiv.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> TCSADRAIN<a id="Xxx999456" name="Xxx999456"></a></span> – &Auml;nderung wird aktiv, wenn alle Zeichen aus dem Puffer ausgegeben wurden.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> TCSAFLUSH<a id="Xxx999458" name="Xxx999458"></a></span> – ... wie <span class="listing">TCSADRAIN</span>, nur dass noch alle befindlichen Zeichen im Puffer verworfen werden.</td>
</tr>
</table>
<p>Bevor Sie zur Praxis schreiten, ben&ouml;tigen Sie noch die Kenntnis &uuml;ber eine Variable in der Struktur <span class="listing">termios</span>, die noch nicht zur Sprache kam: das Array <span class="listing">c_cc</span>. Es enth&auml;lt alle Sonderzeichen, die durch das Programm ver&auml;ndert werden k&ouml;nnen. Hier einige Sonderzeichen dazu. Weitere Zeichen finden Sie unter <span class="listing">/usr/include/termbits.h</span> oder <span class="listing">/usr/include/asm/termbits.h</span>.<a id="Xxx999461" name="Xxx999461"></a></p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 13.5   
    </b>Einige Angaben f&uuml;r das Struktur-Array c_cc</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VEOF
</td>
<td class="tabellentext" bgcolor="#000000">Dateiende
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VEOL
</td>
<td class="tabellentext" bgcolor="#000000">Zeilenende
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VERASE
</td>
<td class="tabellentext" bgcolor="#000000">Letztes Zeichen l&ouml;schen
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VINTR
</td>
<td class="tabellentext" bgcolor="#000000">Unterbrechungssignal SIGINT
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VKILL
</td>
<td class="tabellentext" bgcolor="#000000">Zeile l&ouml;schen
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VQUIT
</td>
<td class="tabellentext" bgcolor="#000000">Abbruch à la SIGQUIT
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VSTOP
</td>
<td class="tabellentext" bgcolor="#000000">Ausgabe anhalten
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VSTART
</td>
<td class="tabellentext" bgcolor="#000000">Ausgabe fortsetzen
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VSTATUS
</td>
<td class="tabellentext" bgcolor="#000000">Statusinformationen anfordern
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VSUSP
</td>
<td class="tabellentext" bgcolor="#000000">Einen Prozess suspendieren
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VWERASE
</td>
<td class="tabellentext" bgcolor="#000000">Letztes Wort l&ouml;schen
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VMIN
</td>
<td class="tabellentext" bgcolor="#000000">Anzahl der Bytes, die gelesen werden m&uuml;ssen, bevor read() zur&uuml;ckkehrt
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">VTIME
</td>
<td class="tabellentext" bgcolor="#000000">Es wird eine entsprechende Zeit in 0.1 Sekunden angegeben.
</td>
</tr>
</table><br>
<p>Dazu ein einfaches Beispiel, womit Sie das Zeichen f&uuml;r <span class="listing">EOF</span>, das mit <b>(STRG)</b>+<b>(C)</b> generiert wird, ver&auml;ndern k&ouml;nnen. Im Beispiel wird auch <span class="listing">EOF</span> ausgel&ouml;st, wenn Sie die <b>(ESC)</b>-Taste dr&uuml;cken. Die Tastenkombination <b>(STRG)</b>+<b>(C)</b> bleibt allerdings trotzdem erhalten.<a id="Xxx999528" name="Xxx999528"></a></p>
<pre><a id="Xxx999529" name="Xxx999529"></a>/* my_eof.c */
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
int main (void) {
  struct termios term;
  int c;
  if ((tcgetattr (STDIN_FILENO, &amp;term)) &lt; 0) {
    printf ("Fehler bei tcgetattr (%s) \n",
       strerror(errno));
    exit (EXIT_FAILURE);
  }
  // ASCII-Code 27 = ESC == EOF
  term.c_cc[VEOF] = 27;   
  if ((tcsetattr (STDIN_FILENO, TCSAFLUSH, &amp;term)) &lt; 0) {
    printf ("Fehler bei tcsetattr (%s) \n",
       strerror(errno));
    exit (EXIT_FAILURE);
  }
  printf("Eingabe machen (mit ESC abbrechen)\n");
  while ((c = getchar ()) != EOF)
    putchar (c);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o my_eof my_eof.c
$ ./my_eof
Eingabe machen (mit ESC abbrechen)
Eine Eingabe
Eine Eingabe
[ESC]</pre>
<p>In diesem Beispiel haben Sie das Sonderzeichen <span class="listing">EOF</span> ver&auml;ndert. Mit der Angabe von</p>
<pre>term.c_cc[VEOF] = 27;</pre>
<p>bekommt das Sonderzeichen <span class="listing">EOF</span> (<span class="listing">VEOF</span>) den ASCII-Code 27 zugewiesen, der dem Escape-Zeichen entspricht. Mit</p>
<pre>if((tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;term)) &gt; 0)</pre>
<p>setzen Sie die Attributs&auml;nderung in Kraft. Jetzt folgt der Test, ob es auch funktioniert:</p>
<pre>while((c=getchar()) != EOF)
      putchar(c);</pre>
<p>So lange, bis Sie EOF bet&auml;tigen, k&ouml;nne Sie etwas mit der Tastatur eingeben. In diesem Beispiel w&auml;re das Programm zu Ende, wenn die Escape-(<b>(ESC)</b>)-Taste gedr&uuml;ckt wird statt, wie gew&ouml;hnlich verwendet, die Tastenkombination <b>(STRG)</b>+<b>(D)</b>.</p>
<p>Da nicht jeder s&auml;mtliche ASCII-Code-Zeichen im Kopf hat – geschweige den Wert der Sonderzeichen –, ist in der Headerdatei <span class="listing">&lt;termios.h&gt;</span> noch folgendes Makro definiert:</p>
<pre>#ifndef CTRL
   #define CTRL(ch) ((ch)&amp;0x1F)
#endif</pre>
<p>Falls dies bei Ihnen nicht vorhanden sein sollte, so wissen Sie ja jetzt, wie Sie es selbst definieren k&ouml;nnen. Damit k&ouml;nnen Sie die Eingabe eines Sonderzeichens, z. B. die Tastenkombination <b>(STRG)</b>+<b>(Y)</b>, folgenderma&szlig;en festlegen:</p>
<pre>term.c_cc[VEOF] = CTRL('Y');</pre>
<p>Hiermit w&uuml;rden Sie mit der Tastenkombination <b>(STRG)</b>+<b>(Y)</b> das EOF-Zeichen generieren.</p>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t33"></a><h3 class="t3">13.1.2 Flags setzen und l&ouml;schen<a id="RxxKap13000040004691F01E1FF" name="RxxKap13000040004691F01E1FF"></a> 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999546" name="Xxx999546"></a><a id="Xxx999547" name="Xxx999547"></a>Um einzelne oder mehrere Flags f&uuml;r <span class="listing">c_iflag</span>, <span class="listing">c_oflag</span>, <span class="listing">c_cflag</span> und <span class="listing">c_lflag</span> zu setzen bzw. abzufragen, wird wie folgt vorgegangen:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Flag(s) setzen:</td>
</tr>
</table>
// einzelnes Flag setzen
c_iflag | &lt;flag&gt;              
// mehrere Flags setzen ( hier flag1, flag2 und flag3)
c_iflag | &lt;flag1|flag2|flag3&gt;
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Flag(s) l&ouml;schen:</td>
</tr>
</table>
// einzelnes Flag l&ouml;schen
c_iflag &amp; ~&lt;flag&gt;            
// mehrere Flags l&ouml;schen (hier flag1, flag2 und flag3)
c_iflag &amp; ~&lt;flag1|flag2|flag3&gt;  
<p>Hierzu folgt ein einfaches Beispiel, in dem Sie eine Linux-&uuml;bliche Passworteingabe machen k&ouml;nnen. Im Beispiel wird das Flag <span class="listing">ECHO</span> abgeschaltet, womit die Eingabe nicht am Bildschirm angezeigt wird. Das Flag <span class="listing">ECHONL</span> hingegen wird eingeschaltet, damit nach Eingabe des Passwortes durch Bet&auml;tigung von <b>(ENTER)</b> dieses Newline-Zeichen ausgegeben wird – und das Programm auch sauber in der n&auml;chsten Zeile fortf&auml;hrt. Am Ende stellen Sie den zuvor gesicherten Terminalzustand wieder her.</p>
<pre><a id="Xxx999554" name="Xxx999554"></a>/* my_getpass.c */
#include &lt;termios.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define PASS 8
static char *my_getpass (void) {
  struct termios origstate, changedstate, teststate;
  char passwort[PASS];
  char *p = passwort;
  /* alten Terminalzustand speichern (von stdin = id 0) */
  if (tcgetattr (0, &amp;origstate) != 0)
    printf ("tcgetattr failed");
  changedstate = origstate;
  /* neuen Terminalzustand setzen (von stdin = id 0) */
  /* Ausgabe ausschalten */
  changedstate.c_lflag &amp;= ~ECHO;   
  /* Newline beachten (einschalten) */
  changedstate.c_lflag |= ECHONL;
  if (tcsetattr (0, TCSANOW, &amp;changedstate) != 0)
    printf ("tcsetattr failed");
  /* &Uuml;berpr&uuml;fen, ob der Terminalzustand erfolgreich */
  /* ver&auml;ndert wurde                                */
  tcgetattr (0, &amp;teststate);
  if (teststate.c_lflag &amp; ECHO)
    printf ("ECHO-Flag konnte nicht abgeschaltet werden\n");
  if (!teststate.c_lflag &amp; ECHONL)
    printf ("ECHONL konnte nicht eingeschaltet werden\n");
  fprintf(stdout,"Passwort eingeben : ");
  fgets(passwort, PASS, stdin);
  /* alten Terminalzustand wiederherstellen */
  /* (von stdin = id 0)                     */
  if (tcsetattr (0, TCSANOW, &amp;origstate) != 0)
    printf ("tcsetattr failed");
  return p;
}
int main (void) {
  char *ptr = my_getpass();
  printf("Ihre Eingabe war: %s\n",ptr);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o my_getpass my_getpass.c
$./my_getpass
Passwort eingeben :********
Ihre Eingabe war: juergen</pre>
<p><a id="Xxx999558" name="Xxx999558"></a>Jetzt zu einem weiteren Beispiel, das Ihnen zeigt, wie Sie bestimmte Steuerzeichen von der Tastatur abfragen k&ouml;nnen. Im Beispiel werden Tastendr&uuml;cke wie <b>(F1)</b>, <b>(F2)</b>, die Pfeiltasten oben, unten, rechts und links, <b>(Page_½)</b>, <b>(Page_¼)</b>und <b>(Home)</b> &uuml;berpr&uuml;ft. Sie k&ouml;nnen dies nat&uuml;rlich noch weiter ausstricken. Dabei werden die lokalen Flags <span class="listing">ECHO</span>, <span class="listing">ICANON</span> und <span class="listing">ISIG</span> abgeschaltet. Sie sollten das Beispiel au&szlig;erdem in einem echten Terminal ausf&uuml;hren, damit es richtig l&auml;uft – sonst wird z. B. <b>(F1)</b> nicht angezeigt. Ein echtes Terminal k&ouml;nnen Sie durch gleichzeitiges Dr&uuml;cken von <b>(STRG)</b>+<b>(ALT)</b>+<b>(F1)</b> &ouml;ffnen. Zur&uuml;ck zu Ihrer grafischen Oberfl&auml;che kommen Sie wieder mit der Tastenkombination <b>(STRG)</b>+<b>(ALT)</b>+<b>(F7)</b>. Das Programm ist recht ordentlich dokumentiert, womit ich mir weitere Erkl&auml;rungen ersparen kann.</p>
<pre><a id="Xxx999560" name="Xxx999560"></a>/* keystroke.c */
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
/*Altes Terminal wiederherstellen */
static struct termios BACKUP_TTY;
/* Eingabekanal wird so umge&auml;ndert, damit die Tasten */
/* einzeln  abgefragt werden k&ouml;nnen                 */
static int new_tty (int fd) {
  struct termios buffer;
  /* Wir fragen nach den Attributen des Terminals und */
  /* &uuml;bergeben diese dann an buffer. BACKUP_TTY dient   */
  /* bei Programmende zur Wiederherstellung der alten   */
  /* Attribute und bleibt somit unber&uuml;hrt.              */
  if ((tcgetattr (fd, &amp;BACKUP_TTY)) == -1)
    return -1;
  buffer = BACKUP_TTY;
  /* Lokale Flags werden gel&ouml;scht :                   */
  /* ECHO - Zeichenausgabe auf Bildschirm             */
  /* ICANON - Zeilenorientierter Eingabemodus         */
  /* ISIG – Terminal-Steuerzeichen (kein STRG+C mehr  */
  /* m&ouml;glich)                                         */
  buffer.c_lflag = buffer.c_lflag &amp; ~(ECHO | ICANON | ISIG);
  /* VMIN=Anzahl der Bytes, die gelesen werden m&uuml;ssen, */
  /* bevor read() zur&uuml;ckkehrt                          */
  /* In unserem Beispiel 1 Byte f&uuml;r 1 Zeichen          */
  buffer.c_cc[VMIN] = 1;
  /*Wir setzen jetzt die von uns gew&uuml;nschten Attribute*/
  if ((tcsetattr (fd, TCSAFLUSH, &amp;buffer)) == -1)
    return -1;
  return 0;
}
/*Urspr&uuml;ngliches Terminal wiederherstellen*/
static int restore_tty (int fd) {
  if ((tcsetattr (fd, TCSAFLUSH, &amp;BACKUP_TTY)) == -1)
    return -1;
  return 0;
}
int main (int argc, char **argv) {
  int rd;
  char c, buffer[10];
  /*Setzen des neuen Modus*/
  if (new_tty (STDIN_FILENO) == -1) {
    printf ("Fehler bei der Funktion new_tty()\n");
    exit (EXIT_FAILURE);
  }
  do {
    /*Erste Zeichen lesen*/
    if (read (STDIN_FILENO, &amp;c, 1) &lt; 1) {
      printf ("Fehler bei read\n");
      restore_tty (STDIN_FILENO);
      exit (EXIT_FAILURE);
    }
    /*Haben wir ein ESC ('\E') gelesen? */
    if (c == 27) {
      /* Ja, eine Escape-Sequenz, wir wollen den Rest */
      /* der Zeichen auslesen                        */
      rd = read (STDIN_FILENO, buffer, 4);
      buffer[rd] = '\0';   /*String terminieren */
      /*Folg. Werte haben die Funktionstasten in der Term */
      /*   F1 = \E[[A            */
      /*   F2 = \E[[B            */
      /*   PFEIL RECHTS= \E[C    */
      /*   PFEIL LINKS = \E[D    */
      /*   PFEIL RUNTER= \E[B    */
      /*   PFEIL HOCH = \E[A     */
      /*   POS 1 = \E[1~         */
      /*   BILD RUNTER = \E[6~   */
      /*   BILD HOCH = \E[5~     */
      if (strcmp (buffer, "[[A") == 0)
        printf ("F1\n");
      if (strcmp (buffer, "[[B") == 0)
        printf ("F2\n");
      if (strcmp (buffer, "[C") == 0)
        printf ("-&gt;\n");
      if (strcmp (buffer, "[D") == 0)
        printf ("&lt;-\n");
      if (strcmp (buffer, "[B") == 0)
        printf ("V\n");
      if (strcmp (buffer, "[A") == 0)
        printf ("^\n");
      if (strcmp (buffer, "[1~") == 0)
        printf ("POS 1\n");
      if (strcmp (buffer, "[6~") == 0)
        printf ("BILD RUNTER\n");
      if (strcmp (buffer, "[5~") == 0)
        printf ("BILD HOCH\n");
      /* Nein, kein ESC ... */
    } 
    else {
      if ((c &lt; 32) || (c == 127))
        /*Nummerischen Wert ausgeben */
        printf ("%d\n", c);   
      else
        /*Zeichen ausgeben */
        printf ("%c\n", c);   
    }
  } while (c != 'q');
  restore_tty (STDIN_FILENO);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o keystroke keystroke.c
$ ./keystroke
^
-&gt;
&lt;-
V
BILD HOCH
BILD RUNTER
F1 
F2
POS1
q</pre>
<p><a id="Xxx999564" name="Xxx999564"></a>Zum Abschluss noch ein Beispiel, wie Sie eine einzelne Taste abfragen bzw. abfangen k&ouml;nnen. Dazu m&uuml;ssen Sie das Terminal in den Raw-Modus schalten – oder besser w&auml;re wohl abschalten. Denn wie der Name raw (f&uuml;r roh, unbearbeitet) schon andeutet, handelt es sich hier um einen fast nackten Terminalmodus – dabei werden vorwiegend Flags ausgeschaltet. Lediglich das Kontrollflag, wie gro&szlig; ein Zeichen in Bits ist, wird dabei gesetzt.</p>
<pre><a id="Xxx999566" name="Xxx999566"></a>/* my_getch.c */
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
#include &lt;stdlib.h&gt;
 
static struct termios new_io;
static struct termios old_io;
/* Funktion schaltet das Terminal in den Raw-Modus:            */
/* Folgende Eingabeflags werden gel&ouml;scht:                      */
/*               BRKINT, ICRNL, INPCK, ISTRIP, IXON            */
/* Folgende Kontrollflags werden gel&ouml;scht: CSIZE, PERENB       */
/* Folgende Ausgabeflags werden gel&ouml;scht: OPOST                */
/* Folgende lokale Flags werden gel&ouml;scht:                      */
/*                           ECHO, ICANON, IEXTEN, ISIG        */
/* Gesetzt wird das Kontrollflag CS8, was bedeutet,            */
/* dass ein Zeichen 8 Bit breit ist                            */
/* Steuerzeichen: Leseoperation liefert 1 Byte VMIN=1 VTIME=1  */
static int raw (int fd) {
  /* Sichern unseres Terminals */
  if ((tcgetattr (fd, &amp;old_io)) == -1)
    return -1;
  new_io = old_io;
  /* Wir ver&auml;ndern jetzt die Flags f&uuml;r den Raw-Modus */
  new_io.c_iflag =
    new_io.c_iflag &amp; ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  new_io.c_oflag = new_io.c_iflag &amp; ~(OPOST);
  new_io.c_cflag = new_io.c_cflag &amp; ~(CSIZE | PARENB);
  new_io.c_lflag = new_io.c_lflag &amp; ~(ECHO|ICANON|IEXTEN|ISIG);
  new_io.c_cflag = new_io.c_cflag | CS8;
  new_io.c_cc[VMIN]  = 1;
  new_io.c_cc[VTIME] = 0;
  /*Jetzt setzen wir den Raw-Modus*/
  if ((tcsetattr (fd, TCSAFLUSH, &amp;new_io)) == -1)
    return -1;
  return 0;
}
/*Funktion zur Abfrage einer Taste*/
static int getch () {
  int c;
  if (raw (STDIN_FILENO) == -1) {
    printf ("Fehler bei der Funktion raw()\n");
    exit (EXIT_FAILURE);
  }
  c = getchar ();
  /*Alten Terminalmodus wiederherstellen*/
  tcsetattr (STDIN_FILENO, TCSANOW, &amp;old_io);
  return c;
}
int main (void) {
  int zeichen;
  printf ("Warte auf'q', um das Programm zu beenden\n");
  while ((zeichen = getch ()) != 'q')
    printf ("'%c' != 'q'\n", zeichen);
  printf ("'%c' == 'q'\n", zeichen);
  printf ("ENDE\n");
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o my_getch my_getch.c
$ ./my_getch
Warte auf'q', um das Programm zu beenden
'a' != 'q'
's' != 'q'
'd' != 'q'
'f' != 'q'
'j' != 'q'
'k' != 'q'
'l' != 'q'
'&ouml;' != 'q'
'q' == 'q'
ENDE</pre>
<p>Die Funktion <span class="listing">raw()</span> schaltet das Terminal in den Raw-Modus, und mit der Funktion <span class="listing">getch()</span> k&ouml;nnen Sie dann nach einer einzelnen oder irgendeiner Taste fragen. Den gro&szlig;en Overhead der Funktion <span class="listing">raw()</span> k&ouml;nnen Sie sich ersparen, da Linux/UNIX daf&uuml;r eine Funktion f&uuml;r uns bereith&auml;lt:<a id="Xxx999571" name="Xxx999571"></a></p>
<pre>#include &lt;termios.h&gt;
int cfmakeraw(struct termios *tty_zeiger);</pre>
<p>Diese Funktion ist ebenfalls in der Headerdatei <span class="listing">&lt;termios.h&gt;</span> definiert und erleichtert Ihnen den Schritt, das Terminal in den Raw-Modus zu setzen.</p>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t34"></a><h3 class="t3">13.1.3 Terminalidentifizierung<a id="RxxKap13000040004691F01E214" name="RxxKap13000040004691F01E214"></a> 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999575" name="Xxx999575"></a>Um den Namen des Terminals zu erfragen, der gerade die Kontrolle hat, k&ouml;nnen Sie folgende Funktion verwenden:<a id="Xxx999577" name="Xxx999577"></a></p>
<pre>#include &lt;stdio.h&gt;
char *ctermid(char *s);</pre>
<p>Die Funktion <span class="listing">ctermid()</span> gibt einen String mit dem Pfadnamen des Kontrollterminals f&uuml;r den aktuellen Prozess zur&uuml;ck. In den meisten F&auml;llen d&uuml;rfte dies <span class="listing">/dev/tty</span> sein. F&uuml;r <span class="listing">s</span> sollten Sie mindestens <span class="listing">L_ctermid<a id="Xxx999580" name="Xxx999580"></a></span> Bytes Speicherplatz reservieren. Die symbolische Konstante <span class="listing">L_ctermid</span> ist in der Headerdatei <span class="listing">&lt;stdio.h&gt;</span> definiert. Die Funktion gibt bei Erfolg einen Zeiger auf einen Puffer zur&uuml;ck, der auf den Namen des Kontrollterminals verweist, ansonsten wird bei einem Fehler <span class="listing">NULL</span> zur&uuml;ckgegeben. Hierzu ein kurzes Beispiel der Funktion <span class="listing">ctermid()</span>:</p>
<pre><a id="Xxx999581" name="Xxx999581"></a>/* my_tty.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
static char termname[L_ctermid];
int main (void) {
   const char *ptr = ctermid (termname);
   if (ptr != NULL)
      printf ("Kontrollterminalname = %s\n", ptr);
   else
      printf("Konnte Terminalname nicht ermitteln\n");
   return EXIT_SUCCESS;
}</pre>
<p>Wenn Sie die Adresse des Terminalpfadnamens ben&ouml;tigen, k&ouml;nnen Sie die folgende Funktion verwenden:<a id="Xxx999584" name="Xxx999584"></a><a id="Xxx999585" name="Xxx999585"></a></p>
<pre>char *ttyname(int fd);</pre>
<p>Die Funktion liefert einen nullterminierten Pfadnamen (in einem statischen Speicherbereich) des Terminalger&auml;tes zur&uuml;ck, womit der Filedeskriptor <span class="listing">fd</span> ge&ouml;ffnet wurde. Bei einem Fehler oder wenn <span class="listing">fd</span> mit keinem Terminal verbunden ist, wird <span class="listing">NULL</span> zur&uuml;ckgegeben. Auch hierzu ein einfaches Beispiel:</p>
<pre><a id="Xxx999588" name="Xxx999588"></a>/* sende.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
int main(int argc, char **argv) {
  printf("Nachricht von Terminal %s\n%s",
     ttyname(STDIN_FILENO), *++argv);
  return EXIT_SUCCESS;
}</pre>
<p>&Ouml;ffnen Sie nun zwei Pseudo-Konsolen (<span class="listing">pts</span>) unter X. Ermitteln Sie zuerst mit diesem Programm den Pfad der Konsole (<span class="listing">tty</span>). In meinem Beispiel hat Konsole 1 den Pfad <span class="listing">/dev/pts/2</span> und Konsole 2 den Pfad <span class="listing">/dev/pts/3</span>. F&uuml;hren Sie das Programm folgenderma&szlig;en aus (der Programmname sei <span class="listing">sende</span>):</p>
<pre>---[/dev/pts/2]---
$ ./sende hallo &gt; /dev/pts/3</pre>
<p>Auf der Konsole <span class="listing">/dev/pts/3</span> steht jetzt:</p>
<pre>---[/dev/pts/3]---
Nachricht von Terminal /dev/pts/2
hallo</pre>
<p>Wenn Sie wollen, k&ouml;nnen Sie jetzt vom Terminal <span class="listing">/dev/pts/3</span>, wie eben gemacht, eine Nachricht an <span class="listing">/dev/pts/2</span> senden. Dies funktioniert daher, da Sie mit</p>
<pre>ttyname(STDIN_FILENO)</pre>
<p>den Terminalnamen der Standardeingabe abfragen. Sie k&ouml;nnen ja statt der Standardeingabe die Standardausgabe abfragen (<span class="listing">STDOUT_FILENO</span>).</p>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t35"></a><h3 class="t3">13.1.4 Geschwindigkeitskontrolle – Baudrate von Terminals einstellen<a id="RxxKap13000040004691F01E224" name="RxxKap13000040004691F01E224"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999598" name="Xxx999598"></a>Jetzt zu einigen Funktionen, womit Sie die Geschwindigkeit der Ein-/Ausgabe eines Terminalger&auml;tes ver&auml;ndern oder erfragen k&ouml;nnen. Diese Schnittstelle ist schon sehr alt, weshalb hier f&uuml;r die Geschwindigkeit noch Baud verwendet wird. Die korrekte Bezeichnung w&uuml;rde Bits pro Sekunde (bps) lauten. Damit k&ouml;nnen Sie zum Beispiel testen, wie die Geschwindigkeit zwischen zwei Terminals im Netzwerk ist. Folgende Funktionen stehen Ihnen zum Erfragen der Geschwindigkeit zur Verf&uuml;gung:<a id="Xxx999600" name="Xxx999600"></a><a id="Xxx999601" name="Xxx999601"></a><a id="Xxx999602" name="Xxx999602"></a></p>
<pre>#include &lt;termios.h&gt;
speed_t cfgetispeed(const struct termios *tty_zeiger);
speed_t cfgetospeed(const struct termios *tty_zeiger);</pre>
<p>Beide Funktionen sind in der Headerdatei <span class="listing">termios.h</span> definiert und geben die momentan gesetzte Baudrate zur&uuml;ck, wobei <span class="listing">cfgetispeed()</span> die Geschwindigkeit der Eingabe und <span class="listing">cfgetospeed()</span> die Geschwindigkeit der Ausgabe zur&uuml;ckgibt. Folgende Konstanten sind hierf&uuml;r auf alle F&auml;lle definiert:</p>
<pre>B0,B50,B75,B110,B134,B150,B200,B300,B600,
B1200,B1800,B2400,B4800,B9600,B19200,B38400</pre>
<p>Wobei <span class="listing">B0</span> f&uuml;r die Beendigung einer Verbindung steht. Weiterhin k&ouml;nnen (unter Linux auf alle F&auml;lle) vorhanden sein:</p>
<pre>B57600,B115200,B230400,B460800</pre>
<p>Angewendet werden diese Funktionen folgenderma&szlig;en:</p>
<pre>baudrate = funktion_erfrage_baudrate(cfgetispeed(&amp;terminal));
...
unsigned long funktion_erfrage_baudrate(speed baudkonstante) {
    if(baudkonstante == B0)              return(0);
    else if(baudkonstante == B50)        return(50);
    else if(baudkonstante == B75)        return(75);
    ...
    ...
    else if(baudkonstante == B460800)    return(460800);
    else   return -1;
}</pre>
<p>Hier das Beispiel, womit Sie die Baudrate eines Terminalger&auml;tes erfragen, das Sie in der Kommandozeile als zweites Argument mit angeben.</p>
<pre><a id="Xxx999611" name="Xxx999611"></a>/* baud.c */
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
 
typedef unsigned long Ulong;
typedef struct termios TTY;
static speed_t baud_konstante[] = {
       B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200,
       B1800, B2400, B4800, B9600, B19200, B38400, B57600,
       B115200, B230400/*, B460800 */
     };
static Ulong baud_werte[] = {
       0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
       1800, 2400, 4800, 9600, 19200, 38400, 57600,
       115200, 230400/*, 460800 */
     };
static Ulong baudrate_wert (speed_t baud) {
  int i;
  for (i = 0; i &lt;= 19; i++) {
    if (baud == baud_konstante[i])
      return (baud_werte[i]);
  }
  return -1;
}
int main (int argc, char **argv) {
  int fd;
  speed_t baud_input, baud_output;
  TTY terminal;
  if (argc != 2) {
    printf ("Usage: %s Ger&auml;tepfad\n", *argv);
    exit (EXIT_FAILURE);
  }
  if ((fd = open (argv[1], O_RDWR | O_NONBLOCK)) == -1) {
    perror ("fopen()");
    exit (EXIT_FAILURE);
  }
  if (isatty (fd) == 0) {
    printf ("%s ist keine tty\n", argv[1]);
    exit (EXIT_FAILURE);
  }
  if (tcgetattr (fd, &amp;terminal) == -1) {
    printf ("Fehler bei tcgetattr()\n");
    exit (EXIT_FAILURE);
  }
  if((baud_input=baudrate_wert(cfgetispeed(&amp;terminal))) == -1) {
    printf ("Fehler bei baud_input ...\n");
    exit (EXIT_FAILURE);
  }
  if((baud_output=baudrate_wert(cfgetospeed(&amp;terminal))) == -1) {
    printf ("Fehler bei baud_output ...\n");
    exit (EXIT_FAILURE);
  }
  printf ("Eingabe-Baudrate : %d\n", baud_input);
  printf ("Ausgabe-Baudrate : %d\n", baud_output);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o baud baud.c
$ ./baud /dev/tty
Eingabe-Baudrate : 38400
Ausgabe-Baudrate : 38400</pre>
<p>Neu in diesem Programm ist die Funktion:<a id="Xxx999615" name="Xxx999615"></a></p>
<pre>#include  &lt;unistd. h.&gt;
int isatty(int fd);</pre>
<p>Damit k&ouml;nnen Sie abfragen, ob ein Filedeskriptor auf das Terminal eingestellt ist. Wichtig an den Funktionen <span class="listing">cf</span>get<span class="listing">...()</span> und <span class="listing">cf</span>set<span class="listing">...()</span> ist, wenn Sie mit <span class="listing">cfgetispeed()</span> etwas abfragen wollen, f&uuml;hren Sie zuerst mit der Funktion <span class="listing">tcgetattr()</span> die Struktur <span class="listing">termios</span> f&uuml;r das betreffende Ger&auml;t eine Abfrage aus. Dasselbe gilt auch, wenn Sie die beiden folgenden Funktionen einsetzen wollen.<a id="Xxx999619" name="Xxx999619"></a><a id="Xxx999620" name="Xxx999620"></a><a id="Xxx999621" name="Xxx999621"></a></p>
<pre>#include &lt;termios.h&gt;
int cfsetispeed( struct termios *termzeiger, 
                 speed_t baudrate );
int cfsetospeed( struct termios *termzeiger, 
                 speed_t baudrate);</pre>
<p>Auch hier m&uuml;ssen Sie die Aufrufe erst mit dem <span class="listing">tcsetattr()</span>-Aufruf aktivieren. Hier das Beispiel, erweitert um die M&ouml;glichkeit, die Baudrate auf 115200 hoch zu setzen.</p>
<pre><a id="Xxx999624" name="Xxx999624"></a>/* setbaud.c */
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;termios.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
typedef unsigned long Ulong;
typedef struct termios TTY;
static speed_t baud_konstante[] = {
       B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200,
       B1800, B2400, B4800, B9600, B19200, B38400, B57600,
       B115200, B230400/*, B460800 */
      };
static Ulong baud_werte[] = {
       0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
       1800, 2400, 4800, 9600, 19200, 38400, 57600,
       115200, 230400/*, 460800 */
     };
// R. W. Stevens-like Fehlerbehandlung
static void fehler_exit (char *error_msg, ...) {
  va_list az;
  va_start (az, error_msg);
  vprintf (error_msg, az);
  va_end (az);
  exit (EXIT_FAILURE);
}
static Ulong baudrate_wert (speed_t baud) {
  int i;
  for (i = 0; i &lt;= 19; i++) {
    if (baud == baud_konstante[i])
      return (baud_werte[i]);
  }
  return -1;
}
int main (int argc, char **argv) {
  int fd;
  speed_t baud_input, baud_output;
  TTY terminal;
  if (argc != 2)
    fehler_exit ("Bitte einen Ger&auml;tepfad mit angeben\n");
  if ((fd = open (argv[1], O_RDWR | O_NONBLOCK)) == -1)
    fehler_exit ("Konnte %s nicht &ouml;ffnen\n", argv[1]);
  if (isatty (fd) == 0)
    fehler_exit ("%s ist kein tty\n", argv[1]);
  if (tcgetattr (fd, &amp;terminal) == -1)
    fehler_exit ("Fehler bei tcgetattr()\n");
  if((baud_input=baudrate_wert(cfgetispeed(&amp;terminal))) == -1)
    fehler_exit ("Fehler bei baud_input ...\n");
  if((baud_output=baudrate_wert(cfgetospeed(&amp;terminal))) == -1)
    fehler_exit ("Fehler bei baud_output ...\n");
  printf ("Eingabe-Baudrate : %d\n", baud_input);
  printf ("Ausgabe_Baudrate : %d\n", baud_output);
  if ((cfsetispeed (&amp;terminal, B115200)) == -1)
    fehler_exit("Fehler beim Setzen von Eingabe-Baudrate ...\n");
  if ((cfsetospeed (&amp;terminal, B115200)) == -1)
    fehler_exit("Fehler beim Setzen von Ausgabe-Baudrate ...\n");
  if (tcsetattr (fd, TCSAFLUSH, &amp;terminal) == -1)
    fehler_exit ("Fehler bei tcsetattr ...\n");
  if (tcgetattr (fd, &amp;terminal) == -1)
    fehler_exit ("Fehler bei tcgetattr ...\n");
  if((baud_input=baudrate_wert(cfgetispeed(&amp;terminal))) == -1)
    fehler_exit ("Fehler bei baud_input ...\n");
  if((baud_output=baudrate_wert(cfgetospeed(&amp;terminal))) == -1)
    fehler_exit ("Fehler bei baud_output ...\n");
  printf ("Eingabe-Baudrate-neu : %d\n", baud_input);
  printf ("Ausgabe_Baudrate-neu : %d\n", baud_output);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o setbaud setbaud.c
$ ./setbaud /dev/tty
Eingabe-Baudrate : 38400
Ausgabe_Baudrate : 38400
Eingabe-Baudrate-neu : 115200
Ausgabe_Baudrate-neu : 115200</pre>
<p>Zum Thema Terminal E/A lie&szlig;e sich noch eine ganze Menge mehr verfassen. F&uuml;r den Fall, dass Sie mehr Informationen dazu ben&ouml;tigen, sei die Manual Page (man termios) empfohlen.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap12-008.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap13-001.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap13-000.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:56:52 GMT -->
</html>
