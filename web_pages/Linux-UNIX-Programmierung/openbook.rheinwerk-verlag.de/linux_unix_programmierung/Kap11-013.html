<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap11-013.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:57:48 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – 11.14 Syncrones Multiplexing – select()</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap11-012.html">
<link rel="next" href="Kap11-014.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap11-012.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap11-014.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="Kap11-000.html#RxxKap11000040003691F041100">11 Netzwerkprogrammierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-000.html#RxxKap11000040003691F041102">11.1 Einf&uuml;hrung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-001.html#RxxKap11001040003861F042100">11.2 Aufbau von Netzwerken</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-001.html#RxxKap11001040003861F042102">11.2.1 ISO/OSI und TCP/IP – Referenzmodell</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-001.html#RxxKap11001040003861F042117">11.2.2 Das World Wide Web (Internet)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-002.html#RxxKap11002040003871F03C100">11.3 TCP/IP – Aufbau und Struktur</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-002.html#RxxKap11002040003871F03C107">11.3.1 Netzwerkschicht (Daten&uuml;bertragung)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-002.html#RxxKap11002040003871F03C109">11.3.2 Internetschicht</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-002.html#RxxKap11002040003871F03C10B">11.3.3 Transportschicht (TCP, UDP)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-002.html#RxxKap11002040003871F03C10E">11.3.4 Anwendungsschicht</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-003.html#RxxKap11003040003881F040100">11.4 TCP Socket</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-004.html#RxxKap11004040003891F04F102">11.5 Kommunikationsmodell</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-005.html#RxxKap110050400038A1F01B100">11.6 Grundlegende Funktionen zum Zugriff auf die Socket-Schnittstelle</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B102">11.6.1 Ein Socket anlegen – socket()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B1A4">11.6.2 Verbindungsaufbau – connect()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B1BB">11.6.3 Socket mit einer Adresse verkn&uuml;pfen – bind()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B1C0">11.6.4 Auf Verbindungen warten – listen() und accept()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B1C8">11.6.5 Senden und Empfangen von Daten (1) – write() und read()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B1CC">11.6.6 Senden und Empfangen von Daten (2) – send() und recv()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-005.html#RxxKap110050400038A1F01B1D4">11.6.7 Verbindung schlie&szlig;en – close()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-006.html#RxxKap110060400038B1F02F100">11.7 Aufbau eines Clientprogramms</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-006.html#RxxKap110060400038B1F02F177">11.7.1 Zusammenfassung: Clientanwendung und Quellcode</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-007.html#RxxKap110070400038C1F03A100">11.8 Aufbau des Serverprogramms</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-007.html#RxxKap110070400038C1F03A107">11.8.1 Zusammenfassung: Serveranwendung und Quellcode</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-008.html#RxxKap110080400038D1F039100">11.9 IP-Adressen konvertieren, manipulieren und extrahieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-008.html#RxxKap110080400038D1F039102">11.9.1 inet_aton(), inet_pton() und inet_addr()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-008.html#RxxKap110080400038D1F03910E">11.9.2 inet_ntoa() und inet_ntop()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-008.html#RxxKap110080400038D1F039116">11.9.3 inet_network()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-008.html#RxxKap110080400038D1F039178">11.9.4 inet_netof()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-008.html#RxxKap110080400038D1F03917C">11.9.5 inet_lnaof()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-008.html#RxxKap110080400038D1F039180">11.9.6 inet_makeaddr()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-009.html#RxxKap110090400038E1F042100">11.10 Namen und IP-Adressen umwandeln</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-009.html#RxxKap110090400038E1F042108">11.10.1 Name-Server</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-009.html#RxxKap110090400038E1F04210A">11.10.2 Informationen zum Rechner im Netz – gethostbyname und gethostbyaddr</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-009.html#RxxKap110090400038E1F04219F">11.10.3 Service-Informationen – getservbyname() und getservbyport()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-010.html#RxxKap110100400038F1F02E100">11.11 Der Puffer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-011.html#RxxKap11011040003901F01F100">11.12 Standard-E/A-Funktionen verwenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-011.html#RxxKap11011040003901F01F10D">11.12.1 Pufferung von Standard-E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-012.html#RxxKap11012040003911F030100">11.13 Parallele Server</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap11013040003921F03B100">11.14 Syncrones Multiplexing – select()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-014.html#RxxKap11014040003931F044100">11.15 POSIX-Threads und Netzwerkprogrammierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-015.html#RxxKap11015040003941F043100">11.16 Optionen f&uuml;r Sockets setzen bzw. erfragen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-015.html#RxxKap11015040003941F043102">11.16.1 setsockopt()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-015.html#RxxKap11015040003941F043108">11.16.2 getsockopt()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-015.html#RxxKap11015040003941F04310D">11.16.3 Socket-Optionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-016.html#RxxKap11016040003951F04F100">11.17 UDP</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-016.html#RxxKap11016040003951F04F10C">11.17.1 Clientanwendung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-016.html#RxxKap11016040003951F04F112">11.17.2 Serveranwendung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-016.html#RxxKap11016040003951F04F114">11.17.3 recvfrom() und sendto()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-016.html#RxxKap11016040003951F04F17B">11.17.4 bind() verwenden oder weglassen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-017.html#RxxKap11017040003961F026100">11.18 UNIX-Domain-Sockets (IPC)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-017.html#RxxKap11017040003961F026105">11.18.1 Die Adressstruktur von UNIX-Domain-Sockets</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-017.html#RxxKap11017040003961F02610F">11.18.2 Lokale Sockets erzeugen – socketpair()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-018.html#RxxKap11018040003971F01A100">11.19 Multicast-Socket</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-018.html#RxxKap11018040003971F01A180">11.19.1 Anwendungsgebiete von Multicast-Verbindungen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-019.html#RxxKap11019040003981F017100">11.20 Nicht blockierende I/O-Sockets</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-020.html#RxxKap11020040003991F010100">11.21 Etwas zu Streams und TLI, Raw Socket, XTI</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-020.html#RxxKap11020040003991F010102">11.21.1 Raw Socket</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-020.html#RxxKap11020040003991F010106">11.21.2 TLI und XTI</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-020.html#RxxKap11020040003991F010109">11.21.3 RPC (Remote Procedure Call)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-021.html#RxxKap110210400039A1F048100">11.22 IPv4 und IPv6</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-021.html#RxxKap110210400039A1F048105">11.22.1 IPv6 – ein wenig genauer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-022.html#RxxKap110220400039B1F03D100">11.23 Netzwerksoftware nach IPv6 portieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-022.html#RxxKap110220400039B1F03D103">11.23.1 Konstanten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-022.html#RxxKap110220400039B1F03D107">11.23.2 Strukturen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap11-022.html#RxxKap110220400039B1F03D10B">11.23.3 Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap11-023.html#RxxKap110230400039C1F02F100">11.24 Sicherheit und Verschl&uuml;sselung</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">11.14 <a id="RxxKap11357SyncronesMultiplexingselect" name="RxxKap11357SyncronesMultiplexingselect"></a>Syncrones Multiplexing – select<a id="RxxKap11013040003921F03B100" name="RxxKap11013040003921F03B100"></a>() 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p><a id="Xxx999236" name="Xxx999236"></a><a id="Xxx999237" name="Xxx999237"></a>Bisher kennen Sie drei M&ouml;glichkeiten, Clients zu bearbeiten. Die »normale« Server-Client-L&ouml;sung, die f&uuml;r nur eine Clientanfrage ausgelegt ist, die Verwendung von mehreren Prozessen und die L&ouml;sung mit der Thread-Programmierung. Welche davon eignet sich allerdings am besten, wenn man mehrere Clients gleichzeitig bearbeiten will, wie dies z. B. bei einem Webserver, Chat-Programmen, einem Spieleserver usw. ben&ouml;tigt wird.</p>
<p>Die einfache Server-Client-L&ouml;sung, die nur f&uuml;r einen Client ausgelegt war, f&auml;llt schon mal flach, da alle anderen Clients, die eine Anfrage an den Server stellen, in eine Warteschlange gesteckt werden und warten m&uuml;ssen, bis der Server wieder f&uuml;r Verbindungsw&uuml;nsche frei ist.</p>
<p>Die Threads sind eine weitere interessante L&ouml;sung, allerdings, wenn hier das Thema »Portabilit&auml;t« ins Spiel kommt, schneiden auch die Threads relativ schlecht ab. Zwar gibt es f&uuml;r alle Plattformen Thread-Bibliotheken, nur sind diese leider nur bedingt portabel. Und in der Netzwerkprogrammierung ist das Thema »Portabilit&auml;t« schon ein gro&szlig; geschriebenes Thema.</p>
<p>Also w&auml;re die Verwendung von mehreren Prozessen (mittels <span class="listing">fork()</span>) eine interessante L&ouml;sung. Hierbei wird f&uuml;r jeden Client ein neuer (Server-)Prozess erzeugt und gestartet, jeder Client bekommt praktisch einen eigenen Server. Voraussetzung hierf&uuml;r ist allerdings, dass Sie sich mit der Systemprogrammierung der entsprechenden Plattform auskennen. Schlie&szlig;lich m&uuml;ssen die einzelnen Prozesse auch kontrolliert werden.</p>
<p>Nat&uuml;rlich gibt es hier nebenbei noch weitere M&ouml;glichkeiten, mehrere Clients zu behandeln. Allerdings sind dies immer wieder Dinge, die stark von der Plattform der Entwicklung abh&auml;ngen.</p>
<p>Und trotzdem gibt es eine L&ouml;sung, womit man auch mehrere Plattformen zufrieden stellen kann, n&auml;mlich die Funktion <span class="listing">select()</span>. Mit <span class="listing">select()</span> lassen sich recht komfortabel mehrere Clients behandeln - und das auch auf verschiedenen Plattformen wie MS Windows und Linux-/UNIX-Systemen. Also ein sehr geeigneter Kandidat f&uuml;r portable L&ouml;sungen.</p>
<p>Das Problem bei einem Server, wie Sie ihn bisher verwendet haben, ist, dass dieser immer nur auf einen Socket-Deskriptor gewartet hat und auch immer &uuml;ber einen Socket-Deskriptor Daten empfangen bzw. versendet wurden. Wurde beim Server z. B. <span class="listing">revc()</span> aufgerufen, blockierte dieser Aufruf den Socket-Deskriptor so lange, bis der Client wirklich Daten an diesen gesendet hat. Klar, man kann das Blockieren auch damit umgehen, indem man den Socket-Deskriptor als nicht blockierend einrichtet (z. mit <span class="listing">fcntl()</span>). Allerdings sollte man bedenken, dass hierbei st&auml;ndig &uuml;berpr&uuml;ft wird, ob an einem Socket Daten vorliegen – das hei&szlig;t, es wird in einer Schleife dauerhaft »gepollt« – was die CPU unn&ouml;tig belastet. Mit der Funktion <span class="listing">select()</span> k&ouml;nnen Sie den Socket-Deskriptor so einrichten, dass nur dann CPU-Zeit ben&ouml;tigt wird, wenn auch wirklich Daten an einem Socket-Deskriptor vorliegen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Dieser Abschnitt sollte nicht den Eindruck erwecken, die Funktion <span class="listing">select()</span> sei eine Routine, die sich nur zur Netzwerkprogrammierung eignet. <span class="listing">select()</span> kann &uuml;berall dort eingesetzt werden, wo auch Deskriptoren verwendet werden bzw. synchrones Multiplexing verwendet werden soll. Des Weiteren lassen sich mit <span class="listing">select()</span> auch hervorragend so genannte Timeouts einrichten. </p>
</td>
</tr>
</table><br>
<p><a id="Xxx999249" name="Xxx999249"></a><a id="Xxx999250" name="Xxx999250"></a>Hier also die Syntax zur entsprechenden <span class="listing">select()</span>-Funktion:</p>
<pre>/* entsprechend nach POSIX 1003.1–2001 */
#include &lt;sys/select.h&gt;
/* entsprechend nach fr&uuml;heren Standards */
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd. h.&gt;
int select( int n, fd_set *readfds, fd_set *writefds,
            fd_set *exceptfds, struct timeval *timeout );</pre>
<p>Mit dem ersten Parameter <span class="listing">n</span> geben Sie die Gr&ouml;&szlig;e der folgenden Menge an. Hierf&uuml;r wird gew&ouml;hnlich der Wert des h&ouml;chsten (Socket-)Deskriptors plus eins angegeben. Sie sollten sich allerdings nicht darauf verlassen, dass hier automatisch eine aufsteigende und l&uuml;ckenlose Reihenfolge f&uuml;r die (Socket-)Deskriptoren vergeben wird. Welche Nummer der n&auml;chste (Socket-)Deskriptor verwendet, entscheidet immer noch das System. Daher empfiehlt es sich, jeden gesetzten (Socket-)Deskriptor mit dem zu vergleichen, der rein theoretisch der h&ouml;chste ist.</p>
<p>Die n&auml;chsten drei Parameter sind Zeiger auf die <span class="listing">fd_sets</span>, die zum Lesen, Schreiben oder auf Ausnahmen getestet werden. Sofern Sie einen der Parameter nicht verwenden wollen, k&ouml;nnen Sie hierf&uuml;r <span class="listing">NULL</span> angeben. Drei getrennte Sets sind n&ouml;tig, da man ja nicht alle (Socket-)Deskriptoren auf Lesen oder Schreiben testen m&ouml;chte.</p>
<p>Der am h&auml;ufigsten verwendete Parameter (wie es auch im anschlie&szlig;enden Beispiel der Fall ist) ist <span class="listing">readfds</span>. Mit diesem Parameter wird &uuml;berpr&uuml;ft, ob auf den (Socket-)Deskriptoren Daten zum Lesen vorhanden sind. Das Gegenst&uuml;ck dazu ist der Parameter <span class="listing">writefds</span> – hiermit k&ouml;nnen Sie die Beschreibbarkeit von (Socket-)Deskriptoren &uuml;berpr&uuml;fen – sprich, ob ein Deskriptor bereit ist, eine Ausgabe anzunehmen (diese wird z. B. gerne bei Pipes verwendet). Der dritte <span class="listing">fd_set</span>-Parameter <span class="listing">exceptfds</span> wird weitaus seltener verwendet. Dieser kann verwendet werden, um zu &uuml;berpr&uuml;fen, ob bei einen (Socket-)Deskriptor irgendwelche besonderen Zust&auml;nde (Ausnahmen) vorliegen. Dies wird z. B. bei Out-of-band-Daten (<span class="listing">MSG_OOB</span>) verwendet (siehe Manual Page zu <span class="listing">send()</span> und/oder <span class="listing">recv()</span>).</p>
<p>Nach dem Aufruf von <span class="listing">select()</span> wird diese Menge in Teilmengen der Filedeskriptoren verteilt, welche die Bedingungen erf&uuml;llen.</p>
<p>Mit dem letzten Parameter k&ouml;nnen Sie ein Timeout, eine Zeit im Format von Sekunden (<span class="listing">tv_sec</span>) und Mikrosekunden (<span class="listing">tv_usec</span>), einrichten. Diese Zeit wird dann abgewartet, bis eine bestimmte Bedingung eintritt. Sind Sie daran nicht interessiert, k&ouml;nnen Sie auch hier <span class="listing">NULL</span> angeben. Es gibt aber auch einen Nachteil, wenn sich <span class="listing">select()</span> vorzeitig verabschiedet (vor Ablauf der festgelegten Zeit). <span class="listing">select()</span> gibt keine Auskunft dar&uuml;ber, wie lange denn tats&auml;chlich gewartet wurde. Dazu muss extra eine Funktion wie z. B. <span class="listing">gettimeofday()</span> aufgerufen werden.</p>
<p>Die Funktion gibt die Anzahl der Filedeskriptoren zur&uuml;ck, die Ihre Bedingung erf&uuml;llt haben (einfach die Anzahl der (Socket-)Deskriptoren, die bereit sind). Wenn die Zeit abgelaufen ist (Timeout), wird 0 und bei einem Fehler des Funktionsaufrufs <span class="listing">select()</span> -1 zur&uuml;ckgegeben.</p>
<p>Ein Problem bei <span class="listing">select()</span> ist, dass es mit Bitfeldern arbeitet – was somit abh&auml;ngig vom Betriebssystem ist. Die Bitfeldgr&ouml;&szlig;e bei BSD z. B. betr&auml;gt 256 und unter Linux 1024. Somit k&ouml;nnen auf BSD nur die ersten 256 und unter Linux 1024 Deskriptoren angesprochen werden. Wie viele Deskriptoren Sie denn nun tats&auml;chlich pro Prozess verwenden k&ouml;nnen, ist mit der symbolischen Konstante <span class="listing">FD_SETSIZE</span> definiert. Nat&uuml;rlich macht es jetzt wenig Sinn, alle (Socket-)Deskriptoren zu &uuml;berwachen. Zum Gl&uuml;ck m&uuml;ssen Sie sich eigentlich recht wenig um diese Menge k&uuml;mmern, da Ihnen der Datentyp <span class="listing">fd_set</span> die Arbeit zum Speichern der (Socket-)Deskriptoren abnimmt und einige Makros den Zugriff darauf erleichtern. Hier die Makros, um die Mengen zu bearbeiten:<a id="Xxx999260" name="Xxx999260"></a><a id="Xxx999261" name="Xxx999261"></a><a id="Xxx999262" name="Xxx999262"></a><a id="Xxx999263" name="Xxx999263"></a></p>
<pre>FD_ZERO(fd_set *set);
FD_SET(int element, fd_set *set);
FD_CLR(int element, fd_set *set);
FD_ISSET(int element, fd_set *set);</pre>
<p>Die Makros lassen sich recht schnell erkl&auml;ren. <span class="listing">FD_ZERO()</span> macht aus der Menge <span class="listing">set</span> eine leere Menge, <span class="listing">FD_SET()</span> f&uuml;gt <span class="listing">element</span> der Menge <span class="listing">set</span> hinzu, und <span class="listing">FD_CLR()</span> entfernt <span class="listing">element</span> aus der Menge <span class="listing">set</span>. Mit <span class="listing">FD_ISSET()</span> k&ouml;nnen Sie &uuml;berpr&uuml;fen, ob <span class="listing">element</span> in der Menge <span class="listing">set</span> vorkommt (genauer: gesetzt ist).</p>
<p>Das folgende Beispiel, ein einfacher TCP-Echo-Server, soll Ihnen die Funktion <span class="listing">select()</span> demonstrieren. Nach dem Starten des Servers d&uuml;rfen Sie gerne mehrere Clients gleichzeitig starten und dem Server Nachrichten zukommen lassen. Sie werden feststellen, dass der Server keinen Client blockiert und somit ohne Problem mehrere Clients »gleichzeitig« handeln kann (echtes Multiplexing eben) – genauer <span class="listing">FD_SETSIZE</span> Clients. Sobald auch hier ein Client die Zeichenfolge »quit« sendet, entfernt der Server den Client (genauer: den (Socket-)Deskriptor) aus der Menge. Die Netzwerkfunktionen um <span class="listing">select()</span> herum wurden in extra Funktionen »ausgelagert«, damit Sie den &Uuml;berblick zu den eigentlichen Funktionen rund um <span class="listing">select()</span> behalten k&ouml;nnen. Hierzu der Server »multi_server.c«:</p>
<pre>/* multi_server.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd. h.&gt;
#define BUF 1024
#define socket_t int
/* Funktion gibt aufgetretene Fehler aus und 
 * beendet die Anwendung */
void error_exit(char *error_message) {
    fprintf(stderr, "%s: %s\n", error_message,
       strerror(errno));
    exit(EXIT_FAILURE);
}
 int create_socket( int af, int type, int protocol ) {
    socket_t sock;
    const int y = 1;
    /* Erzeuge das Socket */
    sock = socket(af, type, protocol);
    if (sock &lt; 0)
        error_exit("Fehler beim Anlegen eines Sockets");
    setsockopt( sock, SOL_SOCKET,
                SO_REUSEADDR, &amp;y, sizeof(int));
    return sock;
}
/* Erzeugt die Bindung an die Serveradresse 
 * (genauer an einen bestimmten Port) */
void bind_socket(socket_t *sock, unsigned long adress,
                 unsigned short port) {
   struct sockaddr_in server;
   memset( &amp;server, 0, sizeof (server));
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = htonl(adress);
   server.sin_port = htons(port);
   if (bind( *sock, (struct sockaddr*)&amp;server,
             sizeof(server)) &lt; 0 )
       error_exit("Kann das Socket nicht \"binden\"");
}
/* Teile dem Socket mit, dass Verbindungsw&uuml;nsche
 * von Clients entgegengenommen werden */
void listen_socket( socket_t *sock ) {
  if(listen(*sock, 5) == -1 )
      error_exit("Fehler bei listen");
}
/* Bearbeite die Verbindungsw&uuml;nsche von Clients 
 * Der Aufruf von accept() blockiert so lange, 
 * bis ein Client Verbindung aufnimmt */
void accept_socket(socket_t *socket, socket_t *new_socket){
   struct sockaddr_in client;
   int len;
   
   len = sizeof(client);
   *new_socket = accept( *socket,(struct sockaddr *)&amp;client,
                         &amp;len );
   if (*new_socket  == -1) 
      error_exit("Fehler bei accept");
}
/* Daten empfangen via TCP */
void TCP_recv( socket_t *sock, char *data, size_t size) {
    int len;
    len = recv (*sock, data, size, 0);
    if( len &gt; 0 || len != -1 )
       data[len] = '\0';
    else
       error_exit("Fehler bei recv()");
}
/* Socket schlie&szlig;en */
void close_socket( socket_t *sock ){
    close(*sock);
}
 
int main (void) {
  socket_t sock1, sock2, sock3;
  int i, ready, sock_max, max=-1;
  int client_sock[FD_SETSIZE];
  fd_set gesamt_sock, lese_sock;
  char *buffer = (char*) malloc (BUF);
  sock_max = sock1 = create_socket(AF_INET, SOCK_STREAM, 0);
  bind_socket( &amp;sock1, INADDR_ANY, 15000 );
  listen_socket (&amp;sock1);
  
  for( i=0; i&lt;FD_SETSIZE; i++)
     client_sock[i] = -1;
  FD_ZERO(&amp;gesamt_sock);
  FD_SET(sock1, &amp;gesamt_sock);
  for (;;) {
    /* Immer aktualisieren */
    lese_sock = gesamt_sock;
    /* Hier wird auf die Ankunft von Daten oder
     * neuer Verbindungen von Clients gewartet */
    ready=select(sock_max+1, &amp;lese_sock, NULL, NULL, NULL);
    /* Eine neue Clientverbindung ... ? */
    if( FD_ISSET(sock1, &amp;lese_sock)) {
       accept_socket( &amp;sock1, &amp;sock2 );
       /* Freien Platz f&uuml;r (Socket-)Deskriptor 
        * in client_sock suchen und vergeben */
       for( i=0; i&lt; FD_SETSIZE; i++)
          if(client_sock[i] &lt; 0) {
             client_sock[i] = sock2;
             break;
          }
       /* Mehr als FD_SETSIZE Clients sind nicht m&ouml;glich */   
       if( i == FD_SETSIZE )
          error_exit("Server &uuml;berlastet – zu viele Clients");
       /* Den neuen (Socket-)Deskriptor zur
        * (Gesamt-)Menge hinzuf&uuml;gen */   
       FD_SET(sock2, &amp;gesamt_sock);
       /* select() ben&ouml;tigt die h&ouml;chste 
        * (Socket-)Deskriptor-Nummer */
       if( sock2 &gt; sock_max )
          sock_max = sock2;
       /* h&ouml;chster Index f&uuml;r client_sock
        * f&uuml;r die anschlie&szlig;ende Schleife ben&ouml;tigt */
       if( i &gt; max )
          max = i;
       /* ... weitere (Lese-)Deskriptoren bereit? */   
       if( --ready &lt;= 0 )
          continue; //Nein ...
    } //if(FD_ISSET ...
    
    /* Ab hier werden alle Verbindungen von Clients auf
     * die Ankunft von neuen Daten &uuml;berpr&uuml;ft */
    for(i=0; i&lt;=max; i++) {
       if((sock3 = client_sock[i]) &lt; 0)
          continue;
       /* (Socket-)Deskriptor gesetzt ... */   
       if(FD_ISSET(sock3, &amp;lese_sock)){
          /* ... dann die Daten lesen */
          TCP_recv (&amp;sock3, buffer, BUF-1);
          printf ("Nachricht empfangen: %s\n", buffer);
          /* Wenn quit erhalten wurde ... */
          if (strcmp (buffer, "quit\n") == 0) {
             /* ... hat sich der Client beendet */
             //Socket schlie&szlig;en
             close_socket (&amp;sock3);   
             //aus Menge l&ouml;schen
             FD_CLR(sock3, &amp;gesamt_sock);  
             client_sock[i] = -1;        //auf -1 setzen
             printf("Ein Client hat sich beendet\n");
          }
          /* Noch lesbare Deskriptoren vorhanden ... ? */
          if( --ready &lt;= 0 )
             break; //Nein ...
       }
    }
  } // for(;;)
  return EXIT_SUCCESS;
}</pre>
<p>Jetzt noch der Quellcode zum Client:</p>
<pre>/* client.c */ 
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd. h.&gt;
#define BUF 1024
#define socket_t int
/* Funktion gibt aufgetretene Fehler aus und 
 * beendet die Anwendung */
void error_exit(char *error_message) {
    fprintf(stderr, "%s: %s\n", error_message,
       strerror(errno));
    exit(EXIT_FAILURE);
}
 int create_socket( int af, int type, int protocol ) {
    socket_t sock;
    const int y = 1;
    /* Erzeuge das Socket */
    sock = socket(af, type, protocol);
    if (sock &lt; 0)
        error_exit("Fehler beim Anlegen eines Sockets");
    setsockopt( sock, SOL_SOCKET,
                SO_REUSEADDR, &amp;y, sizeof(int));
    return sock;
}
/* Baut die Verbindung zum Server auf */
void connect_socket(socket_t *sock, char *serv_addr,
                    unsigned short port) {
   struct sockaddr_in server;
   struct hostent *host_info;
   unsigned long addr;
   memset( &amp;server, 0, sizeof (server));
   if ((addr = inet_addr( serv_addr )) != INADDR_NONE) {
       /* argv[1] ist eine nummerische IP-Adresse */
       memcpy( (char *)&amp;server.sin_addr, 
               &amp;addr, sizeof(addr));
   }
   else {
      /* F&uuml;r den Fall der F&auml;lle: Wandle den Servernamen
       * z. B. "localhost" in eine IP-Adresse um */
       host_info = gethostbyname( serv_addr );
       if (NULL == host_info) 
           error_exit("Unbekannter Server"); 
       memcpy( (char *)&amp;server.sin_addr, host_info-&gt;h_addr,
               host_info-&gt;h_length);
   }
   server.sin_family = AF_INET;
   server.sin_port = htons( port );
   /* Baue die Verbindung zum Server auf */
   if (connect( *sock, (struct sockaddr *)&amp;server,
                sizeof( server)) &lt; 0)
      error_exit( "Kann keine Verbindung zum Server "
                  " herstellen");
}
/* Daten versenden via TCP */
void TCP_send( socket_t *sock, char *data, size_t size) {
   if(send( *sock, data, size, 0) == -1 )
      error_exit("Fehler bei send()");
}
/* Socket schlie&szlig;en */
void close_socket( socket_t *sock ){
    close(*sock);
}
int main (int argc, char **argv) {
  socket_t sock;
  char *buffer = (char *)malloc (BUF);
  if( argc &lt; 2 ){
     printf("Usage: %s ServerAdresse\n", *argv);
     exit(EXIT_FAILURE);
  }
  sock = create_socket(AF_INET, SOCK_STREAM, 0);
  connect_socket(&amp;sock, argv[1], 15000);
  do {
      buffer[0] = '\0';
      printf ("Nachricht zum Versenden: ");
      fgets (buffer, BUF, stdin);
      TCP_send (&amp;sock, buffer, strlen (buffer));
  } while (strcmp (buffer, "quit\n") != 0);
  close_socket (&amp;sock);
  return EXIT_SUCCESS;
}</pre>
<p>Die Programme bei der Ausf&uuml;hrung:</p>
<pre>[ tty1 ]
$ gcc -o multi_server multi_server.c
$ gcc -o client client.c
$ ./multi_server
[ tty2 ]
$ ./client localhost
Nachricht zum Versenden: Hallo Server von tty2
Nachricht zum Versenden:  
[ tty3 ]
$ ./client 127.0.0.1
Nachricht zum Versenden: Hallo Server von tty3
Nachricht zum Versenden:
[ tty1 ]
$ ./multi_server
Nachricht empfangen: Hallo Server von tty2
Nachricht empfangen: Hallo Server von tty3
[ tty2 ]
$ ./client localhost
Nachricht zum Versenden: Hallo Server von tty2
Nachricht zum Versenden: Ich beende mich jetzt dann
Nachricht zum Versenden: quit
$
[ tty3 ]
$ ./client 127.0.0.1
Nachricht zum Versenden: Hallo Server von tty3
Nachricht zum Versenden: Ich auch bye!
Nachricht zum Versenden: quit
$
[ tty1 ]
$ ./multi_server
Nachricht empfangen: Hallo Server von tty2
Nachricht empfangen: Hallo Server von tty3
Nachricht empfangen: Ich beende mich jetzt dann
Nachricht empfangen: quit
Ein Client hat sich beendet
Nachricht empfangen: Ich auch, bye!
Nachricht empfangen: quit
Ein Client hat sich beendet
...
...</pre>
<p>Zugegeben, das Beispiel war noch sehr theoretisch, daher ein Fall aus dem echten Leben der Netzwerkprogrammierung. Das beste Beispiel in diesem Fall d&uuml;rfte wohl ein HTTP-Webserver sein. Das folgende Listing zeigt Ihnen das Grundger&uuml;st eines solchen Webservers. Im Gro&szlig;en und Ganzen entspricht dieses auf den ersten Blick etwas komplexere Beispiel einem typischen Aufbau eines parallelen Servers, wie Sie diesen bereits in diesem Kapitel gesehen haben. Sie finden in diesem Beispiel viele netzwerktypische Techniken, weshalb es sich lohnen kann, sich umfassend damit zu besch&auml;ftigen. Der Quellcode ist, sofern dies n&ouml;tig ist, gut dokumentiert.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Sofern Sie mit Begriffen eines Webservers wie Request-Header oder Response-Header &uuml;berhaupt nichts anzufangen wissen, empfehle ich Ihnen das Kapitel zur CGI-Programmierung in C zu lesen, das Sie in dem Buch »C von A bis Z« finden (auch zu finden auf der Buch-CD).</p>
</td>
</tr>
</table><br>
<pre><a id="Xxx999277" name="Xxx999277"></a>/* http_server.c */
#include &lt;unistd. h.&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/ioctl.h&gt;
#define bool int
#define true  1
#define false 0
#define SERVER_PORT     2001
#define BUFFER_SIZE     2048
typedef void (*sighandler_t)(int);
static sighandler_t
my_signal(int sig_nr, sighandler_t signalhandler) {
   struct sigaction neu_sig, alt_sig;
   neu_sig.sa_handler = signalhandler;
   sigemptyset (&amp;neu_sig.sa_mask);
   neu_sig.sa_flags = SA_RESTART;
   if (sigaction (sig_nr, &amp;neu_sig, &amp;alt_sig) &lt; 0)
      return SIG_ERR;
   return alt_sig.sa_handler;
}
/* String anhand bestimmter Tokens zerlegen */
static int
GetToken(char *buf, int n, char *token, int toklen, char delim) {
  int len;
  int i = 0;
  int k;
  for( k=1; k&lt;=n;k++) {
    token[0] = 0;
    len = 0;
    while(buf[i] == delim || buf[i] == ' ' || buf[i] == 0 ||
          buf[i] == '\t' || buf[i] == '\r' || 
          buf[i] == '\n') {
      i++;
    }
    while(buf[i]!=delim &amp;&amp; buf[i]!=' ' &amp;&amp; buf[i]!='\0' &amp;&amp;
          buf[i]!='\t' &amp;&amp; buf[i]!=10 &amp;&amp; buf[i]!=13) {
      token[len++]  =  buf[i++];
      if(len &gt; toklen - 1) {
        return -1;
      }
    }
    token[len] = 0;
  }
  return len;
}
/* Ganze Bl&ouml;cke von size Bytes Gr&ouml;&szlig;e an den */
/* Socket (Client) senden                   */
static int SendBlock(int soc,unsigned char *buf, int size) {
  unsigned char *r;
  int len = 0;
  r = buf;
  while( size &gt; 0 ) {
    if((len = send(soc, r, size, 0)) == -1) {
      return -1;
    }
    size -= len;
    r += len;
  }
  return 0;
}
/* Variable Anzahl Bytes an Socket (den Client) schicken */
static int SendBuf(int soc, char *buf) {
  char *r = NULL;
  int len = 0;
  int rlen = strlen(buf);
  r = buf;
  while( rlen &gt; 0 ) {
    if((len = send(soc, r, strlen(r), 0)) == -1) {
      return -1;
    }
    rlen -= len;
    r += len;
  }
  return 0;
}
/* Den Response-Header an den Client senden; z. B.:
   HTTP/1.1 200 OK
   Date: Wed, 29 Jun 2004 00:38:10 GMT
   Server: Apache/2.0.12 (UNIX) PHP/5.0.3 mod_ssl/2.8.3 ...
   Last-Modified: Wed, 15 Jun 2004 12:53:23 GMT
   Content-Length: 3752
   Connection: close
   Content-Type: text/html
   ...
*/
static void
SendHTTPHeader( int soc, int code, const char *phase,
                int length, time_t *pftime ) {
  char msg[255] = {0};
  struct tm *ptm, *pftm;
  time_t stime;
  sprintf(msg, "HTTP/1.1 %d %s\r\n", code, phase);
  SendBuf(soc, msg);
  time(&amp;stime);
  ptm = gmtime(&amp;stime);
  strftime( msg, 255,
            "Date: %a, %d %b %Y %H:%M:%S %Z\r\n", ptm );
  SendBuf(soc, msg);
  SendBuf(soc, "Server: http_server 0.1\r\n");
  if(pftime != NULL) {
    pftm = gmtime(pftime);
    strftime( msg, 255, "Last-Modified: "
              "%a, %d %b %Y %H:%M:%S %Z\r\n", pftm);
    SendBuf(soc, msg);
  }
  SendBuf(soc, "Accept-Ranges: none\r\n");
  sprintf(msg, "Content-Length: %d\r\n", length);
  SendBuf(soc, msg);
  SendBuf(soc, "Connection: Keep-Alive\r\n");
  SendBuf(soc, "Content-Type: text/html\r\n");
  SendBuf(soc, "\r\n");
}
static int httpd(int soc) {
  int returnval = 0;
  char buf[512] ={0};
  char method[255] = {0};
  char uri[512] = {0};
  char headline[1024] = {0};
  char request_header[BUFFER_SIZE] = {0};
  char *r = NULL;
  char hTitle[32] = {0};
  char hValue[128] = {0};
  FILE *fd;
  bool isFirst = true;
  /* Aus Deskriptor einen FILE-Stream machen */
  fd = fdopen(soc, "r");
  printf("-----------Request-Header Client-------------\n");
  /* Request-Header des Clients auslesen */
  while(1) {    /* Request-Header zeilenweise einlesen */
    r = fgets(buf, BUFFER_SIZE, fd);
    /* ... Request-Header des Clients fertig, wenn ... */
    if( *r == '\r' &amp;&amp; *(r+1) == '\n') {
      break;
    }
    printf("ClientRequest: %s", r);
/* Als Erstes wird immer die Methode der Anfrage gesendet */
/* meistens ist die Methode GET oder POST                 */
/* Diese Methode wollen wir entsprechend mit GetToken()   */
/* pr&auml;pariert in dem char-Array method speichern.         */
    if(isFirst) {
      strcpy(headline, r);
      GetToken(headline, 1, method, 255, 0);
      isFirst = false;
    }
    /*  Keep-Alive? */
    else {
      strcat(request_header, r);
      GetToken(r, 1, hTitle, 32, ':');
      if(strcmp(hTitle, "Connection") == 0 ) {
        GetToken(r, 2, hValue, 128, ' ');
        if(strcmp(hValue, "Keep-Alive") == 0 ) {
          printf("Client ben&ouml;tigt keep alive\r\n");
          returnval = 1;
        } else {
          printf("Client ben&ouml;tigt kein keep alive\r\n");
          returnval = -1;
        }
      }
    }
  }
  printf("Fertig mit dem Lesen des Request-Headers...\r\n");
  printf("--------------------------------------------\n");
  fflush(stdout);
  /* Wurde die Methode GET gesendet - */
  /* Beispiel unterst&uuml;tzt nur diese   */
  if((strcmp(method,"GET")==0)||(strcmp(method,"get")==0)) {
    char dir[255];
    char path[512] = {0};
    FILE *file;
    struct stat fst;
    GetToken(headline, 2, uri, 1024, 0);
    GetToken(uri, 1, dir, 255, '/');
    printf("Folgende Datei wurde vom Client"
           " angefordert %s\n",uri);
    sprintf(path, ".%s", uri);
    file = fopen(path, "r");
    if(file == NULL) {
    /* Ausgabe an den Browser, falls Datei nicht vorhanden */
      char error404[] =
        "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;404 Not Found&lt;/TITLE&gt;"
        "&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;Nicht gefunden&lt;/H1&gt;"
        "Die angeforderte URL konnte nicht auf"
        " diesem Server gefunden werden."
        "&lt;P&gt;&lt;HR&gt;&lt;I&gt;http_server0.1&lt;I&gt;&lt;/BODY&gt;"
        "&lt;/HTML&gt;\r\n\r\n";
      printf("404 Nachricht\r\n");
      SendHTTPHeader( soc, 404, "FILE NOT FOUND.",
                      strlen(error404)+1, NULL );
      SendBlock( soc, error404, strlen(error404)+1 );
      fflush(stdout);
      SendBuf(soc, "\r\n\r\n");
      return -1;
    } else {
      /* Server-Response erzeugen-Die Antwort des Servers */
      unsigned char *blob = NULL;
      stat(path, &amp;fst);
      printf("Datei existiert ...\r\n");
      fflush(stdout);
      /* Den Response-Header an den Client schicken */
      SendHTTPHeader( soc, 200, "OK", fst.st_size,
                      &amp;(fst.st_mtime) );
      /* Speicher f&uuml;r d. angeforderte Dokument anfordern */
      blob = (unsigned char *)malloc(fst.st_size);
      /* Komplettes Dokument in blob einlesen */
      fread(blob, fst.st_size, 1, file);
      /* Komplettes Dokument an den Client senden */
      SendBlock(soc, blob, fst.st_size);
      /* ...fertig - aufr&auml;umen */
      fclose(file);
      printf("Alle Daten gesendet ...\r\n");
      fflush(stdout);
      SendBuf(soc, "\r\n\r\n");
      free(blob);
    }
  }
  return returnval;
}
int main(int argc, char *argv[]) {
  int soc, soc_cli;
  socklen_t srv_len, cli_len;
  int ret = -1;
  struct sockaddr_in srv_addr, cli_addr;
  const int y = 1;
  /* 1. Typischer Vorgang einer Serveranwendung:    */
  /*    +   Einen Socket erzeugen - socket()        */
  /*    + Den eigenen Port festlegen - bind()       */
  /*    + Auf Verbindungsw&uuml;nsche warten - listen()  */
  /*    + Verbindung annehmen - accept()            */
  soc = socket(AF_INET, SOCK_STREAM, 0);
  srv_addr.sin_family = AF_INET;
  srv_addr.sin_addr.s_addr = htons(INADDR_ANY);
  srv_addr.sin_port = htons(SERVER_PORT);
  srv_len = sizeof(srv_addr);
  setsockopt( soc, SOL_SOCKET, SO_REUSEADDR,
              &amp;y, sizeof(int));
  ret = bind(soc, (struct sockaddr *)&amp;srv_addr, srv_len);
  if(ret != 0) {
    printf("Fehler: binding server socket\r\n");
    return EXIT_FAILURE;
  }
  ret = listen(soc, 5);
  if(ret != 0) {
    printf("Fehler: listening server socket\r\n");
    return EXIT_FAILURE;
  }
  /* SIGCHLD ignorieren */
  my_signal(SIGCHLD, SIG_IGN);
  while(1) {
    int pid;
    fd_set fdlist, testfd;
    int result = 0;
    int rlen = 0;
    printf("Warte auf Clientverbindung...\r\n");
    cli_len = sizeof(cli_addr);
    soc_cli = accept( soc,
                      (struct sockaddr *)&amp;cli_addr,
                      (socklen_t*)&amp;cli_len );
    /* Parallelen Server erzeugen */
    pid = fork();
    switch(pid) {
      /* Kindprozess k&uuml;mmert sich um den neuen Client */
      /* (z. B. Browser)                              */
    case 0:
      if(soc_cli != -1) {
        printf("Client verbunden mit socket %d\r\n",
           soc_cli);
        /* Menge in fdlist auf null setzen */
        FD_ZERO(&amp;fdlist);
        /* Den Client-Socket der Menge hinzuf&uuml;gen */
        FD_SET(soc_cli, &amp;fdlist);
        while(1) {
          testfd = fdlist;
          /* Sind auf der Deskriptor(en)-Menge */
          /* testfd Daten zum Lesen vorhanden? */
          result = select( FD_SETSIZE, &amp;testfd,
                           NULL, NULL, NULL );
          /* Fehler bei select() */
          if(result &lt;= 0) {
            break;
          }
          /* Pr&uuml;fen, ob das Bit f&uuml;r soc_cli in */
          /* testfd gesetzt ist ...           */
          if(FD_ISSET(soc_cli, &amp;testfd)) {
            ioctl(soc_cli, FIONREAD, &amp;rlen);
            if(rlen == 0) {
              /* Bit f&uuml;r soc_cli aus der Menge */
              /* fdlist wieder l&ouml;schen         */
              FD_CLR(soc_cli, &amp;fdlist);
              break;
            }
            /* Die Anforderung des Clients */
            /* bearbeiten                  */
            result = httpd(soc_cli);
            if(result &lt; 0) {
              break;
            }
          }
        }
        printf("Client socket %d beendet\r\n", soc_cli);
        fflush(stdout);
        close(soc_cli);
      } else {
        printf("Fehler:accepting client's connection.\r\n");
      }
      exit(EXIT_SUCCESS);
      break;
    case -1:
      printf("Fehler bei fork() (%s)\r\n", strerror(errno));
      break;
    default:
      /* Elternprozess ben&ouml;tigt den verbundenen Socket */
      /* nicht mehr, da sich der Kindprozess damit    */
      /* besch&auml;ftigt                                 */
      close(soc_cli);
      break;
    }
  }
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o http_server http_server.c</pre>
<p>Erstellen Sie nun eine HTML-Datei. Speichern Sie diese Datei im selben Verzeichnis, in dem Ihr Webserver ausgef&uuml;hrt wird. Hier wird die Datei mit dem Namen index.html gespeichert.</p>
<pre>$ ./http_server
Waiting for client connecting...</pre>
<p>&Ouml;ffnen Sie jetzt einen Webclient (Ihren Lieblings-Webbrowser, wenn Sie wollen), und geben Sie folgende Adresse ein:</p>
<pre>http://localhost:2001/index.html</pre>
<p>Jetzt m&uuml;ssten Sie den Inhalt der Datei index.html in Ihrem Browser lesen k&ouml;nnen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/11_10.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein11_10.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 11.10   
    </b>Erfolgreich mit dem http_server verbunden</p>
</td>
</tr>
</table><br>
<p>F&uuml;r den Fall, dass Sie eine nicht vorhandene Datei anfordern, wird die servertypische 404-Nachricht (File not found) zur&uuml;ckgegeben.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext">
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/11_11.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein11_11.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 11.11   
    </b>Ein nicht vorhandenes Dokument wurde angefordert.</p>
</td>
</tr>
</table><br>
<p>Au&szlig;erdem k&ouml;nnen Sie die Ausgabe Ihres Webservers bei der Arbeit in der Konsole betrachten:</p>
<pre>$ ./http_server
Warte auf Clientverbindung...
Client verbunden mit socket 4
-------------Request-Header Client---------------
ClientRequest: GET /index.html HTTP/1.1
ClientRequest: Host: localhost:2001
ClientRequest: User-Agent: Mozilla/5.0 (X11; U; Linux i686;
ClientRequest: Accept:text/xml,application/xml,appl ...
ClientRequest: Accept-Encoding: gzip,deflate, compress ...
ClientRequest: Accept-Charset: ISO-8859–1, utf-8;q=0.66, ...
ClientRequest: Keep-Alive: 300
ClientRequest: Connection: keep-alive
Client ben&ouml;tigt kein keep alive
ClientRequest: If-Modified-Since: Sat, 08 May 2004 23:23:26 
ClientRequest: Cache-Control: max-age=0
Fertig mit dem Lesen des Request-Headers...
------------------------------------------------
Folgende Datei wurde vom Client angefordert /index.html
Datei existiert ...
Alle Daten gesendet ...
Client-socket-4-Verbindung beendet
Warte auf Client-Verbindung ...
Client verbunden mit socket 4
Warte auf Clientverbindung ...
-------------Request-Header Client---------------
ClientRequest: GET /icnzgtfhjkldex.html HTTP/1.1
ClientRequest: Connection: Keep-Alive
Client ben&ouml;tigt keep alive
ClientRequest: Pragma: no-cache
ClientRequest: Cache-control: no-cache
ClientRequest: Accept: text/*, image/jpeg, image/png, image/...
ClientRequest: Accept-Encoding: x-gzip, x-deflate, gzip, defla...
ClientRequest: Accept-Charset: iso-8859–15, utf-8;q=0.5, *;q=0.5
ClientRequest: Accept-Language: de, DE, en
ClientRequest: Host: localhost:2001
Fertig mit dem Lesen des Request-Headers ...
------------------------------------------------
Folgende Datei wurde vom Client angefordert /icnzgtfhjkldex.html
404 Nachricht
Client-socket-4-Verbindung beendet</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Keep Alive<a id="Xxx999305" name="Xxx999305"></a></b>   Bei HTTP/1.0 waren alle Verbindungen nicht persistent, d. h., der Server hat die Verbindung zum Client (z. B. nach dem Liefern einer HTML-Datei) abgebrochen. Wenn der Client eine persistente Verbindung aufbauen wollte, musste dieser den Connection-Header mit Keep Alive best&uuml;cken. In HTTP/1.1 ist dies jetzt umgekehrt der Fall. Die Verbindungen sind hierbei immer persistent, au&szlig;er der Client schickt einen Connection-Header mit close.</p>
</td>
</tr>
</table><br>
<p>Eine Zeile, in der Sie sicherlich h&auml;ngen geblieben sind, war wohl die folgende Zeile:</p>
<pre>ioctl(soc_cli, FIONREAD, &amp;rlen);</pre>
<p>Damit l&auml;sst sich ganz bequem herausfinden, wie viele ungelesene Bytes in einem Filedeskriptor (hier Socket) noch verf&uuml;gbar sind. Die Anzahl befindet sich anschlie&szlig;end in <span class="listing">rlen</span>. Im Beispiel wird, wenn keine Bytes mehr verf&uuml;gbar sind, der Filedeskriptor (hier Socket) aus der Menge <span class="listing">fdlist</span> mit dem Makro <span class="listing">FD_CLR()</span> wieder entfernt.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis zu \r\n   </b>Sicherlich ist Ihnen im Listing bei den Ausgaben des Servers auch das \r\n am Ende aufgefallen. Im Prinzip ist es allerdings egal, ob Sie hierbei \n oder \r\n verwenden – vorausgesetzt nat&uuml;rlich, die Clientsoftware spricht dasselbe Protokoll wie der Server. Gew&ouml;hnlich werden Serverd&auml;monen so programmiert, dass diese \r\n und  \n kennen.</p>
</td>
</tr>
</table><br>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap11-012.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap11-014.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap11-013.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:57:52 GMT -->
</html>
