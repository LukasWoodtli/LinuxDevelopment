<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap15-002.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:46:13 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – 15.3 Eine Einf&uuml;hrung in die Glib-Bibliothek</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap15-001.html">
<link rel="next" href="Kap15-003.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap15-001.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap15-003.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="Kap15-000.html#RxxKap15000040005211F024100">15 GTK+</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-000.html#RxxKap15000040005211F024102">15.1 Was ist GTK+?</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-000.html#RxxKap15000040005211F024108">15.1.1 Was sind GDK und Glib?</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-000.html#RxxKap15000040005211F02410E">15.1.2 Schnittstellen von GTK+ zu anderen Programmiersprachen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-000.html#RxxKap15000040005211F024110">15.1.3 GTK+ und GNOME</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-000.html#RxxKap15000040005211F024115">15.1.4 GTK+ Version 1.2 und 2.x</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-000.html#RxxKap15000040005211F024175">15.1.5 GTK+-Aufbau des Kapitels</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-001.html#RxxKap150010400053E1F049100">15.2 GTK+-Anwendungen &uuml;bersetzen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap150020400053F1F013100">15.3 Eine Einf&uuml;hrung in die Glib-Bibliothek</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F013103">15.3.1 Datentypen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F013187">15.3.2 Routinen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F013195">15.3.3 Assertions-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F0131A4">15.3.4 Speicherverwaltung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F0131D6">15.3.5 Stringbearbeitung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F013201">15.3.6 Selbstverwaltender Stringpuffer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F013218">15.3.7 Timer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F01322F">15.3.8 Dynamische Arrays</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F013243">15.3.9 Listen, Hashtabellen und bin&auml;re B&auml;ume</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap150020400053F1F01324A">15.3.10 Ausblick Glib</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-003.html#RxxKap15003040005401F028100">15.4 Grundlagen der GTK+-Programmierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F028109">15.4.1 Die Umgebung initialisieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F02810F">15.4.2 Widgets erzeugen und ggf. die Attribute setzen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F02817C">15.4.3 Eine Callback-Funktion einrichten, um Events abzufangen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F028190">15.4.4 Eine GTK+-Anwendung beenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F02819D">15.4.5 Die hierarchische Anordnung der Widgets definieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F0281A8">15.4.6 Widgets anzeigen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F0281B0">15.4.7 Signale und Events abfangen und bearbeiten – (Events-)Verarbeitungsschleife</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-003.html#RxxKap15003040005401F0281B9">15.4.8 GTK+ und Umlaute (Zeichenkodierung)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-004.html#RxxKap15004040005411F03E100">15.5 Fenster – GtkWindow</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-004.html#RxxKap15004040005411F03E19A">15.5.1 Dialogfenster (Dialogboxen)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-004.html#RxxKap15004040005411F03E1BB">15.5.2 GtkMessageDialog</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-005.html#RxxKap15005040005421F03D100">15.6 Anzeige-Elemente</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-005.html#RxxKap15005040005421F03D10A">15.6.1 Text – GtkLabel</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-005.html#RxxKap15005040005421F03D194">15.6.2 Trennlinie – GtkSeparator</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-005.html#RxxKap15005040005421F03D196">15.6.3 Grafiken – GtkImage</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-005.html#RxxKap15005040005421F03D19A">15.6.4 Statusleiste – GtkStatusbar</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-005.html#RxxKap15005040005421F03D1A1">15.6.5 Fortschrittsbalken – GtkProgressBar</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-006.html#RxxKap15006040005431F023100">15.7 Beh&auml;lter</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-006.html#RxxKap15006040005431F023102">15.7.1 Boxen – GtkBox</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-006.html#RxxKap15006040005431F02317A">15.7.2 Aufteilungen, Register und Button-Box</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-006.html#RxxKap15006040005431F0231CB">15.7.3 Tabellen – GtkTable</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-006.html#RxxKap15006040005431F0231F6">15.7.4 Ausrichtung – GtkAlignment</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-007.html#RxxKap15007040005441F037100">15.8 Buttons und Toogled-Buttons</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-007.html#RxxKap15007040005441F03710A">15.8.1 Buttons allgemein</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-007.html#RxxKap15007040005441F03717A">15.8.2 Radio-Buttons (GtkRadioButton)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-007.html#RxxKap15007040005441F037182">15.8.3 GtkRadioButton, GtkCheckButton und GtkToggleButton</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-007.html#RxxKap15007040005441F037191">15.8.4 Signale f&uuml;r Buttons (GtkButton)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-008.html#RxxKap15008040005451F023100">15.9 Dateneingabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-008.html#RxxKap15008040005451F02310A">15.9.1 Textfelder – GtkEntry</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-008.html#RxxKap15008040005451F0231A0">15.9.2 Schieberegler – GtkScale</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-008.html#RxxKap15008040005451F0231C1">15.9.3 Zahlenfelder – GtkSpinButton</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-008.html#RxxKap15008040005451F0231E0">15.9.4 Einstellungen – GtkAdjustment</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-008.html#RxxKap15008040005451F0231F1">15.9.5 GtkEditable</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-009.html#RxxKap15009040005461F035100">15.10 Men&uuml; und Toolbar</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-009.html#RxxKap15009040005461F03510A">15.10.1 Men&uuml; – GtkItemFactory</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-009.html#RxxKap15009040005461F0351C3">15.10.2 Toolbar – GtkToolbar</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-009.html#RxxKap15009040005461F0351F0">15.10.3 Options-Men&uuml; – GtkOptionsMenu</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-009.html#RxxKap15009040005461F0351FA">15.10.4 Combo-Boxen – GtkCombo</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-010.html#RxxKap15010040005471F030100">15.11 Mehrzeiliger Text</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-010.html#RxxKap15010040005471F030111">15.11.1 Text(editor) – GtkTextView, GtkTextBuffer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-010.html#RxxKap15010040005471F0301D9">15.11.2 Scrollendes Fenster – GtkScrolledWindow</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-011.html#RxxKap15011040005481F04B100">15.12 Ausw&auml;hlen (Selection)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap15-011.html#RxxKap15011040005481F04B10D">15.12.1 Dateiauswahl – GtkFileSelection</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-012.html#RxxKap15012040005491F04C100">15.13 Events</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap15-013.html#RxxKap150130400054A1F03E100">15.14 Weitere Widget- und GTK+-Elemente im &Uuml;berblick</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">15.3 <a id="RxxKap1544EineEinfuhrungindieGlibBibliothek" name="RxxKap1544EineEinfuhrungindieGlibBibliothek"></a>Eine Einf&uuml;hrung in die Glib-Biblioth<a id="RxxKap150020400053F1F013100" name="RxxKap150020400053F1F013100"></a>ek 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p><a id="Xxx999236" name="Xxx999236"></a>GTK+ und GDK sind f&uuml;r die grafische Seite einer Anwendung verantwortlich, und Glib ist die nicht sichtbare Schnittstelle f&uuml;r den Anwender. Alles, was hinter den grafischen Kulissen so passiert, wird gew&ouml;hnlich &uuml;ber die Glib gemacht. Diese Bibliothek beinhaltet Funktionen f&uuml;r die Speicherverwaltung, Stringmanipulationen, verkettete Listen, Arrays, B&auml;umen und eine Menge mehr. Nat&uuml;rlich finden Sie im Buch nur wieder einen kleinen Einblick in die Glib-Welt, was aber f&uuml;r die weitere Verwendung mithilfe der Dokumentation zur Glib v&ouml;llig ausreichen sollte. Trotzdem kommen Sie, sofern Ihre Programme GTK+- oder GNOME-Bibliotheken verwenden werden, nicht um das Erlernen der Glib herum. Um Glib zu verwenden, m&uuml;ssen Sie die Headerdatei <span class="listing">glib.h<a id="Xxx999238" name="Xxx999238"></a></span> in die Programme mit einbinden. Es kann au&szlig;erdem sein, wenn Sie eine Anwendung mit GTK+ oder GNOME schreiben, dass die Glib-Bibliothek ben&ouml;tigt wird, obwohl Sie keine dieser Funktionen in der Anwendung verwendet haben.</p>
<p>F&uuml;r Funktionen der Glib wurde folgende Schreibweise festgelegt: Alle Glib-Funktionen beginnen mit dem Pr&auml;fix <span class="listing">g_</span> – die Datentypen mit dem Pr&auml;fix <span class="listing">g</span> (ohne Unterstrich) –, und Makros werden meist beginnend mit einem gro&szlig;en <span class="listing">G</span> oder <span class="listing">GLIB</span> gekennzeichnet.</p>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t32"></a><h3 class="t3">15.3.1 Datentypen<a id="RxxKap150020400053F1F013103" name="RxxKap150020400053F1F013103"></a> 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999241" name="Xxx999241"></a>Jeder, der schon einmal Software auf ein anderes System portieren musste, wei&szlig;, wie das enden kann. Sp&auml;testens wenn auf dem einen System eine vorzeichenlose 16-Bit-Ganzzahl deklariert ist, lernt man beim Portieren die andere Seite von C wieder kennen. Um die richtige Darstellung von Datentypen k&uuml;mmert sich die Glib f&uuml;r Sie. Somit w&auml;re das Problem schon weg. Folgende Datentypen und deren Gegenst&uuml;ck (falls vorhanden) in Standard-C sind in der Headerdatei <span class="listing">glib.h</span> definiert:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 15.1   
    </b>Datentypen der Glib-Bibliothek</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Glib-Datentyp</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Standard-C-Datentyp</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gchar
</td>
<td class="tabellentext" bgcolor="#000000">char
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">guchar
</td>
<td class="tabellentext" bgcolor="#000000">unsigned char
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gint
</td>
<td class="tabellentext" bgcolor="#000000">int
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">guint
</td>
<td class="tabellentext" bgcolor="#000000">unsigned int
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gshort
</td>
<td class="tabellentext" bgcolor="#000000">short
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gushort
</td>
<td class="tabellentext" bgcolor="#000000">unsigned short
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">glong
</td>
<td class="tabellentext" bgcolor="#000000">long
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gulong
</td>
<td class="tabellentext" bgcolor="#000000">unsigned long
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gfloat 
</td>
<td class="tabellentext" bgcolor="#000000">float
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gdouble
</td>
<td class="tabellentext" bgcolor="#000000">double
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gintN
</td>
<td class="tabellentext" bgcolor="#000000">int mit genau n Bit Breite
(m&ouml;glicher Wert f&uuml;r n = 8, 16, 32, 64)
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gpointer
</td>
<td class="tabellentext" bgcolor="#000000">void *, typloser Zeiger
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gconstpointer
</td>
<td class="tabellentext" bgcolor="#000000">const void *, konstanter typloser Zeiger
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gboolean
</td>
<td class="tabellentext" bgcolor="#000000">Wahrheitswert, entweder TRUE oder FALSE
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">gsize und gssize
</td>
<td class="tabellentext" bgcolor="#000000">signed und unsigned Werte, welche die Gr&ouml;&szlig;e einer Datenstruktur repr&auml;sentieren
</td>
</tr>
</table><br>
<p>Die Datentypen <span class="listing">gboolean</span>, <span class="listing">gsize</span> und <span class="listing">gssize</span> sind keinen Standarddatentypen von C. Die 8-, 16-, 32- und 64-Bit-Integer (<span class="listing">gintN</span>) sind sehr sinnvoll, wenn garantiert werden muss, dass ein Integer eine bestimmte Bitl&auml;nge haben muss. Da nicht auf jedem System eine Darstellung von 64-Bit-Werten m&ouml;glich ist, m&uuml;ssen Sie bei Verwendung eines solchen Typs erst die symbolische Konstante <span class="listing">G_HAVE_GINT64</span> &uuml;berpr&uuml;fen, ob diese gesetzt ist.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Es ist auch m&ouml;glich und somit nicht falsch, wenn Sie bei einer auf Glib basierenden Anwendung die Datentypen mit denen der Standard-C-Funktionen vermischen. Sinnvoll ist dies aber nicht.</p>
</td>
</tr>
</table><br>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t33"></a><h3 class="t3">15.3.2 Routinen<a id="RxxKap150020400053F1F013187" name="RxxKap150020400053F1F013187"></a> 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>F&uuml;r den t&auml;glichen Gebrauch finden Sie in der Glib eine Menge Routinen, die meistens sicherere Wrapper-Funktionen zu den Standardfunktionen von C sind. Aufgeteilt werden diese Funktionen in Hilfsfunktionen und Funktionen zur Manipulation von Datenstrukturen. Zuerst werden die einfachen Hilfsfunktionen beschrieben.</p>
<h4 class="t4">Ausgabe von Fehlern und anderen Nachrichten</h4>
<p><a id="Xxx999324" name="Xxx999324"></a>Die h&auml;ufigste Methode, um ein Programm zu debuggen bzw. eine Meldung auszugeben, ist die, eine Nachricht auf die Konsole oder in eine Datei zu schreiben. Die Glib hat hierf&uuml;r zum Gl&uuml;ck mehrere M&ouml;glichkeiten zur Verf&uuml;gung.</p>
<p>Die wohl einfachste und am h&auml;ufigsten verwendete Methode d&uuml;rften wohl die Funktionen <span class="listing">g_print()<a id="Xxx999327" name="Xxx999327"></a></span> und <span class="listing">g_printerr()<a id="Xxx999328" name="Xxx999328"></a></span> sein:</p>
<pre>void g_print(const gchar *format, ...);
void g_printerr(const gchar *format, ...);</pre>
<p>Die Funktion <span class="listing">g_print()</span> ist als Ersatz f&uuml;r die Standardfunktion <span class="listing">printf()</span> zu sehen. Mit <span class="listing">g_print()</span> wird der formatierte, variabel lange Textstring auf die Standardausgabe (<span class="listing">stdout</span>) ausgegeben (sofern diese nicht umgeleitet wurde). Die Funktion <span class="listing">g_printerr()</span> hingegen schreibt die Ausgabe auf die Standardfehlerausgabe (bekannt als <span class="listing">stderr</span>). Sicherlich stellen Sie sich hierbei die Frage, warum sollten Sie jetzt diese beiden Funktionen im Gegensatz zu <span class="listing">printf()</span> und <span class="listing">fprintf()</span> verwenden? Der Grund ist simpel und einfach. Mit den beiden Funktionen k&ouml;nnen Sie noch zus&auml;tzlich einen Handler einrichten. Mit diesem Handler wiederum k&ouml;nnen Sie die Ausgabe in eine Datei umleiten, in ein GTK+-Widget oder in ein anderes Programm. Um allerdings die Standardausgabe der beiden Funktionen (<span class="listing">g_print()</span> und <span class="listing">g_printerr()</span>) zu ver&auml;ndern, m&uuml;ssen Sie die entsprechenden Funktionen <span class="listing">g_set_print_handler()<a id="Xxx999331" name="Xxx999331"></a></span> bzw. <span class="listing">g_set_printerr_handler()<a id="Xxx999332" name="Xxx999332"></a></span> verwenden. Jede der beiden Funktionen erh&auml;lt einen Zeiger auf eine selbst geschriebene Funktion, die als Argument einen String erwartet. Mehr dazu entnehmen Sie bei Bedarf bitte der Dokumentation.</p>
<p>Weitere Funktionen, die meistens noch einen Zusatz zum eigentlichen Formatstring ausgeben, sind:<a id="Xxx999334" name="Xxx999334"></a><a id="Xxx999335" name="Xxx999335"></a><a id="Xxx999336" name="Xxx999336"></a><a id="Xxx999337" name="Xxx999337"></a></p>
<pre>void g_message(const gchar *format, ...);
void g_warning(const gchar *format, ...);
void g_error(const gchar *format, ...);
const gchar *g_strerror(gint errnum); </pre>
<p>Die Funktionen <span class="listing">g_message()</span> und <span class="listing">g_warning()</span> sind der Funktion <span class="listing">g_print()</span> recht &auml;hnlich. Mit <span class="listing">g_message()</span> wird vor dem String die Zeichenfolge <span class="listing">Message:</span> ausgegeben, und bei <span class="listing">g_warning()</span> wird die Textfolge <span class="listing">***</span> <span class="listing">(process:1234)</span> <span class="listing">WARNING</span> <span class="listing">***</span> dem eigentlichen String vorangestellt. Die Funktion <span class="listing">g_error()</span> hingegen setzt vor den Formatstring noch den String <span class="listing">***</span> <span class="listing">ERROR</span> <span class="listing">***</span> und beendet anschlie&szlig;end mit dem Signal <span class="listing">SIGABRT</span> das Programm. <span class="listing">g_strerror()</span> erwartet als Parameter die Fehlervariable <span class="listing">errno</span> und gibt einen dementsprechenden String aus, wof&uuml;r der Fehlercode der Ganzzahl steht. Diese Funktion ist das Pendant zur Funktion <span class="listing">perror()</span>. Es wird empfohlen, diese Funktionen immer bei der Ausgabe von Fehlermeldungen zu verwenden.</p>
<p>Hierzu folgt ein einfaches Listing, das die eben vorgestellten Funktionen in der Praxis zeigt.</p>
<pre><a id="Xxx999341" name="Xxx999341"></a>/* glib1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;gtk/gtk.h&gt;
int main(void) {
   FILE *f1;
   const gchar *text = "Ausgabe mit g_message";
   
   g_print("Ausgabe mit g_print\n");
   g_printerr("Ausgabe mit g_printerr\n");
   g_message("%s\n",text);
   g_warning("Ausgabe mit g_warning\n");
   f1 = fopen("abcd", "r");
   if( f1 == NULL ) {
      printf("Fehler : %s\n", g_strerror(errno));
   }   
   g_error("Ausgabe mit g_error (FATALER FEHLER - Ende)\n");
   return EXIT_SUCCESS;   
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib1 glib1.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib1
Ausgabe mit g_print
Ausgabe mit g_printerr
** Message: Ausgabe mit g_message
** (process:2272): WARNING **: Ausgabe mit g_warning
Fehler : No such file or directory
** ERROR **: Ausgabe mit g_error (FATALER FEHLER - Ende)
aborting...
Abgebrochen</pre>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t34"></a><h3 class="t3">15.3.3 Assertions-Funktionen<a id="RxxKap150020400053F1F013195" name="RxxKap150020400053F1F013195"></a> 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999346" name="Xxx999346"></a>Nat&uuml;rlich gibt es bei der Glib auch eine <span class="listing">assert()</span>-Version mit <span class="listing">g_assert()</span>, wobei hier die Funktion <span class="listing">g_assert()</span> voll und ganz der Funktion von <span class="listing">assert()</span> entspricht, z. B.:<a id="Xxx999348" name="Xxx999348"></a></p>
<pre>int x=5, y=4, z=3;
g_assert( x &gt; y );  /* OK */
g_assert( x &gt; z );  /* OK */
g_assert( z &gt; y );  /* Fehler !!! */</pre>
<p>Folgende Fehlermeldung wird dabei ausgegeben:</p>
<pre>** ERROR **:
file glibx.c: line xx (main): assertion failed: (z &gt; y)
aborting...
Abgebrochen</pre>
<p>In Standard-C mussten Sie <span class="listing">assert()</span> mit einem Flag im Programmcode au&szlig;er Kraft setzen. Glib macht es Ihnen dabei noch einfacher, indem Sie beim &Uuml;bersetzen das Flag <span class="listing">-DG_DISABLE_ASSERT</span> verwenden:</p>
<pre>$ gcc -o -DG_DISABLE_ASSERT glibx glibx.c \
  `pkg-config --libs --cflags gtk+-2.0`</pre>
<p>Die Glib stellt Ihnen au&szlig;erdem mit <span class="listing">g_assert_not_reached()</span> noch ein anderes Assert ohne Argumente zur Verf&uuml;gung. Dieses kann z. B. verwendet werden, wenn eine Situation eintrifft, die einfach niemals h&auml;tte eintreffen sollen/k&ouml;nnen. not reached eignet sich in der Regel nur f&uuml;r die Fehlersuche, z. B.</p>
<pre>while(1) {
    ...
}
g_assert_not_reached();</pre>
<p>Hier k&ouml;nnte es ja durch irgendeinen Speicher&uuml;berlauf passieren, dass die <span class="listing">while</span>-Schleife abgebrochen wird, wie immer das auch passieren kann. In einem solchen Fall kann man sagen »line should never be reached«. Dabei wird folgende Fehlermeldung ausgegeben:</p>
<pre>** ERROR **:
file glibx.c: line 9 (main): should not be reached aborting...</pre>
<p>Weitere Routinen, um z. B. eine Funktion zu beenden, wenn eine bestimmte Bedingung nicht eintraf, w&auml;ren die Funktionen <span class="listing">g_return_if_fail()<a id="Xxx999359" name="Xxx999359"></a></span> und <span class="listing">g_return_val_if_fail()<a id="Xxx999360" name="Xxx999360"></a></span>. Beide Funktionen k&ouml;nnen wie <span class="listing">g_assert()</span> verwendet werden, nur ohne dass das Programm beendet wird. Ein Beispiel mit <span class="listing">g_return_if_fail()</span>.</p>
<pre><a id="Xxx999361" name="Xxx999361"></a>/* glib2.c */
#include &lt;gtk/gtk.h&gt;
static void myfunc( gint val1, gint val2 ) {
   g_return_if_fail( (val1 &gt; 0 &amp;&amp; val2 &gt; 0) );
   /* Tu was ... */
   g_print("val1 und val2 haben nicht den Wert 0\n");
   return;
}
int main(void) {
   myfunc(5, 4);
   myfunc(3, 1);
   myfunc(0, 3); /* Fehler - aber nicht kritisch */
   g_print("Kein Programmabbruch!\n");   
   return 0;   
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib2 glib2.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib2
val1 und val2 haben nicht den Wert 0
val1 und val2 haben nicht den Wert 0
** CRITICAL **: 
file glib2.c: line 6 (myfunc): assertion `(val1 &gt; 0 &amp;&amp; val2 &gt; 0)' failed.
Kein Programmabbruch!</pre>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t35"></a><h3 class="t3">15.3.4 Speicherverwaltung<a id="RxxKap150020400053F1F0131A4" name="RxxKap150020400053F1F0131A4"></a> 
      <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999366" name="Xxx999366"></a>Folgende Funktionen werden Ihnen von der Glib zur Reservierung und zum Freigeben von Speicherplatz zur Verf&uuml;gung gestellt. Als Vergleich sei hier auch das Gegenst&uuml;ck aus der Standardbibliothek angegeben:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 15.2   
    </b>Funktionen zum Reservieren und Freigeben von Speicherplatz</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Glib-Funktion</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>entspricht …</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999374" name="Xxx999374"></a>gpointer g_malloc(gulong n_bytes)
</td>
<td class="tabellentext" bgcolor="#000000">void *malloc(size_t size) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999379" name="Xxx999379"></a>gpointer g_malloc0(gulong n_bytes)
</td>
<td class="tabellentext" bgcolor="#000000">wie malloc(), initialisiert Speicher wie calloc()
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999384" name="Xxx999384"></a>gpointer g_try_malloc(gulong n_bytes)
</td>
<td class="tabellentext" bgcolor="#000000">wie malloc() 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999389" name="Xxx999389"></a>gpointer g_realloc( gpointer mem,
          gulong n_bytes ) 
</td>
<td class="tabellentext" bgcolor="#000000">wie void *realloc(void *ptr, size_ t size) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999394" name="Xxx999394"></a>gpointer g_try_realloc(gpointer mem,
           gulong n_bytes)
</td>
<td class="tabellentext" bgcolor="#000000">wie realloc() 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999399" name="Xxx999399"></a>void g_free(gpointer mem)
</td>
<td class="tabellentext" bgcolor="#000000">void free(void *ptr)
</td>
</tr>
</table><br>
<p>Folgende besonderen Merkmale weist <span class="listing">g_malloc()</span> im Gegensatz zu <span class="listing">malloc()</span> in Standard-C auf:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> g_malloc()</span> gibt <span class="listing">NULL</span> zur&uuml;ck, wenn die Gr&ouml;&szlig;e des zu reservierenden Speichers 0 ist. Das liegt aber daran, weil man sich aus Portabilit&auml;tsgr&uuml;nden innerhalb der GNU libc dazu entschlossen hat, <span class="listing">malloc(0)</span> g&uuml;ltig zu machen.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> g_malloc()</span> beendet das Programm von selbst, wenn ein Fehler (<span class="listing">NULL</span>) bei der Allozierung aufgetreten ist. Sie m&uuml;ssen nicht mehr selbst auf <span class="listing">NULL</span> &uuml;berpr&uuml;fen. <span class="listing">g_malloc()</span> eignet sich daher nicht f&uuml;r eigene Bibliotheken, da diese <span class="listing">NULL</span> zur&uuml;ckgeben m&uuml;ssen.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Die <span class="listing">_try_</span>-Versionen <span class="listing">g_try_malloc()</span> und <span class="listing">g_try_realloc()</span> beenden sich im Gegensatz zu den Versionen ohne <span class="listing">_try_</span> (<span class="listing">g_malloc()</span>; <span class="listing">g_realloc()</span>) nicht selbstst&auml;ndig bei einem Fehler - sondern geben C-typisch <span class="listing">NULL</span> (bei Auftreten eines Fehlers) zur&uuml;ck.</td>
</tr>
</table>
<p>Hierzu ein Listing, das Ihnen die <span class="listing">g</span>-Familie der <span class="listing">malloc()</span>-Fraktion demonstriert:</p>
<pre><a id="Xxx999416" name="Xxx999416"></a>/* glib3.c */
#include &lt;gtk/gtk.h&gt;
#define MMAX 100
int main(void) {
   gpointer *mem, *dup;
   gchar *text = "Text zum Kopieren";
   /* Speicher reservieren */
   mem = g_malloc(MMAX);
   /* Etwas in Speicher schreiben */
   g_snprintf((gchar *)mem, MMAX, "%s\n",text);
   /* Inhalt des Speichers ausgeben */
   g_print("mem: %s",(gchar *)mem);
   /* Speicherplatz duplizieren */
   dup = g_memdup(mem, MMAX);
   /* Inhalt des kopierten Speichers ausgeben */
   g_print("dup: %s",(gchar *)dup);   
   /* Kopierten Speicherplatz freigeben */
   g_free(dup);   
   /* Ein Fehler mit Absicht - Programmabbruch */
   mem = g_malloc( -1 );
   return 0;   
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib3 glib3.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib3
mem: Text zum Kopieren
dup: Text zum Kopieren
GLib-ERROR **: gmem.c:140: failed to allocate 4294967295 bytes
aborting...
Abgebrochen</pre>
<h4 class="t4">Speicherbl&ouml;cke kopieren</h4>
<p><a id="Xxx999421" name="Xxx999421"></a>Der einfachste Weg, um einen Speicherblock zu kopieren, ist (wie im Beispiel oben gesehen) die Verwendung der Funktion <span class="listing">g_memdup()<a id="Xxx999423" name="Xxx999423"></a></span>. Diese Funktion reserviert die Menge an Speicherplatz, die Sie als zweiten Parameter angegeben haben, und kopiert die Anzahl der Bytes von der Adresse des ersten Parameters in den neuen Block. Als R&uuml;ckgabewert erhalten Sie die Anfangsadresse des neuen Blocks oder <span class="listing">NULL</span>.</p>
<h4 class="t4">Makros zur Speicherverwaltung</h4>
<p><a id="Xxx999425" name="Xxx999425"></a>Neben <span class="listing">malloc()</span>-&auml;hnlichen Funktionen der Glib bietet Ihnen diese Bibliothek auch einige Makros zur Speicherbeschaffung an. Da ja die Speicherblockgr&ouml;&szlig;e beim Aufruf mit z. B. <span class="listing">g_malloc()</span> nicht nummerisch angegeben werden sollte, sondern als Gr&ouml;&szlig;e des Datentyps oder der Struktur mit dem <span class="listing">sizeof()</span>-Operator, finden sich in der Glib Makros, die Ihnen die Arbeit des Castens abnehmen (was immer noch eine h&auml;ufige Fehlerquelle ist, weshalb Sie es, wenn nicht n&ouml;tig, sein lassen sollten). Ein Beispiel:</p>
<pre>Strukturzeiger = (structurtyp *)g_malloc(sizeof(structurtyp)*10);</pre>
<p>Hiermit werden f&uuml;r den Strukturzeiger zehn Elemente vom Typ <span class="listing">structurtyp</span> mit der entsprechenden Gr&ouml;&szlig;e reserviert. Es ist jetzt im Prinzip egal, wie diese Struktur aussieht. Diese Casterei wird Ihnen jetzt mit dem Makro <span class="listing">g_new()</span> abgenommen:</p>
<pre>Strukturzeiger = g_new(strukturtyp, 10);</pre>
<p>Auch wenn das Konstrukt dem C++-Pendant recht &auml;hnlich sieht, es hat nichts damit zu tun! Speicherplatz m&uuml;ssen Sie hierbei weiterhin mit <span class="listing">g_free()</span> freigeben und nicht etwa mit einem C++-&auml;hnlichen <span class="listing">delete()</span>. Hier ein &Uuml;berblick zu den Makros und den gleichwertigen Gegenst&uuml;cken:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 15.3   
    </b>Makros zur Speicherreservierung</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Makro</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Gleichwertig zu ...</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999437" name="Xxx999437"></a>g_new(type , size);
</td>
<td class="tabellentext" bgcolor="#000000">g_malloc(sizeof(type) * size);
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999442" name="Xxx999442"></a>g_new0(type, size);
</td>
<td class="tabellentext" bgcolor="#000000">g_malloc0(sizeof(type) * size );
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999447" name="Xxx999447"></a>g_renew(type, ptr, size);
</td>
<td class="tabellentext" bgcolor="#000000">g_realloc(ptr, sizeof(type) * size );
</td>
</tr>
</table><br>
<h4 class="t4">Weitere Funktionen zur Speicherbeschaffung</h4>
<p>Die Glib bietet noch eine Menge mehr Funktionen und Makros zur Speicherbeschaffung und -verwaltung an. Alle hier zu diskutieren w&uuml;rde den Umfang des Buchs sprengen. Die g&auml;ngigen kennen Sie zumindest jetzt, und sie sind in der Regel auch v&ouml;llig ausreichend, um damit arbeiten zu k&ouml;nnen.</p>
<p><a id="Xxx999461" name="Xxx999461"></a>Erw&auml;hnen muss ich allerdings noch einen speziellen Mechanismus der Glib – den Speicherklumpen (<span class="listing">GmemChunk</span>). Dieser wird f&uuml;r das Belegen immer gleichartiger Speicherbl&ouml;cke verwendet, was bei einer GUI-Software recht h&auml;ufig vorkommt. Der Klumpen setzt sich dabei aus Atomen (Speicherbl&ouml;cken) zusammen. <span class="listing">GmemChunk</span> ist allerdings keine Datenstruktur, sondern ein Hilfsmittel zu Verwaltung der Speicherbl&ouml;cke. Sinn hat es nat&uuml;rlich, dadurch die Geschwindigkeit von GUI-Anwendungen zu beschleunigen. <a id="Xxx999463" name="Xxx999463"></a>Eine weitere Speichertechnik sind die Quarks mit <span class="listing">GQuark</span>, die erst einmal nichts mit Physik oder der Speicherverwaltung zu tun haben, aber intern irgendwie doch, da mit dieser Technik Speicherplatz gespart werden kann.</p>
<p>Sofern Sie also umfangreiche und speicherintensive Anwendungen erstellen, sollten Sie sich <span class="listing">GMemChunk</span> und <span class="listing">GQuark</span> auf jeden Fall in der Dokumentation ansehen. Als Tipp kann ich Ihnen hierf&uuml;r auch das Buch von M. Warkus, GNOME 2.0, empfehlen, das auf diese Themen genauer eingeht.</p>
<a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t36"></a><h3 class="t3">15.3.5 Stringbearbeitung<a id="RxxKap150020400053F1F0131D6" name="RxxKap150020400053F1F0131D6"></a> 
      <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999466" name="Xxx999466"></a>Die Behandlung und Bearbeitung von Strings ist h&auml;ufig eine der umfangreicheren Aufgaben f&uuml;r den C-Programmierer. Die meiste Zeit muss der Programmierer dabei h&auml;ufig f&uuml;r den Puffer des Strings aufwenden. Die Glib hat Ihnen hierf&uuml;r viele Funktionen zur Verf&uuml;gung gestellt, die Ihnen (fast) die ganze Arbeit abnehmen. Die Glib bietet Ihnen eine unglaubliche Anzahl von Stringfunktionen, so dass ich Sie auch hier mit einem Tut mir Leid f&uuml;r den kurzen &Uuml;berblick ... abspeisen muss. Aber die wichtigsten werden erw&auml;hnt – versprochen. Sofern Sie anschlie&szlig;end weiter nach Stringfunktionen forschen wollen, m&uuml;ssen Sie lediglich nach Funktionen mit dem Pr&auml;fix <span class="listing">g_str</span> Ausschau halten. Alle Stringfunktionen der Glib beginnen damit. Dann gibt es noch Funktionen, die im Zusammenhang mit dem Datentyp <span class="listing">GString</span> stehen, die alle mit dem Pr&auml;fix <span class="listing">g_string</span> beginnen. S&auml;mtliche Funktionen, die Sie vom Standard-C her kennen, sind nat&uuml;rlich auch in verbesserter Form in der <span class="listing">g_</span>-Variante vorhanden – worauf allerdings nicht n&auml;her eingegangen wird, da diese &auml;hnlich angewendet werden, wie Sie dies vom Standard-C her kennen.</p>
<h4 class="t4">Stringkonvertierungs- und Modifikationsfunktionen</h4>
<p>Um alle Zeichen eines Strings in Gro&szlig;- bzw. Kleinbuchstaben umzuwandeln, k&ouml;nnen Sie die folgenden Funktionen verwenden:<a id="Xxx999470" name="Xxx999470"></a><a id="Xxx999471" name="Xxx999471"></a></p>
<pre>void g_strup(const gchar * string);/* alles in Gro&szlig;buchstaben  */
void g_strdown(gchar * sring);     /* alles in Kleinbuchstaben */</pre>
<p>Beachten Sie, dass hierbei die Strings direkt ver&auml;ndert werden. Sofern der String <span class="listing">NULL</span> ist, kehren beide Funktionen einfach zur&uuml;ck. Wollen Sie zwei Strings unabh&auml;ngig von der Gro&szlig;- bzw. Kleinschreibung vergleichen, k&ouml;nnen Sie folgende Funktionen verwenden:<a id="Xxx999474" name="Xxx999474"></a><a id="Xxx999475" name="Xxx999475"></a></p>
<pre>gint g_strcasecmp (gchar *str1, gchar *str2);
gint g_strncasecmp(gchar *str1, gchar *str2, guint n);</pre>
<p>Mit der Funktion <span class="listing">g_strncasecmp()</span> k&ouml;nnen Sie im Gegensatz zur Funktion <span class="listing">g_strcasecmp()</span> die ersten <span class="listing">n</span>-Bytes, anstatt die beiden kompletten Strings, miteinander vergleichen. Sind beide Strings gleich, gibt die Funktion 0, ansonsten die Adressen der Position zur&uuml;ck, die nicht mehr miteinander &uuml;bereinstimmen.</p>
<p>Einen String umdrehen k&ouml;nnen Sie mit der Funktion:<a id="Xxx999478" name="Xxx999478"></a></p>
<pre>void g_strreverse(gchar *str);</pre>
<p>Hierbei wird der String ver&auml;ndert und in umgekehrter Reihenfolge ausgegeben. Bei einer &Uuml;bergabe von <span class="listing">NULL</span> kehrt die Funktion unwiderruflich zur&uuml;ck.</p>
<p>Hierzu ein Listing, das diese Funktionen demonstrieren soll:</p>
<pre><a id="Xxx999483" name="Xxx999483"></a>/* glib4.c */
#include &lt;gtk/gtk.h&gt;
int main(void) {
   gchar text[]  = { "Text zum Manipulieren" };
   gchar text2[] = { "Text (noch mehr)" };
   
   g_strup(text);
   g_print("g_strup()  : %s\n",text);
   g_strdown(text);
   g_print("g_strdown(): %s\n",text);  
 
   if(g_strcasecmp( text, text2 ) )
      g_print("'text' und 'text2' sind ungleich\n");
   else 
      g_print("Beide Zeichenketten sind gleich\n");
   if(g_strncasecmp(text, text2, 5) )
      g_print("'text' und 'text2' sind ungleich"
              " (erste 5 Zeichen)\n");
   else
      g_print("Die ersten 5 Zeichen der beiden "
              "Strings sind gleich\n"); 
  
   g_strreverse( text );
   g_print("g_strreverse() : %s\n",text);
   return 0;   
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib4 glib4.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib4
g_strup()  : TEXT ZUM MANIPULIEREN
g_strdown(): text zum manipulieren
'text' und 'text2' sind ungleich
Die ersten 5 Zeichen der beiden Strings sind gleich
g_strreverse() : nereilupinam muz txet</pre>
<p><a id="Xxx999487" name="Xxx999487"></a>Um eine Kopie einer Zeichenkette anzulegen, sind folgende Funktionen vorhanden:<a id="Xxx999488" name="Xxx999488"></a><a id="Xxx999489" name="Xxx999489"></a></p>
<pre>gchar* g_strdup (const gchar *str);  
gchar* g_strndup(const gchar *str, gsize n);</pre>
<p>Beide Funktionen geben eine Kopie der Zeichenkette <span class="listing">str</span> zur&uuml;ck. Mit <span class="listing">g_strndup()</span> werden nur die ersten <span class="listing">n</span> Bytes kopiert und zur&uuml;ckgegeben. Ist <span class="listing">str</span> k&uuml;rzer als <span class="listing">n</span> Bytes, wird der Rest mit <span class="listing">\0</span> aufgef&uuml;llt.</p>
<p>Weitere interessante Funktionen hierzu sind:<a id="Xxx999493" name="Xxx999493"></a><a id="Xxx999494" name="Xxx999494"></a></p>
<pre>gchar* g_strdup_printf (const gchar *format, ...);
gchar* g_strdup_vprintf(const gchar *format, va_list args);</pre>
<p>Beide Funktionen erstellen ein Format und eine Werteliste wie <span class="listing">printf()</span>. Anschlie&szlig;end legen diese Funktionen eine neue Zeichenkette mit passender L&auml;nge an und schreiben die Ausgabe hinein. Dies ist die sicherere und komfortablere Alternative zu <span class="listing">sprintf()</span>. Die Funktion <span class="listing">g_strdup_vprintf()</span> unterscheidet sich dadurch, dass eine <span class="listing">va_list</span> entgegengenommen wird, wie dies zum Beispiel bei der Verwendung einer selbst geschriebenen Funktion mit variabler Argumentenanzahl der Fall ist.</p>
<p>Beliebig viele Strings aneinander h&auml;ngen, ohne sich um den Speicherplatz zu k&uuml;mmern, k&ouml;nnen Sie mit der Funktion:<a id="Xxx999499" name="Xxx999499"></a></p>
<pre>gchar* g_strconcat(const gchar *str1, ...);</pre>
<p>Damit diese Funktion auch funktioniert, muss die Liste mit <span class="listing">NULL</span> abgeschlossen werden. Zur&uuml;ckgegeben wird die Anfangsadresse aller zusammengeh&auml;ngter Strings.</p>
<p>Wollen Sie selbiges machen und dabei noch ein Zwischenraumzeichen (Feldtrenner) zwischen den einzelnen Strings einf&uuml;gen, k&ouml;nnen Sie die Funktion <span class="listing">g_strjoin()</span> verwenden:<a id="Xxx999503" name="Xxx999503"></a></p>
<pre>gchar* g_strjoin(const gchar *trenner, ...);</pre>
<p>Ansonsten funktioniert diese Funktion genauso wie <span class="listing">g_strconcat()</span> – also muss die Liste auch mit <span class="listing">NULL</span> abgeschlossen werden.</p>
<p>Die <span class="listing">snprintf()</span>-Funktion der Glib sei in diesem Zusammenhang ebenfalls erw&auml;hnt, da diese recht h&auml;ufig in der Praxis eingesetzt wird:<a id="Xxx999507" name="Xxx999507"></a></p>
<pre>gint g_snprintf( gchar *zielstring,
                 gulong n,
                 const gchar *format, ... );</pre>
<p>Funktioniert &auml;hnlich wie <span class="listing">snprintf()</span> und schreibt einen durch <span class="listing">format</span> formatierten String mit der sich anschlie&szlig;enden Werteliste in den Puffer <span class="listing">zielstring</span>. Geschrieben werden <span class="listing">n</span> Bytes Zeichen mit dem abschlie&szlig;enden <span class="listing">\0</span>. Der R&uuml;ckgabewert von <span class="listing">g_snprintf()</span> ist die Anzahl Zeichen, welche die Funktion ausg&auml;be, w&auml;re der Puffer gro&szlig; genug. Dies entspricht nicht dem Verhalten traditioneller <span class="listing">sprintf()</span>-Implementationen.</p>
<p>Das letzte Zeichen einer Zeichenkette entfernen k&ouml;nnen Sie mit der Funktion:<a id="Xxx999510" name="Xxx999510"></a></p>
<pre>gchar* g_strchomp(gchar *zkette);</pre>
<p>Gerne eingesetzt wird diese Funktion wohl bei der Eingabe mittels <span class="listing">fgets()</span>, um das Newline-Zeichen am Ende loszuwerden. Es wird aber nicht das Stringterminierungszeichen entfernt! Es gibt auch eine Version, um das erste Zeichen eines Strings zu entfernen:<a id="Xxx999514" name="Xxx999514"></a></p>
<pre>gchar *g_strchug(gchar * str);</pre>
<p>Um Zeichen, die im String vorkommen, durch andere zu ersetzen, wird diese Funktion verwendet:<a id="Xxx999517" name="Xxx999517"></a></p>
<pre>gchar* g_strdelimit( gchar *str,
                     const gchar *trenner,
                     gchar neuer_trenner ); </pre>
<p>Ersetzt alle in <span class="listing">trenner</span> vorkommenden Zeichen in <span class="listing">str</span> durch das Zeichen <span class="listing">neuer_trenner</span>. Ist der <span class="listing">trenner</span> <span class="listing">NULL</span>, wird eine Standardzeichenkette verwendet, die als symbolische Konstante mit <span class="listing">G_STR_DELIMITERS<a id="Xxx999520" name="Xxx999520"></a></span> definiert ist.</p>
<p>Hierzu wieder ein Listing, das Ihnen die einzelnen Funktionen in der Praxis zeigt:</p>
<pre><a id="Xxx999522" name="Xxx999522"></a>/* glib5.c */
#include &lt;stdio.h&gt;
#include &lt;gtk/gtk.h&gt;
#define MMAX 255
int main(void) {
   const gchar *text = "Hallo ";
   const gchar *tex2 = "Welt! ";
   gchar *copy, *more;
   gchar *str, *test;
   const gchar str1[] = { "String1" };
   const gchar str2[] = { "String2" };
   const gchar str3[] = { "String3" };   
   char buf[MMAX];
   
   copy = g_strdup(text);
   g_print("g_strdup() : %s\n",copy);
   
   more = g_strdup_printf("%s %s",text, tex2);
   g_print("g_strdup_printf(): %s\n", more);
   
   str = g_strconcat(str1,"|", str2,"|", str3, NULL);
   g_print("g_strconcat() : %s\n",str);   
   
   str = g_strjoin("|", str1, str2, str3, NULL);
   g_print("g_strjoin() : %s\n", str);
   
   test = g_malloc(MMAX);
   g_snprintf(test, MMAX, "PIN-Code: 432–557–32 (speichern)");
   
   g_strdelimit(test, "0123456789", '*');
   g_print("%s\n",test);
   g_print("G_STR_DELIMITERS : %s\n",G_STR_DELIMITERS);
   
   g_print("Text eingeben : ");
   fgets(buf, MMAX, stdin);
   /* Weg mit dem Newline-Zeichen */
   g_strchomp(buf);
   g_print("%s\n",buf);
   g_print("Hinter buf\n");   
   return 0;   
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib5 glib5.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib5
g_strdup() : Hallo
g_strdup_printf(): Hallo Welt!
g_strconcat() : String1|String2|String3
g_strjoin() : String1|String2|String3
PIN-Code: ***-***-** (speichern)
G_STR_DELIMITERS : _-|&gt; &lt;.
Text eingeben : Die GLib ist genial
Die GLib ist genial
Hinter buf</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Nicht behandelt wurden au&szlig;erdem die Unmengen an Funktionen f&uuml;r Unicode- und Zeichencodierung. Bei Bedarf sei wieder die Dokumentation empfohlen oder eben entsprechende Literatur.</p>
</td>
</tr>
</table><br>
<a name="t36"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t37"></a><h3 class="t3">15.3.6 Selbstverwaltender Stringpuffer<a id="RxxKap150020400053F1F013201" name="RxxKap150020400053F1F013201"></a> 
      <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999531" name="Xxx999531"></a>In der Glib wurde ein neuer Datentyp mit dem Namen <span class="listing">GString</span> eingef&uuml;hrt, der zwar gleichwertig wie ein gew&ouml;hnlicher String ist, nur dass dieser sich automatisch um den Puffer k&uuml;mmert. Damit geh&ouml;ren Buffer Overflows in Ihrem Programm der Vergangenheit an. Realisiert wird dieser Puffer mit einer einfachen Struktur namens <span class="listing">GString</span>:</p>
<pre>struct GString {
  /* Zeiger auf einen \0-terminierten String */
  gchar *str; 
  /* Aktuelle L&auml;nge */
  gint len; 
};</pre>
<p>Einen neuen Textpuffer k&ouml;nnen Sie mit den folgenden Funktionen erstellen:<a id="Xxx999534" name="Xxx999534"></a><a id="Xxx999535" name="Xxx999535"></a></p>
<pre>GString *g_string_new(const gchar *init);
Gstring *g_string_sized_new(guint size);</pre>
<p>Die erste Funktion erstellt einen neuen Textpuffer, wobei der neue Puffer gleich mit einer Kopie von <span class="listing">init</span> initialisiert wird, worauf dieser verweist. Mit der zweiten Funktion (<span class="listing">g_string_sized_new()</span>) reservieren Sie einen Speicherplatz f&uuml;r einen neuen String mit <span class="listing">size</span> Bytes L&auml;nge. Der Puffer wird dabei automatisch mit <span class="listing">'\0'</span> Zeichen initialisiert. Den Speicherplatz f&uuml;r <span class="listing">GString</span> geben Sie mit der Funktion <span class="listing">g_string_free()</span> wieder frei.<a id="Xxx999539" name="Xxx999539"></a></p>
<pre>void g_string_free(GString *string, gint free_segment);</pre>
<p>Ist <span class="listing">free_segment</span> <span class="listing">TRUE</span>, werden auch die Daten von <span class="listing">str</span> der <span class="listing">GString</span>-Struktur freigegeben.</p>
<p>Jetzt folgen einige Funktionen, mit denen Sie den Textpuffer bearbeiten k&ouml;nnen. Hierzu erst einmal eine - nat&uuml;rlich nicht komplette - Liste einiger Funktionen, die mit dem Datentypen <span class="listing">GString</span> zusammenarbeiten.<a id="Xxx999543" name="Xxx999543"></a><a id="Xxx999544" name="Xxx999544"></a><a id="Xxx999545" name="Xxx999545"></a><a id="Xxx999546" name="Xxx999546"></a><a id="Xxx999547" name="Xxx999547"></a><a id="Xxx999548" name="Xxx999548"></a><a id="Xxx999549" name="Xxx999549"></a><a id="Xxx999550" name="Xxx999550"></a></p>
<pre>GString *g_string_assign(GString  *lval,  const gchar *rval);
GString *g_string_append(GString *string, gchar *val);
GString *g_string_append_c(GString *string, gchar c);
GString *g_string_prepend(GString *string, gchar *val);
GString *g_string_prepend_c(GString *string, gchar c);
GString *g_string_insert( 
                  GString *string, gint offset, gchar *val);
GString *g_string_insert_c(
                  GString *string, gint offset, gchar val);
GString *g_string_erase( GString *string, gint pos, gint length);</pre>
<p>Mit der Funktion <span class="listing">g_string_assign()</span> kopieren Sie den String <span class="listing">rval</span> in den <span class="listing">GString</span> <span class="listing">lval</span>. Wie bei der Standard-C-Funktion <span class="listing">strcpy()</span> wird dabei der Originaltext (falls einer vorhanden ist) in <span class="listing">lval</span> &uuml;berschrieben. Um den Speicherplatz m&uuml;ssen Sie sich keine Gedanken machen, das erledigt Glib f&uuml;r Sie. Als R&uuml;ckgabewert erhalten Sie bei Erfolg einen Zeiger auf <span class="listing">lval</span>.</p>
<p>Mit den Funktionen <span class="listing">g_string_append()</span> und <span class="listing">g_string_append_c()</span> h&auml;ngen Sie an den Quellstring <span class="listing">string</span> (erster Parameter) einen String oder (bei <span class="listing">g_string_append_c()</span>) ein Zeichen (zweiter Parameter) an. Als R&uuml;ckgabewert erhalten Sie einen Zeiger auf die Anfangsadresse von <span class="listing">string</span>.</p>
<p>Mit <span class="listing">g_string_prepend()</span> oder <span class="listing">g_string_prepend_c()</span> f&uuml;gen Sie am Anfang des Zielstrings <span class="listing">string</span> einen String oder ein Zeichen hinzu. Auch hier wird als R&uuml;ckgabewert ein Zeiger auf die Anfangsadresse von <span class="listing">string</span> zur&uuml;ckgegeben.</p>
<p>Mit den Funktionen <span class="listing">g_string_insert()</span> und <span class="listing">g_string_insert_c()</span> f&uuml;gen Sie einen String oder ein Zeichen in den Zielstring <span class="listing">string</span> ein. Wo dieser String oder das Zeichen eingef&uuml;gt wird, geben Sie mit <span class="listing">offset</span> an. Als R&uuml;ckgabewert erhalten Sie einen Zeiger auf die Anfangsadresse von <span class="listing">string</span>.</p>
<p>Mit <span class="listing">g_string_erase()</span> k&ouml;nnen Sie im Zielstring <span class="listing">string</span> von der Position <span class="listing">pos</span> bis zu <span class="listing">length</span> Zeichen l&ouml;schen. Bei falscher Angabe von <span class="listing">pos</span> oder <span class="listing">length</span> wird <span class="listing">string</span> unver&auml;ndert zur&uuml;ckgegeben. Die R&uuml;ckgabe ist auch hierbei ein Zeiger auf den Anfang von <span class="listing">string</span>.</p>
<p>Alle hier erw&auml;hnten Funktionen liefern im Fehlerfalle <span class="listing">NULL</span> zur&uuml;ck, wenn der Zielstring <span class="listing">NULL</span> ist. Ist allerdings der Quellstring <span class="listing">NULL</span>, wird der Zielstring nicht ver&auml;ndert und auch so zur&uuml;ckgegeben.</p>
<p>Eine besondere Funktion sollte noch erw&auml;hnt werden:</p>
<pre>void g_string_sprintf(GString *string, const gchar *fmt ...);</pre>
<p>Diese Funktion ist der <span class="listing">sprintf()</span>-Funktion von C sehr &auml;hnlich und hat den Vorteil, dass der Puffer automatisch erweitert wird, falls n&ouml;tig. Befinden sich im <span class="listing">GString</span> <span class="listing">string</span> noch Zeichen, werden diese unwiderruflich &uuml;berschrieben.</p>
<p>Das folgende Listing soll Ihnen diese Funktionen und den neuen Glib-Datentyp <span class="listing">GString</span> in der Praxis zeigen:</p>
<pre><a id="Xxx999562" name="Xxx999562"></a>/* glib6.c */
#include &lt;gtk/gtk.h&gt;
#include &lt;string.h&gt;
#define MMAX 255
int main(void) {
   GString *gstr;
   guint size;
   gint val = 1;
   
   gstr = g_string_new("GString initialisiert");
   g_print("%s mit %d Bytes\n\n",gstr-&gt;str, gstr-&gt;len);
   
   g_string_assign(gstr, 
           "g_string_assign() ueberschreibt den Originalstring");
   g_print("%s\n\n", gstr-&gt;str);
   
   g_string_append(gstr, 
            "\n-&gt; hinzugefuegt mit g_string_append()");
   g_print("%s\n\n", gstr-&gt;str);
   /* Einzelnes Zeichen hinzuf&uuml;gen am Ende */
   g_string_append_c(gstr, '!');
   g_print("%s\n\n", gstr-&gt;str);
   
   g_string_prepend(gstr, 
            "Vorne angefuegt mit g_string_prepend()\n");
   g_print("%s\n\n", gstr-&gt;str);
   /* Einzelnes Zeichen hinzuf&uuml;gen am Anfang */
   g_string_prepend_c(gstr, '!');
   g_print("%s\n\n", gstr-&gt;str);
   
   g_string_insert(gstr, 10, " xxxEINGEFUEGTxxx " );
   g_print("%s\n\n", gstr-&gt;str);   
   
   size = strlen(gstr-&gt;str);
   /* String l&ouml;schen */
   g_string_erase(gstr, 0, size);
   
   g_string_sprintf(gstr, 
            "Puffer wird mit g_string_sprintf() automatisch"
            " verwaltet (%d)\n",val);
   g_print("%s\n\n", gstr-&gt;str);      
   return 0;   
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib6 glib6.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib6
GString initialisiert mit 21 Bytes
g_string_assign() &uuml;berschreibt den Originalstring
g_string_assign() &uuml;berschreibt den Originalstring
-&gt; hinzugef&uuml;gt mit g_string_append()
g_string_assign() &uuml;berschreibt den Originalstring
-&gt; hinzugef&uuml;gt mit g_string_append()!
Vorne angef&uuml;gt mit g_string_prepend()
g_string_assign() &uuml;berschreibt den Originalstring
-&gt; hinzugef&uuml;gt mit g_string_append()!
!Vorne angef&uuml;gt mit g_string_prepend()
g_string_assign() &uuml;berschreibt den Originalstring
-&gt; hinzugef&uuml;gt mit g_string_append()!
!Vorne ang xxxEINGEF&Uuml;GTxxx ef&uuml;gt mit g_string_prepend()
g_string_assign() &uuml;berschreibt den Originalstring
-&gt; hinzugef&uuml;gt mit g_string_append()!
Puffer wird mit g_string_sprintf() automatisch verwaltet (1)</pre>
<a name="t37"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t38"></a><h3 class="t3">15.3.7 Timer<a id="RxxKap150020400053F1F013218" name="RxxKap150020400053F1F013218"></a> 
      <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999567" name="Xxx999567"></a>Im Gro&szlig;en und Ganzen ist ein Timer nichts anderes als eine Stoppuhr, die so genau wie die Systemuhr ist. Timer werden gerne verwendet, wenn z. B. f&uuml;r eine bestimmte Zeit auf ein Event gewartet werden soll – oder einfach als Verz&ouml;gerung (wie Sie dies im Beispiel der X-Programmierung gesehen haben). Diese sind eigentlich recht einfach zu verwenden. Hier ein &Uuml;berblick zu einigen Funktionen, die Ihnen dazu zur Verf&uuml;gung stehen:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 15.4   
    </b>Timer-Funktionen der Glib</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Funktion</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">Timer erzeugen
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999577" name="Xxx999577"></a>GTimer *g_timer_new();
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">Timer starten
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999582" name="Xxx999582"></a>void g_timer_start( GTimer *timer );
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">Zeit abfragen (Sekunden und Millisekunden), die seit dem Start des Timers vergangen ist
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999587" name="Xxx999587"></a>gdouble g_timer_elapsed(
  GTimer *timer, gulong *msecs );
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">Die abgelaufene Zeit auf 0 zur&uuml;cksetzen (und neustarten)
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999592" name="Xxx999592"></a>void g_timer_reset( GTimer *timer);
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">Timer stoppen
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999597" name="Xxx999597"></a>g_timer_stop( GTimer *stop );
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">Timer zerst&ouml;ren (freigeben)
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999602" name="Xxx999602"></a>void g_timer_destroy(GTimer *timer);
</td>
</tr>
</table><br>
<p>Ein einfaches Listing, das die Timer-Funktionen demonstrieren soll.</p>
<pre><a id="Xxx999613" name="Xxx999613"></a>/* glib7.c */
#include &lt;gtk/gtk.h&gt;
#include &lt;stdio.h&gt;
int main (void) {
   GTimer *timer = NULL;
   gdouble time;
   gulong us;
   gint i=300000000;
   gint j=300000000;
   timer = g_timer_new ();
   
   g_timer_start (timer);
   g_print ("Timer laeuft\n");
   
   while(i--);      
   time = g_timer_elapsed (timer, &amp;us);
   g_print ("Schleife dekrementiert %g sek == %ld usek\n",
             time, us);   
   g_timer_reset( timer );   
   while(i++ &lt;= j);
   time = g_timer_elapsed (timer, &amp;us);
   g_print ("Schleife inkrementieren %g sek == %ld usek\n",
             time, us);     
   g_timer_reset( timer );   
   g_print("Timer von Hand starten &lt;ENTER&gt;\n");
   getchar();
   g_timer_start (timer);
   
   g_print("Timer von Hand stoppen &lt;ENTER&gt;\n");
   getchar();
   g_timer_stop( timer );
   
   time = g_timer_elapsed (timer, &amp;us);
   g_print ("Vergangene Zeit zwischen Start und Stopp"
            " %g sek == %ld usek\n", time, us);
   g_timer_destroy (timer);
   return 0;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib7 glib7.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib7
Timer l&auml;uft
Schleife dekrementiert 0.769323 sek == 769323 usek
Schleife inkrementieren 0.775894 sek == 775894 usek
Timer von Hand starten &lt;ENTER&gt;
ENTER
Timer von Hand stoppen &lt;ENTER&gt;
ENTER
Vergangene Zeit zwischen Start und Stopp 2.26975 sek == 269751 usek</pre>
<a name="t38"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t39"></a><h3 class="t3">15.3.8 Dynamische Arrays<a id="RxxKap150020400053F1F01322F" name="RxxKap150020400053F1F01322F"></a> 
      <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999618" name="Xxx999618"></a>Die Glib bietet Ihnen mit <span class="listing">GArray</span> einen Datentyp f&uuml;r ein C-typisches Arrayfeld, nur mit dem Unterschied, dass dieses nicht von fester Gr&ouml;&szlig;e sein muss. Mit dem flexibleren Array-Datentyp k&ouml;nnen Sie beliebig neue Elemente einf&uuml;gen, und das sowohl am Anfang und am Ende wie auch mittendrin – nat&uuml;rlich ist auch das L&ouml;schen inbegriffen.</p>
<p>Dabei bietet Ihnen die Glib gleich drei Formen von dynamischen Arrays an:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> gew&ouml;hnliche Arrays</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Zeiger-Arrays</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Byte-Arrays</td>
</tr>
</table>
<p>Durchgenommen werden hier nur die gew&ouml;hnlichen Arrays, welche praktisch mit allen Elementen beliebigen Typs – inklusive Strukturen – verwendet werden k&ouml;nnen. Dazu eine kurze Zusammenstellung von einigen Funktionen f&uuml;r <span class="listing">GArray</span>, welche gew&ouml;hnlich alle mit dem Pr&auml;fix <span class="listing">g_array_</span> beginnen.<a id="Xxx999625" name="Xxx999625"></a><a id="Xxx999626" name="Xxx999626"></a><a id="Xxx999627" name="Xxx999627"></a><a id="Xxx999628" name="Xxx999628"></a><a id="Xxx999629" name="Xxx999629"></a><a id="Xxx999630" name="Xxx999630"></a><a id="Xxx999631" name="Xxx999631"></a></p>
<pre>GArray *g_array_new(
        gboolean zero_terminated, gboolean clear, guint size );
void g_array_free( GArray *array, gboolean free_segment );
GArray *g_array_append_vals( 
        GArray *array, gconstpointer *data, guint len );
GArray *g_array_prepend_vals( 
        GArray *array, gconstpointer *data, guint len );
GArray *g_array_insert_vals( 
    GArray *array, guint index, gconstpointer *data, guint len );
GArray *g_array_remove_index( GArray *array, guint index );
g_array_index( array, datentyp, index );</pre>
<p>Zuerst muss mit der Funktion <span class="listing">g_array_new()</span> der Array alloziiert werden. Mit den beiden <span class="listing">gboolean</span>-Parametern geben Sie an, ob ein Nullwert als Terminierungszeichen angeh&auml;ngt wird und ob neue Elemente auf null gesetzt werden. Der letzte Parameter muss die Gr&ouml;&szlig;e des Elements in Bytes (Datentyp) enthalten, wovon Sie einen dynamischen Array erzeugen wollen. Zur&uuml;ckgegeben wird bei Erfolg ein Zeiger auf den neuen <span class="listing">GArray</span>.</p>
<p>Die Speicherverwaltung wird von nun an mit den entsprechenden Funktionen von der Glib &uuml;bernommen. Allerdings freigeben m&uuml;ssen Sie nicht verwendeten Speicherplatz mit der Funktion <span class="listing">g_array_free()</span> wieder selbst.</p>
<p>Wollen Sie ein neues Element am Anfang bzw. Ende des <span class="listing">GArray</span> hinzuf&uuml;gen, k&ouml;nnen Sie hierf&uuml;r die Funktionen <span class="listing">g_array_prepend_vals()</span> bzw. <span class="listing">g_array_append_vals()</span> verwenden. Beide Funktionen erwarten als ersten Parameter einen Zeiger auf den Array, wo entsprechende Daten, die mit dem zweiten Parameter angegeben werden, hinzugef&uuml;gt werden. Mit dem dritten Parameter geben Sie die Anzahl der Elemente an, die Sie hinzuf&uuml;gen wollen.</p>
<p>Die Funktion <span class="listing">g_array_insert_vals()</span> hat im Gegensatz zu den Funktionen <span class="listing">g_array_prepend_vals()</span> und <span class="listing">g_array_append_vals()</span> noch einen zus&auml;tzlichen Parameter (zweiter Parameter), womit Sie die Indexposition angeben und das neue Element einf&uuml;gen k&ouml;nnen.</p>
<p>Ein Element aus der Liste des <span class="listing">GArray</span> (erster Parameter) k&ouml;nnen Sie unter Angabe der Indexnummer des zweiten Parameters mit der Funktion <span class="listing">g_array_remove_index()</span> entfernen.</p>
<p>Um anschlie&szlig;end wieder auf die einzelnen Elemente des <span class="listing">GArray</span> zur&uuml;ckzugreifen, ben&ouml;tigen Sie das Makro <span class="listing">g_array_index()</span>. Als Argument &uuml;bergeben Sie dieser Funktion das Array, den Datentyp der Elemente und die Indexnummer. Zur&uuml;ckgegeben wird dann der Wert des entsprechenden Elementes.</p>
<p>Das folgende Listing soll Ihnen die Verwendung vom dynamischen <span class="listing">GArray</span> mit der Glib demonstrieren. Sie k&ouml;nnen gerne versuchen, das Beispiel in Standard-C in dieser kurzen Form und mit solch einfachem Code zu schreiben.</p>
<pre><a id="Xxx999640" name="Xxx999640"></a>/* glib8.c */
#include &lt;gtk/gtk.h&gt;
#include &lt;stdio.h&gt;
#define MMAX 255
static struct daten {
   gchar ort[MMAX];
   guint plz;
};
static struct daten help;
static guint count = 0;
static void read_data (void) {
   g_print ("Ort eingeben          : ");
   fgets (help.ort, MMAX, stdin);
   g_strchomp (help.ort);
   g_print ("Postleitzahl eingeben : ");
   scanf ("%d", &amp;help.plz);
}
static void insert_beginn (GArray * arr) {
   read_data ();
   g_array_prepend_vals (arr, &amp;help, 1);
   count++;
}
static void insert_end (GArray * arr) {
   read_data ();
   g_array_append_vals (arr, &amp;help, 1);
   count++;
}
static void insert_middle (GArray * arr) {
   guint pos;
   read_data();
   g_print ("Position angeben      : ");
   scanf ("%d", &amp;pos);
   if (pos &lt; count) {
      g_array_insert_vals (arr, pos, &amp;help, 1);
      count++;
   }
   else
      g_print ("Konnte Array nicht einfuegen (%d &lt; %d)\n",
                pos, count);
}
static void remove_array (GArray * arr) {
   guint pos;
   g_print ("Position zum Loeschen angeben    : ");
   scanf ("%d", &amp;pos);
   if (pos &lt; count) {
      g_array_remove_index (arr, pos);
      count--;
   }
   else
      g_print ("Konnte Array nicht entfernen (%d &lt; %d)\n",
                pos, count);
}
static void show_arrays (GArray * arr) {
   struct daten test;
   guint pos = 0;
   while (pos &lt; count) {
      test = g_array_index (arr, struct daten, pos);
      g_print ("Ort     :  %s\n", test.ort);
      g_print ("PLZ     :  %d\n", test.plz);
      pos++;
   }
}
int main (int argc, char **argv) {
   GArray *darray;
   guint auswahl;
   darray = g_array_new (FALSE, FALSE, sizeof (struct daten));
   do {
      printf ("Demonstration: dynamische Arrays (Glib)\n\n");
      printf ("1 - Neue Daten am Anfang einfuegen\n");
      printf ("2 - Neue Daten am Ende einfuegen\n");
      printf ("3 - Neue Daten an gewuenschte Pos. einfuegen\n");
      printf ("4 - Daten entfernen\n");
      printf ("5 - Daten ausgeben\n");
      printf ("0 - Programmende\n");
      printf ("\nIhre Auswahl : ");
      scanf ("%d", &amp;auswahl);
      getchar ();
      switch (auswahl) {
      case 1:
         insert_beginn (darray);
         break;
      case 2:
         insert_end (darray);
         break;
      case 3:
         insert_middle (darray);
         break;
      case 4:
         remove_array (darray);
         break;
      case 5:
         show_arrays (darray);
         break;
      }
   }
   while (auswahl != 0);
   g_array_free (darray, TRUE);
   return 0;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o glib8 glib8.c `pkg-config --libs --cflags gtk+-2.0`
$ ./glib8
Demonstration von dynamischen Arrays mit GLib
1 - Neue Daten am Anfang einfuegen
2 - Neue Daten am Ende einfuegen
3 - Neue Daten an gewuenschte Pos. einf&uuml;gen
4 - Daten entfernen
5 - Daten ausgeben
0 - Programmende
Ihre Auswahl :
...</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Wenn Sie das <span class="listing">GArray</span> auch noch sortieren wollen, k&ouml;nnen Sie sich die Funktionen <span class="listing">g_array_sort()</span> <span class="listing">und</span> <span class="listing">g_array_sort_with_data()</span> ansehen.</p>
</td>
</tr>
</table><br>
<a name="t39"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t310"></a><h3 class="t3">15.3.9 Listen, Hashtabellen und bin&auml;re B&auml;ume<a id="RxxKap150020400053F1F013243" name="RxxKap150020400053F1F013243"></a> 
      <a href="#t2t311"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999649" name="Xxx999649"></a>Weiterhin bietet die Glib eine Unmenge an Funktionen f&uuml;r dynamische Datenstrukturen wie die einfachen und doppelt verketteten Listen. F&uuml;r die einfach verketteten Listen werden der Datentyp <span class="listing">GSList</span> und die Funktionen mit dem Pr&auml;fix <span class="listing">g_slist_</span> verwendet und f&uuml;r die doppelt verketteten Listen der Typ <span class="listing">GList</span> und die Funktionen mit dem Pr&auml;fix <span class="listing">g_list_</span>. Der Vorteil dieser Funktionen ist nat&uuml;rlich, dass man eben schnell auf abgepackte Routinen zugreifen kann und nicht eigene und somit auch wieder fehleranf&auml;llige Versionen der Listen schreiben muss.</p>
<p><a id="Xxx999651" name="Xxx999651"></a>Ebenfalls eine klassische, aber auch l&auml;stig zu schreibende Datenstruktur stellt die Glib Ihnen mit den Hashtabellen zur Verf&uuml;gung. Hashtabellen sind Tabellen, die Schl&uuml;sseln einen sog. Hash zuordnen. Mit diesem Hash werden neue Werte eingef&uuml;gt und vor allem auch schneller wieder gefunden. Der Glib-Datentyp f&uuml;r Hashtabellen ist <span class="listing">GHashTable</span>, und die Routinen haben das Pr&auml;fix <span class="listing">g_hash_</span>. Bei dem GNOME-Desktop und dessen Software werden Hashtabellen zum Beispiel intensiv eingesetzt.</p>
<p><a id="Xxx999653" name="Xxx999653"></a>Der eingebaute Typ <span class="listing">Gtree</span> ist eine Implementierung bin&auml;rer B&auml;ume in der Glib mit allen m&ouml;glichen Routinen dazu. Besser noch, bei den B&auml;umen der Glib handelt es sich zus&auml;tzlich noch um ausbalancierte B&auml;ume. Wer schon einmal versucht hat, eine eigene Routine f&uuml;r ausbalancierte B&auml;ume zu schreiben, wei&szlig;, wie schwierig und vor allem fehleranf&auml;llig das ist. Des Weiteren sind die einzelnen Elemente im bin&auml;ren Baum eben nicht nur einfache Elemente, die aus einem Datensatz bestehen, sondern au&szlig;erdem auch einen Schl&uuml;ssel besitzen, anhand dessen die Datens&auml;tze sortiert und gefunden werden – sprich, eine Hashtabelle von bin&auml;ren B&auml;umen, wenn Sie so wollen. Die Routinen, die sich auf den Typ <span class="listing">Gtree</span> beziehen, beginnen alle mit dem Pr&auml;fix <span class="listing">g_tree_</span>.</p>
<p>Auf die beiden klassischen Datenstrukturen soll hierbei nicht mehr n&auml;her eingegangen werden, da sich die Einf&uuml;hrung in die Glib ohnehin schon ziemlich umfangreich gestaltet und mehr Platz f&uuml;r das eigentliche Thema der GUI-Programmierung reserviert werden sollte. F&uuml;r den weiteren Verlauf des Buchs ben&ouml;tigen Sie dieses Wissen ohnehin nicht.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Sollten Sie mit Begriffen wie Listen, Hashtabellen oder bin&auml;ren B&auml;umen nichts anzufangen wissen, dann muss ich Sie auf ein Einsteigerbuch zu C verweisen. Auf der Buch-CD finden Sie diesbez&uuml;glich mit dem Buch »C von A bis Z« einen einfachen Einstieg in dieses m&auml;chtige Thema.</p>
</td>
</tr>
</table><br>
<a name="t310"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t311"></a><h3 class="t3">15.3.10 Ausblick Glib<a id="RxxKap150020400053F1F01324A" name="RxxKap150020400053F1F01324A"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t310"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Hier angekommen, l&auml;sst sich nur sagen, dass die Glib noch eine Menge mehr hilfreicher Routinen und Typen anbietet. Ich w&uuml;rde teilweise sogar so weit gehen und Ihnen empfehlen, die Glib zur Erstellung von Konsolenprogrammen zu verwenden. Zu den Vorteilen geh&ouml;ren Dinge wie die Sicherheit und ein Einsparen an Overhead bei der Programmierung. Nat&uuml;rlich sollte es nicht unerw&auml;hnt bleiben, dass Sie die Glib nicht verwenden m&uuml;ssen, um GTK+-Programme zu schreiben – Sie k&ouml;nnen nat&uuml;rlich weiterhin f&uuml;r diese Aufgaben die Standard-C-Funktionen verwenden oder im Falle von Algorithmen und Datenstrukturen selbst zum x-ten Mal etwas neu schreiben. Fakt ist, die Glib ist eine ausgereifte und sehr hilfreiche Bibliothek, die einem das Leben enorm erleichtern kann und vor allem bei dem Thema Portieren auf anderen Systemen erste Wahl sein sollte.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap15-001.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap15-003.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap15-002.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:46:13 GMT -->
</html>
