<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap02-002.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:44:26 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Linux-UNIX-Programmierung – 2.3 Funktionen, die den Filedeskriptor verwenden</title>
<meta name="title" content="Linux-UNIX-Programmierung">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2006">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2006">
<meta name="description" content="Linux-UNIX-Programmierung - Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006 – ISBN 3-89842-749-8">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="Kap02-001.html">
<link rel="next" href="Kap02-003.html"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
<table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74">
<a href="https://www.rheinwerk-verlag.de/?GPP=oplup"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a>
</td>
</tr>
</table><div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger</a></div><br /><table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="156" valign="top"><table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
<tr>
<td colspan="2" class="nav1" align="left" valign="top" height="150">
<table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><A class="nav" href="index-2.html">Inhaltsverzeichnis</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00a-000.html#Xxx999195">Vorwort des Autors</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap00b-000.html#Xxx999195">Vorwort der Fachgutachter</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap01-000.html#Xxx999235">1 Einf&uuml;hrung</A></td>
</tr>
<tr>
<td><A class="navnavh" href="Kap02-000.html#Xxx999234">2 E/A-Funktionen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap03-000.html#Xxx999234">3 Attribute von Dateien und Verzeichnissen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap04-000.html#Xxx999234">4 Zugriff auf Systeminformationen</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap05-000.html#Xxx999234">5 Devices – eine einfache Verbindung zur Hardware</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap06-000.html#Xxx999234">6 System- und Benutzerdateien</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap07-000.html#Xxx999234">7 D&auml;monen, Zombies und Prozesse</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap08-000.html#Xxx999235">8 Signale</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap09-000.html#Xxx999235">9 IPC – Interprozesskommunikation</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap10-000.html#Xxx999234">10 Threads</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap11-000.html#Xxx999235">11 Netzwerkprogrammierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap12-000.html#Xxx999236">12 MySQL und PostgreSQL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap13-000.html#Xxx999235">13 Terminal E/A und Benutzerschnittstellen f&uuml;r die Konsole</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap14-000.html#Xxx999235">14 Xlib – X Window-Programmierung</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap15-000.html#Xxx999235">15 GTK+</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap16-000.html#Xxx999235">16 SDL</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap17-000.html#Xxx999247">17 Werkzeuge f&uuml;r Programmierer</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18A-000.html#Xxx999248">A Sicherheit unter Linux</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18B-000.html#Xxx999245">B Funktionsreferenz</A></td>
</tr>
<tr>
<td><A class="navnav" href="Kap18C-000.html#Xxx999245">C Inhalt der Buch-CD</A></td>
</tr>
<tr>
<td><A class="navnav" href="stichwort.html#Xxx537584">Index</A></td>
</tr>
<tr><td><br /><!--<a class="navnav" href="http://download.galileo-press.de/openbook/lup/galileocomputing_linux_unix_programmierung.zip"><strong>Download:</strong><br />- ZIP, ca. 4,3 MB</a></td></tr>
<tr><td><a class="navnav" href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup">Buch bestellen</a></td></tr>
<tr><td>--><a class="navnav" href="https://www.rheinwerk-verlag.de/feedback/">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>

</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
<div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap02-001.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navnav">Rheinwerk Computing /</a><a class="navnav" href="https://www.rheinwerk-verlag.de/openbook/?GPP=oplup"> &lt;openbook&gt; /</a> <a href="index-2.html" class="navnav"> Linux-UNIX-Programmierung</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap02-003.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
<table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup" class="buchtitel">Linux-UNIX-Programmierung</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch – 2., aktualisierte und erweiterte Auflage 2006</span></td>
</tr>
<tr>
<td valign="top" width="90"><a href="https://www.rheinwerk-verlag.de/1137/?GPP=oplup"><img src="common/9783898427494.gif" border="0" alt="Buch: Linux-UNIX-Programmierung" title="Buch: Linux-UNIX-Programmierung" align="left"><br /><br /><span class="autor"><strong>Linux-UNIX-Programmierung</strong><br />1216 S., mit CD, 49,90 Euro<br />Rheinwerk Computing<br />ISBN 3-89842-749-8</span></a></a></td>
<td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="Kap02-000.html#RxxKap02000040000AE1F02D100">2 E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-000.html#RxxKap02000040000AE1F02D107">2.1 Elementare E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-001.html#RxxKap02001040000CB1F04C100">2.2 Filedeskriptor</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-001.html#RxxKap02001040000CB1F04C115">2.2.1 Verwaltung f&uuml;r offene Deskriptoren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh2" href="#RxxKap02002040000CC1F023100">2.3 Funktionen, die den Filedeskriptor verwenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F023102">2.3.1 Datei &ouml;ffnen – open()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0231D2">2.3.2 Anlegen einer neuen Datei – creat()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0231D7">2.3.3 Datei schlie&szlig;en – close()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0231DB">2.3.4 Schreiben von Dateien – write()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0231EF">2.3.5 Lesen von Dateien – read()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0231FA">2.3.6 Schreib-/Lesezeiger positionieren – lseek()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F023214">2.3.7 Duplizieren von Filedeskriptoren – dup() und dup2()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F023220">2.3.8 &Auml;ndern oder Abfragen der Eigenschaften eines Filedeskriptors – fcntl()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F023259">2.3.9 Record Locking – Sperren von Dateien einrichten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0232AF">2.3.10 Multiplexing E/A – select()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0232C4">2.3.11 Unterschiedliche Operationen – ioctl()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0232CD">2.3.12 Lesen und Schreiben mehrerer Puffer – writev() und readv()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a class="navh2" href="#RxxKap02002040000CC1F0232DA">2.3.13 &Uuml;bersicht zu weiteren Funktionen, die den Filedeskriptor verwenden</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-003.html#RxxKap02003040000CD1F024100">2.4 Standard-E/A-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024103">2.4.1 Der FILE-Zeiger</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024115">2.4.2 &Ouml;ffnen und Schlie&szlig;en von Dateien</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0241DC">2.4.3 Formatierte Ausgabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0241FD">2.4.4 Formatierte Eingabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F02420E">2.4.5 Bin&auml;res Lesen und Schreiben</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024212">2.4.6 Zeichen- und zeilenweise Ein-/Ausgabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024259">2.4.7 Status der Ein-/Ausgabe &uuml;berpr&uuml;fen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F02425D">2.4.8 Stream positionieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F024282">2.4.9 Puffer kontrollieren</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0242A1">2.4.10 Datei l&ouml;schen und umbenennen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-003.html#RxxKap02003040000CD1F0242A7">2.4.11 Tempor&auml;re Dateien erstellen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-004.html#RxxKap02004040000CE1F049100">2.5 Mit Verzeichnissen arbeiten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F049102">2.5.1 Ein neues Verzeichnis anlegen – mkdir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F04910C">2.5.2 In ein Verzeichnis wechseln – chdir(), fchdir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F049175">2.5.3 Ein leeres Verzeichnis l&ouml;schen – rmdir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F04917B">2.5.4 Format eines Datei-Eintrags in struct dirent</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F04918E">2.5.5 Einen Verzeichnisstream &ouml;ffnen – opendir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F04919C">2.5.6 Lesen aus dem DIR-Stream – opendir() und Schlie&szlig;en des DIR-Streams – closedir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F0491AF">2.5.7 Positionieren des DIR-Streams</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F0491B9">2.5.8 Komplettes Verzeichnis einlesen – scandir()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><T3Verw><a href="Kap02-004.html#RxxKap02004040000CE1F0491CF">2.5.9 Ganze Verzeichnisb&auml;ume durchlaufen – ftw()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-005.html#RxxKap02005040000CF1F011100">2.6 Fehlerbehandlung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="Kap02-006.html#RxxKap02006040000D01F01A100">2.7 Ausblick</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div>
<h2 class="t2">2.3 <a id="RxxKap0241FunktionendiedenFiledeskriptorverwenden" name="RxxKap0241FunktionendiedenFiledeskriptorverwenden"></a>Funktionen, die den Filedeskriptor verwende<a id="RxxKap02002040000CC1F023100" name="RxxKap02002040000CC1F023100"></a>n 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p>Eine gro&szlig;e Anzahl von Funktionen verwendet einen Filedeskriptor. In diesem Abschnitt finden Sie eine Beschreibung der wichtigsten Funktionen und einen &Uuml;berblick zu weniger verwendeten oder erst in einem sp&auml;teren Kapitel ben&ouml;tigten Funktionen.</p>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t32"></a><h3 class="t3">2.3.1 Datei<a id="Xxx999236" name="Xxx999236"></a> &ouml;ffnen – open(<a id="RxxKap02002040000CC1F023102" name="RxxKap02002040000CC1F023102"></a>)<a id="Xxx999237" name="Xxx999237"></a> 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Es gibt zwei Versionen der Funktionen <span class="listing">open()</span>, um eine Datei zu &ouml;ffnen oder eine neue Datei anzulegen. Hier die Syntax dazu:</p>
<pre>#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
int open(const char *pfadname, int flags);
int open(const char *pfadname, int flags, mode_t zugriffsrechte);</pre>
<p>Als Pfadangabe m&uuml;ssen Sie den absoluten oder relativen Pfad der Datei angeben, die ge&ouml;ffnet werden soll. Da der Prototyp in Wirklichkeit korrekt <span class="listing">open(const</span> <span class="listing">char</span> <span class="listing">*,</span> <span class="listing">int</span> <span class="listing">...)</span> lautet, kann je nach Situation das dritte Argument auch wegfallen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>In der prozessspezifischen Dateitabelle werden dabei die entsprechenden Eintr&auml;ge gemacht und initialisiert. Z. B. wird f&uuml;r die Datei die Position des aktuellen Schreib- oder Lesevorgangs mit 0 vorbelegt (Ausnahme: das <span class="listing">O_APPEND<a id="Xxx999245" name="Xxx999245"></a></span> Flag). Dies ist f&uuml;r den Programmierer nicht unbedingt wichtig zu wissen, aber falls es Sie interessiert, was intern vorgeht, soll dies nicht unerw&auml;hnt bleiben.</p>
</td>
</tr>
</table><br>
<p>Der Systemaufruf <span class="listing">open()</span> liefert als R&uuml;ckgabewert den Index (Filedeskriptor) des neu angelegten Eintrags in der prozessspezifischen Dateitabelle zur&uuml;ck. Die Eintr&auml;ge 0, 1 und 2 sind dabei bereits beim Start des Programms mit denen des Elternprogramms vorbelegt (siehe 2.1, Filedeskriptor). Im Falle einer Shell ist dies der Terminal, sofern keine Dateiumleitung vorgenommen wurde.</p>
<p>Die maximale Anzahl ge&ouml;ffneter Filedeskriptoren f&uuml;r einen Prozess ist mit der symbolischen Konstante <span class="listing">OPEN_MAX<a id="Xxx999249" name="Xxx999249"></a></span>, die in der Headerdatei <span class="listing">&lt;limits.h&gt;<a id="Xxx999250" name="Xxx999250"></a></span> definiert ist, festgelegt. <span class="listing">OPEN_MAX</span> ist hierbei das Minimum an Filedeskriptoren, die das Betriebssystem bzw. die C-Bibliothek bereitstellt. Es k&ouml;nnen nat&uuml;rlich &uuml;ber weiterreichende Funktionen wie <span class="listing">ulimit()<a id="Xxx999251" name="Xxx999251"></a></span>, <span class="listing">rsetlimit()<a id="Xxx999252" name="Xxx999252"></a></span> diese Limits erh&ouml;ht werden, w&auml;hrend <span class="listing">OPEN_MAX</span> immer gleich bleibt. Weiterhin kann man mit diesen Funktionen die Zahl auch kleiner als <span class="listing">OPEN_MAX</span> werden lassen; jene Einstellungen gelten dann auch f&uuml;r Subprogramme (Kindprozesse).</p>
<p>Konnte der Systemaufruf <span class="listing">open()</span> die Datei nicht &ouml;ffnen, wird der Wert -1 zur&uuml;ckgeliefert. Ben&ouml;tigen Sie weitere Informationen, welcher Fehler aufgetreten ist, so sollten Sie die globale Variable <span class="listing">errno<a id="Xxx999254" name="Xxx999254"></a></span>, die sich in der Headerdatei <span class="listing">&lt;errno.h&gt;<a id="Xxx999255" name="Xxx999255"></a></span> befindet, auswerten. Diesen Fehlerwert k&ouml;nnen Sie anhand unterschiedlicher Konstanten, die sich ebenfalls in dieser Headerdatei befinden, identifizieren. Oder besser noch, Sie lassen sich die Fehlermeldung mit der Funktion <span class="listing">perror()<a id="Xxx999256" name="Xxx999256"></a></span> (<span class="listing">stdlib.h</span>) oder <span class="listing">strerror()<a id="Xxx999257" name="Xxx999257"></a></span> (<span class="listing">string.h</span>) im Klartext ausgeben (mehr dazu etwas sp&auml;ter).</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Die Fehlervariable <span class="listing">errno</span> wird in der Regel von allen wichtigen Systemcalls (sofern nicht anders in den Manual Pages »ausgeschildert«) gesetzt und kann daher auch bei allen diesen Funktionen verwendet werden.</p>
</td>
</tr>
</table><br>
<p>Bei der Verwendung von <span class="listing">flags</span> k&ouml;nnen mit dem Systemaufruf <span class="listing">open()</span> folgende Angaben eingesetzt werden:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 2.3   
    </b>Bearbeitungsflags beim &Ouml;ffnen einer Datei</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Flag</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_RDONLY<a id="Xxx999269" name="Xxx999269"></a>
</td>
<td class="tabellentext" bgcolor="#000000">&Ouml;ffnen der Datei zum Lesen
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_WRONLY<a id="Xxx999274" name="Xxx999274"></a>
</td>
<td class="tabellentext" bgcolor="#000000">&Ouml;ffnen der Datei zum Schreiben
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_RDWR<a id="Xxx999279" name="Xxx999279"></a>
</td>
<td class="tabellentext" bgcolor="#000000">&Ouml;ffnen der Datei zum Lesen und Schreiben
</td>
</tr>
</table><br>
<p>Diese drei Flags k&ouml;nnen nicht miteinander kombiniert werden und schlie&szlig;en sich gegenseitig aus. Eins dieser Flags, das Sie ausgew&auml;hlt haben, k&ouml;nnen Sie aber mit dem bitweisen ODER (<span class="listing">|</span>) mit den nachfolgenden Werten kombinieren.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 2.4   
    </b>Weitere Flags f&uuml;r den Systemaufruf open()</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Flag</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_CREAT<a id="Xxx999298" name="Xxx999298"></a>
</td>
<td class="tabellentext" bgcolor="#000000"><a id="Xxx999301" name="Xxx999301"></a>Existiert die Datei noch nicht, wird diese mit den als dritten Parameter angegebenen Zugriffsrechten (minus aktuelle umask) erzeugt. Existiert die Datei bereits, so hat O_CREAT keinen weiteren Effekt.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_APPEND<a id="Xxx999304" name="Xxx999304"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Die Datei wird zum Schreiben am Ende ge&ouml;ffnet. Der Schreib-/Lesezeiger wird vor jeder Schreiboperation auf die aktuelle Dateigr&ouml;&szlig;e gesetzt.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_EXCL<a id="Xxx999309" name="Xxx999309"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Wird dieses Flag zusammen mit O_CREAT verwendet, kann die Datei nicht ge&ouml;ffnet werden, wenn diese bereits existiert. Mit diesem Flag k&ouml;nnen Sie verhindern, dass keine parallelen Schreibzugriffe auf eine Datei gemacht werden.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_TRUNC<a id="Xxx999314" name="Xxx999314"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Existiert diese Datei, wird sie komplett geleert (auf 0 Bytes L&auml;nge gesetzt). Dies geschieht auch, wenn die Datei nicht zum Schreiben ge&ouml;ffnet wurde (sinnvoll mit O_EXCL).
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_SYNC<a id="Xxx999319" name="Xxx999319"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Jeder Schreibvorgang auf das Medium wird direkt ausgef&uuml;hrt, und es wird gewartet, bis der Schreibvorgang komplett beendet wurde. Dieses Flag setzt den Pufferungsmechanismus au&szlig;er Kraft. O_SYNC wird nicht von POSIX.1 unterst&uuml;tzt, wohl aber von SVR4.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_NONBLOCK<a id="Xxx999324" name="Xxx999324"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Falls der Pfadname der Name eines FIFO oder einer Ger&auml;tedatei ist, wird der Prozess beim &Ouml;ffnen und bei nachfolgenden I/O-Operationen nicht blockiert. Dieses Flag zeigt seine Wirkung erst bei einer Pipe oder bei nicht blockierenden Sockets, was sp&auml;ter behandelt wird.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_NOCTTY<a id="Xxx999329" name="Xxx999329"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Falls der Pfadname der Name eines Terminals ist, so sollte dieser nicht der neue Kontrollterminal des Prozesses werden, sofern der aktuelle Prozess kein Kontrollterminal besitzt.
</td>
</tr>
</table><br>
<p>Der dritte Parameter des Systemaufrufs <span class="listing">open()</span> ist optional und wird nur dann ausgewertet, wenn das Flag <span class="listing">O_CREAT</span> gesetzt ist. Mit diesem Parameter k&ouml;nnen Sie die Zugriffsrechte<a id="Xxx999342" name="Xxx999342"></a> auf eine Datei erteilen. Auch f&uuml;r die Zugriffsrechte k&ouml;nnen Sie eine oder mehrere Konstanten, verkn&uuml;pft mit dem bitweisen ODER, verwenden. Hierzu ein &Uuml;berblick &uuml;ber die Konstanten, die Sie f&uuml;r die Zugriffsrechte verwenden k&ouml;nnen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 2.5   
    </b>&Uuml;berblick &uuml;ber die Konstanten f&uuml;r Zugriffsrechte mit open()</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Darstellung in ls</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung </b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_ISUID<a id="Xxx999351" name="Xxx999351"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[--S------]
</td>
<td class="tabellentext" bgcolor="#000000">set-user-ID Bit<a id="Xxx999356" name="Xxx999356"></a> 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_ISGID<a id="Xxx999359" name="Xxx999359"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[-----S---]
</td>
<td class="tabellentext" bgcolor="#000000">set-group-ID Bit<a id="Xxx999364" name="Xxx999364"></a>
F&uuml;r Dateien ohne S_IXGRP f&uuml;hrt dies dazu, dass die Datei dem »mandatory locking« (Linux only) unterliegen. (Siehe sp&auml;ter)
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_ISVTX<a id="Xxx999368" name="Xxx999368"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[--------T]
</td>
<td class="tabellentext" bgcolor="#000000">sticky Bit<a id="Xxx999373" name="Xxx999373"></a> (saved-text Bit)
Hat unter Linux f&uuml;r Dateien keine Bedeutung mehr.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IRUSR<a id="Xxx999377" name="Xxx999377"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[r--------]
</td>
<td class="tabellentext" bgcolor="#000000">read (user; Leserecht f&uuml;r Eigent&uuml;mer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IWUSR<a id="Xxx999384" name="Xxx999384"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[-w-------]
</td>
<td class="tabellentext" bgcolor="#000000">write (user; Schreibrecht f&uuml;r Eigent&uuml;mer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IXUSR<a id="Xxx999391" name="Xxx999391"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[--x------]
</td>
<td class="tabellentext" bgcolor="#000000">execute (user; Ausf&uuml;hrungsrecht f&uuml;r Eigent&uuml;mer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IRWXU<a id="Xxx999398" name="Xxx999398"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[rwx------]
</td>
<td class="tabellentext" bgcolor="#000000">read, write, execute (user; Lese-, Schreib-, Ausf&uuml;hrungsrecht f&uuml;r Eigent&uuml;mer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IRGRP<a id="Xxx999405" name="Xxx999405"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[---r-----]
</td>
<td class="tabellentext" bgcolor="#000000">read (group; Leserecht f&uuml;r Gruppe) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IWGRP<a id="Xxx999412" name="Xxx999412"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[----w----]
</td>
<td class="tabellentext" bgcolor="#000000">write (group; Schreibrecht f&uuml;r Gruppe) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IXGRP<a id="Xxx999419" name="Xxx999419"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[-----x---]
</td>
<td class="tabellentext" bgcolor="#000000">execute (group; Ausf&uuml;hrungsrecht f&uuml;r Gruppe) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IRWXG<a id="Xxx999426" name="Xxx999426"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[---rwx---]
</td>
<td class="tabellentext" bgcolor="#000000">read, write, execute (group; Lese-, Schreib-, Ausf&uuml;hrungsrecht f&uuml;r Eigent&uuml;mer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IROTH<a id="Xxx999433" name="Xxx999433"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[------r--]
</td>
<td class="tabellentext" bgcolor="#000000">read (other; Leserecht f&uuml;r alle anderen Benutzer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IWOTH<a id="Xxx999440" name="Xxx999440"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[-------w-]
</td>
<td class="tabellentext" bgcolor="#000000">write (other; Schreibrecht f&uuml;r alle anderen Benutzer) 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IXOTH<a id="Xxx999447" name="Xxx999447"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[--------x]
</td>
<td class="tabellentext" bgcolor="#000000">execute (other; Ausf&uuml;hrungsrecht f&uuml;r alle anderen Benutzer)
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">S_IRWXO<a id="Xxx999454" name="Xxx999454"></a>
</td>
<td class="tabellentext" bgcolor="#000000">[------rwx]
</td>
<td class="tabellentext" bgcolor="#000000">read, write, execute (other; Lese-, Schreib-, Ausf&uuml;hrungsrecht f&uuml;r alle anderen Benutzer) 
</td>
</tr>
</table><br>
<p>Hierzu folgt jetzt ein Listing mit dem Systemaufruf <span class="listing">open()</span>. Das zweite Argument in der Kommandozeile wird hierbei der Name der neuen Datei.</p>
<pre><a id="Xxx999471" name="Xxx999471"></a>/* make_file.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd. h.&gt;
int main(int argc, char **argv) {
  // Zugriffsrechte f&uuml;r die neue Datei: -rw-rw-r--
  mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
  const char *new_file;
  int fd; // Filedeskriptor
  // Alle Zugriffsrechte der Einschr&auml;nkungsmaske erlauben
  umask(0);
  // Zweites Argument der Kommandozeile auswerten
  if(argv[1] == NULL) {
      fprintf(stderr, "Usage: %s datei_zum_oeffnen\n",
         *argv);
      return EXIT_FAILURE;
  }
  new_file = argv[1];
  /*--------------------------------------------------
    Neue Datei erzeugen                   (O_CREAT)
    zum Schreiben                         (O_WRONLY)
    falls Datei existiert, nicht erzeugen (O_EXCL)
    Zugriffsrechte der Datei erteilen     (modus)
  --------------------------------------------------*/
  fd = open(new_file, O_WRONLY | O_EXCL | O_CREAT, mode);
  if(fd == -1) {
      perror("Fehler bei open ");
      return EXIT_FAILURE;
  }     
  return EXIT_SUCCESS;
}</pre>
<p>Hier das Programm im Einsatz:</p>
<pre>$ gcc -o make_file make_file.c
./make_file test
$ ls -l test
-rw-rw-r--    1 Juergen   users            0 Oct 14 02:23 test
$ ./make_file test
Fehler bei open : File exists</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Sofern Sie mit der oktalen Schreibweise der Rechtevergabe vertraut sind, k&ouml;nnen Sie nat&uuml;rlich diese als Alternative verwenden. Z. B.:
<span class="listing">fd</span> <span class="listing">=</span> <span class="listing">open(</span> <span class="listing">new_file,</span> <span class="listing">O_WRONLY</span> <span class="listing">|</span> <span class="listing">O_EXCL</span> <span class="listing">|</span> <span class="listing">O_CREAT,</span> 0644<span class="listing">);</span></p>
</td>
</tr>
</table><br>
<p>Au&szlig;erdem sollten Sie noch wissen, dass bei Verwendung des Flags <span class="listing">O_CREAT</span> die Zugriffsrechte nicht unbedingt gew&auml;hrt werden m&uuml;ssen, da die Einschr&auml;nkungsmaske die Vergabe von Rechten verhindern kann. Aus diesem Grund wurde mithilfe der Funktion <span class="listing">umask()</span> die Maske zur Wegnahme von Rechtebits auf 0 gesetzt, womit alle Zugriffsrechte in dieser Maske erlaubt werden.</p>
<h4 class="t4">Einschr&auml;nkungsmaske<a id="Xxx999480" name="Xxx999480"></a><a id="Xxx999481" name="Xxx999481"></a> setzen und abfragen – umask()<a id="Xxx999482" name="Xxx999482"></a></h4>
<p>Diese Funktion hat jetzt hier zwar nichts mit den Filedeskriptoren am Hut, aber wird recht h&auml;ufig gerade vor einem <span class="listing">open()</span>- oder dem gleich folgenden <span class="listing">creat()</span>-Aufruf verwendet. Mit dieser Funktion k&ouml;nnen Sie die Einschr&auml;nkungsmaske f&uuml;r einen aktuellen Prozess erfragen oder neu setzen.</p>
<pre>#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
mode_t umask(mode_t new_mask);</pre>
<p>Mit dieser Funktion legen Sie die Einschr&auml;nkungsmaske fest, die beim Anlegen einer neuen Datei (oder auch eines neuen Verzeichnisses) <b>nicht</b> zu vergeben bzw. <b>zu</b> <b>l&ouml;schen</b> ist, selbst wenn diese explizit von Funktionen wie <span class="listing">open()</span> oder <span class="listing">creat()</span> mit dem <span class="listing">modus</span>-Argument gefordert wurde. F&uuml;r das Argument <span class="listing">mask</span> k&ouml;nnen alle Konstanten bis auf <span class="listing">S_ISUID</span>, <span class="listing">S_ISGID</span> und <span class="listing">S_ISVTX</span> verwendet werden, die Sie mit <span class="listing">open()</span> f&uuml;r die Zugriffsrechte verwenden konnten (siehe Tabelle 2.5). Mehrere Werte verkn&uuml;pfen Sie auch hier mit dem bitweisen ODER-Operator. Im Beispiel zuvor wurde die Einschr&auml;nkungsmaske auf 0 gesetzt. Somit k&ouml;nnen hiermit vom Prozess alle Zugriffsrechte f&uuml;r eine Datei gesetzt werden. Nat&uuml;rlich l&auml;sst sich auch die oktale Darstellungsweise verwenden.</p>
<p>Wenn Sie z. B. f&uuml;r die Maske mittels <span class="listing">umask()</span> den (oktalen) Wert 0077 verwenden w&uuml;rden, h&auml;tten Sie folgende Einschr&auml;nkungsmaske:</p>
<pre>---rwxrwx</pre>
<p>Damit ist es gegeben, dass beim Setzen der Rechte, unabh&auml;ngig von den geforderten Rechten, nur die Lese-, Schreib- und Ausf&uuml;hrungsrechte des Eigent&uuml;mers m&ouml;glich w&auml;ren. Das hei&szlig;t, Sie k&ouml;nnen nur die Zugriffsrechte setzen, die von der Einschr&auml;nkungsmaske nicht verwendet wurden; in diesem Falle w&auml;re das Resultat <span class="listing">rwx------</span> (0700). W&uuml;rden Sie z. B. die Maske 0133 setzen, so h&auml;tten Sie folgende Einschr&auml;nkungsmaske vergeben:</p>
<pre>--x-wx-wx    (0133)</pre>
<p>Hiermit ist es nicht m&ouml;glich, dass der Eigent&uuml;mer die Datei ausf&uuml;hren kann und die Gruppe und alle anderen Benutzer an ein Schreib- und Ausf&uuml;hrungsrecht kommen werden. Beispiel einer solchen Berechnung:</p>
<pre>--x-wx-wx    (0133) //Einschr&auml;nkungsmaske von umask()
rw-r--r--    (0644) //M&ouml;gliche Rechtevergabe
-------------------
rwxrwxrwx    (0777) //Gesamtsumme der Rechtevergabe immer 777</pre>
<p>Standardm&auml;&szlig;ig wird meistens die Einschr&auml;nkungsmaske 022 vergeben. Es ist aber auch m&ouml;glich, mit dem Shell-Builtin-Kommando umask die eigene Einschr&auml;nkungsmaske zu &auml;ndern. Innerhalb des o. g. Listings z. B. w&uuml;rde die neu gesetzte umask von 0 nur w&auml;hrend der Ausf&uuml;hrung des Programms (und der Unterprozesse) g&uuml;ltig. Dazu kann man z. B. einen entsprechenden umask-Aufruf in einer Startup-Datei wie .profile eintragen, so dass beim Start einer entsprechenden Shell die Einschr&auml;nkungsmaske automatisch gesetzt wird.</p>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t33"></a><h3 class="t3">2.3.2<a id="Xxx999494" name="Xxx999494"></a> Anlegen einer neuen Datei – creat(<a id="RxxKap02002040000CC1F0231D2" name="RxxKap02002040000CC1F0231D2"></a>)<a id="Xxx999495" name="Xxx999495"></a> 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>In &auml;lteren UNIX-Versionen gab es das Flag <span class="listing">O_CREAT<a id="Xxx999497" name="Xxx999497"></a></span> noch nicht, daher wurde folgende Funktion zum Anlegen einer neuen Datei verwendet:</p>
<pre>#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
int creat(const char *pfadname, mode_t zugriffsmodus);</pre>
<p>Auch diese Funktion gibt bei Erfolg den Wert des neuen Filedeskriptors zur&uuml;ck, und bei einem Fehler wird -1 zur&uuml;ckgeliefert.</p>
<p>Da mit <span class="listing">creat()</span> dasselbe Ziel erreicht wird wie mit der Funktion <span class="listing">open()</span> und den Flags <span class="listing">O_WRONLY</span> <span class="listing">|</span> <span class="listing">O_CREAT</span> <span class="listing">|</span> <span class="listing">O_TRUNC</span>, ist diese Funktion eigentlich &uuml;berfl&uuml;ssig. Au&szlig;erdem kann eine mit <span class="listing">creat()</span> erzeugte Datei erst mal nur beschrieben werden. Wollen Sie aus der Datei lesen, m&uuml;ssen Sie diese erst mit <span class="listing">close()</span> schlie&szlig;en und anschlie&szlig;end mit <span class="listing">open()</span> wieder &ouml;ffnen. Richten Sie weiterhin das Augenmerk auf <span class="listing">O_TRUNC<a id="Xxx999502" name="Xxx999502"></a></span>. Somit ist <span class="listing">open()</span> gegen&uuml;ber <span class="listing">creat()</span> nicht nur aufgrund seiner Flexibilit&auml;t der Vorzug zu geben.</p>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t34"></a><h3 class="t3">2.3.3 Datei<a id="Xxx999503" name="Xxx999503"></a> schlie&szlig;en – close(<a id="RxxKap02002040000CC1F0231D7" name="RxxKap02002040000CC1F0231D7"></a>)<a id="Xxx999504" name="Xxx999504"></a> 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Wenn Sie Ihre Arbeit mit dem Filedeskriptor beendet haben, sollten Sie diesen mit der Funktion <span class="listing">close()</span> wieder schlie&szlig;en. Bei solchen Anwendungen, wie Sie es im Beispiel von <span class="listing">open()</span> oben gesehen haben, ist es nat&uuml;rlich nicht unbedingt notwendig, dass Sie den Filedeskriptor schlie&szlig;en, da bei Beendigung eines Prozesses automatisch alle Filedeskriptoren geschlossen werden. Bei dauerhaft laufenden Programmen kann es aber schon mal zu Engp&auml;ssen mit den maximal ge&ouml;ffneten Filedeskriptoren kommen. Wenn die Grenze von <span class="listing">OPEN_MAX<a id="Xxx999507" name="Xxx999507"></a></span>-Dateien, die gleichzeitig ge&ouml;ffnet wurden, erreicht ist, sollten Sie nicht ben&ouml;tigte Filedeskriptoren freigeben. Die Syntax dazu lautet:</p>
<pre>#include &lt;unistd. h.&gt;
int close(int fd);</pre>
<p>Konnte der Filedeskriptor ordentlich geschlossen werden, liefert <span class="listing">close()</span> den Wert 0 zur&uuml;ck, bei einem Fehler wird -1 zur&uuml;ckgegeben. Wurde f&uuml;r <span class="listing">fd</span> ein falscher bzw. ung&uuml;ltiger Filedeskriptor verwendet, besitzt <span class="listing">errno</span> den Wert <span class="listing">EBADF</span>.</p>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t35"></a><h3 class="t3">2.3.4 Schreiben von Dateien – write()<a id="RxxKap02002040000CC1F0231DB" name="RxxKap02002040000CC1F0231DB"></a><a id="Xxx999510" name="Xxx999510"></a> 
      <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999512" name="Xxx999512"></a>Mit dem Systemaufruf <span class="listing">write()</span> k&ouml;nnen Zeichen in einer ge&ouml;ffneten Datei geschrieben werden. Voraussetzung, dass mit <span class="listing">write()</span> auch in eine Datei geschrieben wird, ist, dass diese (logischerweise) auch zum Schreiben ge&ouml;ffnet wurde. Hier die Syntax:</p>
<pre>#include &lt;unistd. h.&gt;
ssize_t write(int fd, void *puffer, size_t anzahl_bytes);</pre>
<p>Mit <span class="listing">write()</span> werden <span class="listing">anzahl_bytes</span> Zeichen, ab der Adresse <span class="listing">puffer</span>, in die Datei geschrieben, die mit dem Filedeskriptor <span class="listing">fd</span> zuvor mit <span class="listing">open()</span> ge&ouml;ffnet wurde. Als R&uuml;ckgabewert wird entweder die Anzahl der erfolgreich geschriebenen Zeichen oder bei einem Fehler   -1 zur&uuml;ckgegeben. Nat&uuml;rlich erweitert die Funktion <span class="listing">write()</span> auch den Schreib-/Lesezeiger um die Anzahl der erfolgreich geschriebenen Bytes.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Da mit dem primitiven Datentypen <span class="listing">size_t<a id="Xxx999518" name="Xxx999518"></a></span> nur nicht negative Werte aufgenommen werden k&ouml;nnen, hat POSIX.1 den primitiven Typ <span class="listing">ssize_t<a id="Xxx999520" name="Xxx999520"></a></span> f&uuml;r vorzeichenbehaftete Werte eingef&uuml;hrt.</p>
</td>
</tr>
</table><br>
<p>Hier ein Beispiel, das die Funktion <span class="listing">write()</span> im Einsatz demonstriert:</p>
<pre><a id="Xxx999523" name="Xxx999523"></a>/* write_file.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd. h.&gt;
int main(int argc, char **argv) {
  /* Zugriffsrechte f&uuml;r die neue Datei: -rw-rw-r-- */
  mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
  ssize_t size;
  int fd; /* Filedeskriptor */
  char *str;
  /* Alle Zugriffsrechte der Einschr&auml;nkungsmaske erlauben */
  umask(0);
  /* Zweites Argument der Kommandozeile auswerten */
  if(argc &lt; 2) {
      fprintf(stderr, "Usage: %s datei_zum_oeffnen\n",
         *argv);
      return EXIT_FAILURE;
  } 
  if(argc &lt; 3) { str = "Keine Angaben gemacht\n"; }
  else { str = argv[2]; }
  size = strlen(str);
  /*----------------------------------------------
    Neue Datei erzeugen               (O_CREAT)
    zum Schreiben                     (O_WRONLY)
    Daten am Ende hinzuf&uuml;gen          (O_APPEND)
    Zugriffsrechte der Datei erteilen (modus)
  ----------------------------------------------*/
  fd = open(argv[1], O_WRONLY | O_APPEND | O_CREAT, mode);
  if(fd == -1) {
      perror("Fehler bei open()");
      return EXIT_FAILURE;
  }
  if(write(fd, str, size) != size)
      perror("Fehler bei write()");
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm im Einsatz:</p>
<pre>$ gcc -o write_file write_file.c
$ ./write_file test
$ cat test
Keine Angaben gemacht
$ ./write_file test Blopp
$ cat test
Keine Angaben gemacht
Blopp</pre>
<p>In diesem Beispiel wird immer der Text ans Ende der Datei geschrieben (<span class="listing">O_APPEND</span>). Als Text kommt entweder das dritte Argument in der Kommandozeile in Frage oder der konstante String, der auf den <span class="listing">dummy</span> verweist.</p>
<p>Probleme mit der Funktion <span class="listing">write()</span> k&ouml;nnen auch auftreten, weil nicht alle Schreiboperationen direkt auf den Datentr&auml;ger gemacht werden m&uuml;ssen, au&szlig;er es wurde das Flag <span class="listing">O_SYNC<a id="Xxx999529" name="Xxx999529"></a></span> verwendet. Obwohl <span class="listing">write()</span> ein Systemaufruf ist, werden die Daten im Falle einer Datei nochmals in einen separaten Pufferbereich innerhalb des Kernels gelegt, bevor sie schlie&szlig;lich auf den Datentr&auml;ger geschrieben werden. Ein Multitasking-Betriebssystem hat n&auml;mlich noch andere Dinge zu tun, als sich sofort um die Ausf&uuml;hrung Ihres Programms zu k&uuml;mmern. Erst wenn der Systemkern Zeit hat, wendet er sich dem Puffer<a id="Xxx999530" name="Xxx999530"></a> zu und schreibt entsprechende Daten in die Datei. St&uuml;rzt aber das System in der Zeit ab (was bei Linux weniger der Fall ist), wenn sich die Daten noch im Puffer befinden, sind diese weg und nicht mehr zu retten. Alternativ kann auch ein ganzes Dateisystem im synchronen Modus gemountet werden, siehe Manual Page von mount(1); praktisch hei&szlig;t das, dass jedem <span class="listing">open()</span>-Aufruf implizit <span class="listing">O_SYNC</span> zugesteckt wird. Es gibt sogar ein <span class="listing">O_ASYNC<a id="Xxx999531" name="Xxx999531"></a></span>-Flag, um auf einem synchronen Dateisystem einige Dateien als asynchron zu markieren.</p>
<p>Tritt beim Schreiben ein Fehler auf, ist es nicht leicht zu bestimmen, was denn falsch gelaufen ist. Ein R&uuml;ckgabewert von 0 und gr&ouml;&szlig;er sagt nicht aus, ob auch wirklich alle Daten angekommen sind. In unserem Beispiel eben wurde Folgendes verwendet:</p>
<pre>  if(write(fd, str, size) != size)
      fprintf(stderr, "Fehler bei write ...\n");  </pre>
<p>Das scheint im Gro&szlig;en und Ganzen auch in Ordnung zu sein. Was ist aber, wenn die Daten in <span class="listing">str</span> so umfangreich sind oder nicht so viele Daten auf einmal geschrieben werden k&ouml;nnen (wie das bei den Sockets h&auml;ufig der Fall ist)? Dann wird der Schreibvorgang mit einer Fehlermeldung abgebrochen. F&uuml;r solch einen Fall sollten (m&uuml;ssen) Sie sich r&uuml;sten. Es wird empfohlen, <span class="listing">write()</span> immer in einer Schleife zu verwenden, die so lange ausgef&uuml;hrt wird, bis alle Daten geschrieben wurden. Ich habe hierzu eine Wrapper-Funktion f&uuml;r <span class="listing">write()</span> geschrieben, die wie folgt aussieht:</p>
<pre>#include &lt;unistd. h.&gt;
ssize_t write2(int fd, const void *buffer, size_t count) {
   while (count &gt; 0) {
      ssize_t geschrieben = write(fd, buffer, count);
      if (geschrieben == -1)
         return -1;
      count -= geschrieben;
      buffer += geschrieben;
   }
   return 0;
}</pre>
<p>Sie k&ouml;nnen diese Wrapper-Funktion gerne in das Beispiel zuvor einbauen. Diese Funktion kehrt erst zur&uuml;ck, wenn alle Bytes geschrieben wurden oder ein Fehler bei <span class="listing">write()</span> auftritt.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Wrapper<a id="Xxx999539" name="Xxx999539"></a>-Funktionen k&ouml;nnen Sie sich wie einen Strumpf vorstellen, der &uuml;ber die Originalfunktion gezogen wird. Nat&uuml;rlich darf eine solche Funktion nicht denselben Namen wie das Original haben (sie darf nat&uuml;rlich schon, nur wird sich GCC definitiv dar&uuml;ber &auml;rgern).</p>
</td>
</tr>
</table><br>
<p>Wollen Sie au&szlig;erdem absolut sichergehen, dass <span class="listing">write()</span> alle Daten mit einem Rutsch in die Datei schreibt, m&uuml;ssen Sie das Flag f&uuml;r synchrones Schreiben (<span class="listing">O_SYNC</span>) verwenden. Dadurch machen Sie sich allerdings die Zeitvorteile der Funktion <span class="listing">write()</span> zunichte (allerdings auch abh&auml;ngig vom Speichermedium). Der Zeitaufwand f&uuml;r das Schreiben erh&ouml;ht sich dadurch drastisch. Letztendlich m&uuml;ssen Sie entscheiden, ob nun Sicherheit oder Schnelligkeit wichtiger ist.</p>
<a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t36"></a><h3 class="t3">2.3.5 Lesen von Dateien – read()<a id="RxxKap02002040000CC1F0231EF" name="RxxKap02002040000CC1F0231EF"></a><a id="Xxx999543" name="Xxx999543"></a> 
      <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999545" name="Xxx999545"></a>Mit dem Systemaufruf <span class="listing">read()</span> k&ouml;nnen Zeichen aus einer ge&ouml;ffneten Datei gelesen werden. Voraussetzung nat&uuml;rlich ist auch hier, dass mit <span class="listing">read()</span> nur aus einer Datei gelesen werden kann, wenn diese (logischerweise) auch zum Lesen ge&ouml;ffnet wurde. Hier die Syntax:</p>
<pre>#include &lt;unistd. h.&gt;
ssize_t read(int fd, void *puffer, size_t anzahl_bytes);</pre>
<p>Damit werden <span class="listing">anzahl_bytes</span> aus der ge&ouml;ffneten Datei vom Filedeskriptor <span class="listing">fd</span> in die Adresse von <span class="listing">puffer</span> kopiert. Auch hier ist, wie schon bei <span class="listing">write()</span>, der R&uuml;ckgabewert die Anzahl der erfolgreich gelesenen Bytes und im Fehlerfall -1. Steht der Lesezeiger bereits am Dateiende und der Systemaufruf <span class="listing">read()</span> wird verwendet, wird in diesem Fall der Wert 0 zur&uuml;ckgeliefert – was keinen Fehler darstellt! Es ist ebenfalls kein Fehler, wenn weniger Zeichen gelesen wurden, als mit <span class="listing">anzahl_bytes</span> angegeben ist, was z. B. passieren kann, wenn wir uns kurz vor dem Dateiende befinden.</p>
<p>Auch bei der Funktion <span class="listing">read()</span> wird ein Puffermechanismus verwendet, der daf&uuml;r sorgt, dass der Lesevorgang sehr schnell abgewickelt wird. Das dr&uuml;ckt sich darin aus, dass bereits Gelesenes sofort nochmals gelesen werden kann, ohne dass daf&uuml;r z. B. die CD noch mal angedreht werden m&uuml;sste. Dieser Puffer<a id="Xxx999550" name="Xxx999550"></a> (cachet Inodes) hat den Vorteil, dass nicht nur beim Lesen mittels <span class="listing">read()</span> ein Geschwindigkeitsgewinn entsteht, sondern auch beim wiederholten Ausf&uuml;hren eines – sagen wir – 20 MB schweren Programms von einem langsamen (oder k&uuml;nstlich verlangsamten) Ger&auml;t.</p>
<p>Die Anzahl von Bytes, die <span class="listing">read()</span> auf einmal lesen soll, h&auml;ngt sehr stark von der Geschwindigkeit des Lesevorgangs des Mediums ab. Man spricht dabei auch von Blockgr&ouml;&szlig;en. Als optimale Blockgr&ouml;&szlig;e<a id="Xxx999552" name="Xxx999552"></a> haben sich Speicherbl&ouml;cke mit 512, 1024 bis hin zu 8192 Bytes erwiesen. Nat&uuml;rlich h&auml;ngt dies auch von der Menge der Daten ab, die es zu lesen gilt. Es macht durchaus Sinn, die Effizienz der optimalen Gr&ouml;&szlig;e zu ermitteln. Denn je kleiner die Blockgr&ouml;&szlig;e, desto mehr <span class="listing">read()</span>-Aufrufe m&uuml;sste man t&auml;tigen – und ein Wechsel von Userspace zu Kernelspace kostet viel Zeit. Das liegt zwar im Mikrosekunden-Bereich, aber – die Masse macht´s. F&uuml;r &uuml;bliche Diskettenlaufwerke, die mit durchschnittlich 29,7 KB/s lesen, reicht somit eine kleine Blockrate (1024 aufw&auml;rts), bei z. B. externen USB-Festplatten, die knapp 20 MB/s hergeben, kann man auch schon mal eine Blockgr&ouml;&szlig;e von 64 KB oder noch mehr nehmen (kleiner als der auf der Festplatte angegebene Cache sollte sie auf jeden Fall bleiben).</p>
<p>Folgendes Beispiel kopiert die Datei, die Sie als zweites Argument in der Kommandozeile angegeben haben, in die neu erzeugte Datei, die Sie als drittes Argument angegeben haben.</p>
<pre><a id="Xxx999554" name="Xxx999554"></a>/* cpy_file.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd. h.&gt;
#define BLOCKSIZE 64 // bytes
// write2() aus obigem Codeblock &uuml;bernehmen
static ssize_t write2(int, const void *, size_t);
int main(int argc, char **argv) {
  // Zugriffsrechte f&uuml;r die neue Datei: -rw-rw-r--
  mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
  char buffer[BLOCKSIZE];
  int fd_r, fd_w; // Filedeskriptoren
  int n;  
  // Alle Zugriffsrechte der Einschr&auml;nkungsmaske erlauben
  umask(0);
  if(argc &lt; 3) {
      fprintf(stderr, "&gt; %s quelldatei zieldatei\n", *argv);
      return EXIT_FAILURE;
  }     
  fd_r = open(argv[1], O_RDONLY);
  fd_w = open(argv[2], O_WRONLY | O_EXCL | O_CREAT, mode);
  if(fd_r == -1 || fd_w == -1) {
      perror("Fehler bei open()");
      return EXIT_FAILURE;
  }
  while((n = read(fd_r, buffer, BLOCKSIZE)) &gt; 0)
      if(write2(fd_w, buffer, n) &lt; 0)
          perror("Fehler bei write()");
  return EXIT_SUCCESS;
}</pre>
<p>Und hier das Programm in Aktion:</p>
<pre>$ gcc -o cpy_file cpy_file.c
$ ./cpy_file cpy_file.c cpy_file.bak
$ cat cpy_file.bak
/* cpy_file.c */
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd. h.&gt;
#define BLOCKSIZE 64
int main (int argc, char* argv[])
...</pre>
<p>Bei diesem Beispiel wurde f&uuml;r die Blockgr&ouml;&szlig;e des Puffers eine Gr&ouml;&szlig;e von 64 Bytes gew&auml;hlt, womit Lese- und Schreiboperationen durchgef&uuml;hrt werden. Beim letzten Aufruf von <span class="listing">read()</span> wird man wohl keinen ganzen Block mehr lesen k&ouml;nnen. Daher wurde auch der Wert der gelesenen Zeichen in der Variable <span class="listing">n</span> gespeichert, damit auch nur diese Anzahl erfolgreich gelesener Zeichen vom Puffer wieder in die Zieldatei kopiert werden kann.</p>
<a name="t36"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t37"></a><h3 class="t3">2.3.6 Schreib-/Lesezeiger positionieren – lseek()<a id="RxxKap02002040000CC1F0231FA" name="RxxKap02002040000CC1F0231FA"></a><a id="Xxx999559" name="Xxx999559"></a> 
      <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999561" name="Xxx999561"></a>Jede Datei, die Sie &ouml;ffnen, besitzt auch einen Schreib-/Lesezeiger. Nach jedem Schreib- oder Lesevorgang wird dieser Zeiger um die Anzahl der geschriebenen oder gelesenen Bytes weitergesetzt. In der Regel befindet sich dieser Positionszeiger beim &Ouml;ffnen einer Datei, sei dies nun zum Schreiben oder zum Lesen, anfangs immer auf 0; abgesehen davon nat&uuml;rlich, wenn die Datei mit dem Flag <span class="listing">O_APPEND<a id="Xxx999563" name="Xxx999563"></a></span> ge&ouml;ffnet wurde.</p>
<p>Die Parameter der Funktion <span class="listing">lseek()</span> entsprechen dabei denselben wie denen der Funktion <span class="listing">fseek()<a id="Xxx999565" name="Xxx999565"></a></span>, die in der h&ouml;heren Ebene verwendet wird.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;unistd. h.&gt;
off_t lseek(int fd, off_t position, int indikator);</pre>
<p>Vom dritten Parameter (<span class="listing">indikator</span>) h&auml;ngt es ab, wie der zweite Parameter interpretiert wird. Dabei haben Sie drei M&ouml;glichkeiten zur Auswahl.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 2.6   
    </b>M&ouml;gliche Angaben f&uuml;r indikator</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">SEEK_SET<a id="Xxx999574" name="Xxx999574"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Den Schreib-/Lesezeiger vom Anfang der Datei um abstand Bytes versetzen. abstand darf dabei keine negative Zahl sein.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">SEEK_CUR<a id="Xxx999579" name="Xxx999579"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Der Schreib-/Lesezeiger wird relativ zur aktuellen Position der Datei um abstand Bytes versetzt. abstand darf dabei sowohl eine positive als auch eine negative Zahl sein, wobei negative Zahlen einem Zur&uuml;cksetzen (Richtung Anfang der Datei) entsprechen.
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">SEEK_END<a id="Xxx999584" name="Xxx999584"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Den Schreib-/Lesezeiger vom Ende der Datei um abstand Bytes »Richtung Dateiende« versetzen. abstand darf dabei sowohl eine negative als auch eine positive Zahl sein. Letzteres wird man aber wohl kaum in der Praxis finden, denn was befindet sich schon hinter EOF? Beachten Sie au&szlig;erdem, dass lseek() im Gegensatz zu fseek() nicht den EOF-Status bereinigen kann – wozu fseek() gerne verwendet wird! Es gibt n&auml;mlich keinen EOF-Status bei den Low-Level-Funktionen.
</td>
</tr>
</table><br>
<p>Der erste Parameter <span class="listing">fd</span> ist der Filedeskriptor der ge&ouml;ffneten Datei, wo Schreib- und Lesezeiger versetzt werden sollen. Wenn bei diesem Systemaufruf alles glatt verlief, wird die aktuelle neue Position des Schreib- und Lesezeigers zur&uuml;ckgegeben. Bei einem Fehler wird -1 zur&uuml;ckgeliefert.</p>
<p>Der primitive Datentyp <span class="listing">off_t<a id="Xxx999597" name="Xxx999597"></a></span> wurde vom Datentyp <span class="listing">long</span> abgeleitet. Somit kann der maximale Wert der Positionierung auf einmal 2 GB betragen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Auf manchen 32-Bit-Systemen (Linux auf jeden Fall), die das Large Files System<a id="Xxx999602" name="Xxx999602"></a> (LFS) unterst&uuml;tzen, ist es m&ouml;glich, mit der Funktion <span class="listing">open()</span> und dem Flag <span class="listing">   O_LARGEFILE<a id="Xxx999603" name="Xxx999603"></a></span> Dateien zu &ouml;ffnen, die gr&ouml;&szlig;er sind als die o. g. 2 GB. Wird dieses Flag gesetzt, ist der gr&ouml;&szlig;te Wert, der dargestellt werden kann, ein Objekt vom Typ <span class="listing">off64_t</span> (primitiver Datentyp, der gew&ouml;hnlich den Typen <span class="listing">long</span> <span class="listing">long</span> repr&auml;sentiert).</p>
</td>
</tr>
</table><br>
<p>Man kann auch Dateien gr&ouml;&szlig;er als 2 GB ohne <span class="listing">O_LARGEFILE</span> &ouml;ffnen, nur k&ouml;nnen dann die meisten Operationen nur bis 32 Bit ausgef&uuml;hrt werden.</p>
<p>Hierzu ein Beispiel, das eine (Text-)Datei, die Sie als zweites Argument in der Kommandozeile angeben, r&uuml;ckw&auml;rts ausgibt. Mithilfe von <span class="listing">lseek()</span> wird der Schreib-/Lesezeiger zuerst ans Dateiende, eine Position vor EOF, gesetzt. Anschlie&szlig;end wird mit dem Systemaufruf <span class="listing">read()</span> ein Zeichen eingelesen und mit auf dem Bildschirm ausgegeben. Damit der Text r&uuml;ckw&auml;rts ausgegeben wird, muss die Position des Zeigers immer um eine Stelle bis zum Dateianfang (<span class="listing">pos</span> <span class="listing">==</span> <span class="listing">0</span>) zur&uuml;ckgez&auml;hlt werden. Ist der Dateianfang erreicht, wird die Funktion beendet. Hier das Beispiel:</p>
<pre><a id="Xxx999607" name="Xxx999607"></a>/* backward.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd. h.&gt;
static void bwread(int fd) {
    int rv, nl = 0;
    char ch;
    lseek(fd, -1, SEEK_END); 
    while((rv = read(fd, &amp;ch, 1)) == 1) {
        if(ch == '\n' &amp;&amp; !nl) { ++nl; }
        else { putc(ch, stdout); }
        if(lseek(fd, -2, SEEK_CUR) &lt; 0) { break; }
    }
    if(nl) { putc('\n', stdout); }
    if(rv == 0) { fprintf(stderr, "EOF unerwartet ...\n"); }
    else if(rv == -1) { perror("Fehler bei read()"); }
    return;
}
int main(int argc, char **argv) {
    int fd;
    if(argc &lt; 2) {
        fprintf(stderr, "Syntax: %s datei\n", *argv);
        return EXIT_FAILURE;
    }
    if((fd = open(argv[1], O_RDONLY)) &lt; 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    bwread(fd);
    return EXIT_SUCCESS;
}</pre>
<p>Und hier das Programm im Einsatz:</p>
<pre>$ cat &gt; test.txt
Pinguine k&ouml;nnen nicht fliegen.
Sie sind das Produkt eines misslungenen Experiments
von M$. Aber der Tag der Abrechnung naht ;-)
STRG+D
$ gcc -o backward backward.c
$ ./backward test.txt
)-; than gnunhcerbA red gaT red rebA .$M nov
stnemirepxE nenegnulssim senie tkudorP sad dnis eiS
.negeilf thcin nenn&ouml;k eniugniP</pre>
<p>Das Beispiel ber&uuml;cksichtigt &uuml;brigens auch die Position des Newline-Zeichens. Beachten Sie auch, dass hier der Schreib-/Lesezeiger um eine Position vor dem Dateiende platziert wurde. H&auml;tten Sie hierf&uuml;r 0L angegeben, w&uuml;rde <span class="listing">read()</span> den Wert 0 zur&uuml;ckgeben, und es w&uuml;rde <span class="listing">EOF</span> <span class="listing">unerwartet</span> <span class="listing">...</span> ausgegeben werden.</p>
<a name="t37"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t38"></a><h3 class="t3">2.3.7 Duplizieren von Filedeskriptoren – dup()<a id="Xxx999612" name="Xxx999612"></a> und dup2(<a id="RxxKap02002040000CC1F023214" name="RxxKap02002040000CC1F023214"></a>)<a id="Xxx999613" name="Xxx999613"></a> 
      <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999615" name="Xxx999615"></a>In manchen F&auml;llen wird es n&ouml;tig sein, dass Sie einen Filedeskriptor duplizieren m&uuml;ssen. Ein Beispiel hierf&uuml;r w&auml;re, wenn der Elternprozess mit einem Kindprozess Daten austauschen will und der Kindprozess durch einen neuen Prozess mit einer <span class="listing">exec*()</span>-Funktion &uuml;berlagert wird. In solch einem Fall, ohne <span class="listing">dup()</span> oder <span class="listing">dup2()</span>, w&uuml;rde das close-on-exec-Flag<a id="Xxx999617" name="Xxx999617"></a> gesetzt werden. Wird dieses Flag gesetzt, werden alle Filedeskriptoren ung&uuml;ltig (da vom neuen Prozess &uuml;berlagert) – sprich, sie sind nicht mehr vorhanden. Die Kommunikation zwischen dem Eltern- und Kindprozess w&auml;re hiermit auch beendet. Duplizieren Sie hingegeben mit <span class="listing">dup()</span> oder <span class="listing">dup2()</span> einen Filedeskriptor, wird das close-on-exec-Flag gel&ouml;scht, und der neu &uuml;berlagerte Prozess kann diese/n duplizierten Filedeskriptor/en zur Kommunikation verwenden. Mehr zum close-on-exec-Flag in K&uuml;rze. Sollte Ihnen das hier Beschriebene noch nicht so klar oder g&auml;nzlich unklar sein, ist dies noch nicht so wichtig. Mehr dazu finden Sie in den n&auml;chsten Kapiteln zu den Prozessen und den Interprozesskommunikationen.</p>
<p>F&uuml;r solche und eventuell weitere Anwendungsf&auml;lle stehen die Funktionen <span class="listing">dup()</span> und <span class="listing">dup2()</span> zur Verf&uuml;gung.</p>
<pre>#include &lt;unistd. h.&gt;
int dup(int fd);
int dup2(int fd, int fd2);</pre>
<p>Als Parameter wird der Funktion <span class="listing">dup()</span> der Filedeskriptor &uuml;bergeben, der dupliziert werden soll. Im Falle eines Erfolges erh&auml;lt man als R&uuml;ckgabewert die Nummer des Filedeskriptors, der nun auf dieselbe Datei verweist. Bei der Nummer handelt es sich um die kleinste nicht negative Zahl, die noch nicht f&uuml;r einen anderen Filedeskriptor vergeben wurde. Schl&auml;gt der Aufruf von <span class="listing">dup()</span> fehl, wird -1 zur&uuml;ckgegeben.</p>
<p>Beim Aufruf der Funktion <span class="listing">dup2()</span> hingegen wird der Wert des Zieldeskriptors als zweiter Parameter (<span class="listing">fd2</span>) angegeben. Wurde <span class="listing">fd2</span> bereits zuvor ge&ouml;ffnet, wird dieser zuvor noch geschlossen.</p>
<p>Bei beiden Funktionen zeigt der neu zur&uuml;ckgegebene Filedeskriptor auf denselben Dateitabelleneintrag, worin sich u. a. der Schreib-/Lesezeiger befindet. Somit kann man auf einen Deskriptor <span class="listing">lseek()</span> anwenden und danach von dem anderen (von der neuen Position) lesen.</p>
<p>Hierzu ein Anwendungsbeispiel der beiden Funktionen:</p>
<pre><a id="Xxx999624" name="Xxx999624"></a>/* dup_fd.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd. h.&gt;
static void test_write(const char *str) {
  write(STDOUT_FILENO, str, strlen(str));
  return;
}
int main(int argc, char **argv) {
  mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
  int fd1, fd2, fd3;
  // Alle Zugriffsrechte der Einschr&auml;nkungsmaske erlauben
  umask(0);
  fd1 = open("file1", O_WRONLY | O_CREAT, mode);
  fd2 = open("file2", O_WRONLY | O_CREAT, mode);
  if(fd1 == -1 || fd2 == -1) {
      perror("Fehler bei open()");
      return EXIT_FAILURE;
  }
  test_write("Zeile 1\n");
  dup2(fd1, STDOUT_FILENO);
  test_write("Zeile 2\n");
  dup2(fd2, STDOUT_FILENO);
  test_write("Zeile 3\n");
  test_write("Zeile 4\n");
  dup2(fd1, STDOUT_FILENO);
  test_write("Zeile 5\n");
  dup2(fd2, STDOUT_FILENO);
  test_write("Zeile 6\n");
  test_write("Zeile 7\n");
  close(fd1);
  close(fd2);
  fd3 = dup(STDERR_FILENO);
  write(fd3, "Schwerer Fehler ...\n",
      strlen("Schwerer Fehler ...\n"));
  return EXIT_SUCCESS;
}</pre>
<p>Und hier das Programm im Einsatz:</p>
<pre>$ gcc -o dup_fd dup_fd.c
$ ./dup_fd
Zeile 1
Schwerer Fehler ...
$ cat file1
Zeile 2
Zeile 5
$ cat file2
Zeile 3
Zeile 4
Zeile 6
Zeile 7</pre>
<p>In diesem Beispiel wurde vorwiegend der Filedeskriptor f&uuml;r die Standardausgabe dupliziert. Somit wurde die Standardausgabe jeweils in eine der beiden ge&ouml;ffneten Dateien umgeleitet. Am Ende wurde auch noch die Standardfehlerausgabe dupliziert, und mithilfe ihres Filedeskriptors wurde auch eine Ausgabe darauf gemacht.</p>
<a name="t38"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t39"></a><h3 class="t3">2.3.8 &Auml;ndern oder Abfragen der Eigenschaften eines Filedeskriptors – fcntl()<a id="RxxKap02002040000CC1F023220" name="RxxKap02002040000CC1F023220"></a><a id="Xxx999630" name="Xxx999630"></a> 
      <a href="#t2t310"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999631" name="Xxx999631"></a><a id="Xxx999632" name="Xxx999632"></a>Zum &Auml;ndern oder Abfragen einer offenen Datei k&ouml;nnen Sie die Funktion <span class="listing">fcntl()</span> verwenden. Damit lassen sich folgende Anwendungsbeispiele auf eine ge&ouml;ffnete Datei realisieren:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Setzen oder Abfragen der Flags im Dateitabelleneintrag</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Setzen oder Abfragen von Eintr&auml;gen in der Prozesstabelle</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Setzen oder Abfragen von Record Lockings (Sperren)</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Duplizieren von Filedeskriptoren</td>
</tr>
</table>
<p>Anhand dieser Aufz&auml;hlungspunkte wird klar, wie universell diese Funktion ist. Hierzu die Syntaxbeschreibung:</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;fcntl.h&gt;
int fcntl( int fd, int kommando ... );</pre>
<p>Als erstes Argument geben Sie den Filedeskriptor an, an dem Sie entsprechende Einstellungen oder Ver&auml;nderungen vornehmen wollen. Das zweite Argument ist das Kommando, was Sie mit dem entsprechenden Filedeskriptor anstellen wollen. Hierf&uuml;r gibt eine Reihe von symbolischen Konstanten, die anschlie&szlig;end ausf&uuml;hrlich beschrieben werden. Das dritte Argument wird nur dann ausgewertet, wenn Sie vorhaben, einen Filedeskriptor zu duplizieren oder wenn Sie die Einstellung einer offenen Datei ver&auml;ndern wollen. Der R&uuml;ckgabewert von <span class="listing">fcntl()</span> ist vom Kommando abh&auml;ngig, aber im Fehlerfall wird wie gew&ouml;hnlich -1 zur&uuml;ckgeliefert.</p>
<p>Jetzt wie versprochen zu den einzelnen Kommandos von <span class="listing">fcntl()</span> und deren Bedeutung und Anwendungsbeispiele.</p>
<h4 class="t4">F_DUPFD<a id="Xxx999642" name="Xxx999642"></a></h4>
<p><a id="Xxx999644" name="Xxx999644"></a>Verwenden Sie als Kommando <span class="listing">F_DUPFD</span>, so wird der Filedeskriptor <span class="listing">fd</span> dupliziert. Bei Erfolg liefert in diesem Fall die Funktion <span class="listing">fcntl()</span> den kleinstm&ouml;glichen positiven Wert des neuen Filedeskriptors zur&uuml;ck.</p>
<pre>int old_fd, new_fd;
new_fd = fcntl(fd, F_DUPFD, 0);</pre>
<p>Dieser neue Filedeskriptor besitzt denselben Dateitabelleneintrag wie <span class="listing">fd</span> (sprich hier <span class="listing">lseek()</span>, dort <span class="listing">read()</span>), verwendet aber innerhalb der Prozesstabelle einen eigenen Eintrag f&uuml;r die Filedeskriptor-Flags, wobei das close-on-exec-Bit gel&ouml;scht ist. Bei gel&ouml;schtem close-on-exec-Bit bleibt der Filedeskriptor auch bei einem <span class="listing">exec*()</span>-Aufruf bestehen. Dies ist &uuml;brigens dieselbe Funktionalit&auml;t wie beim Systemaufruf mit <span class="listing">dup2()</span>.</p>
<h4 class="t4">F_GETFD<a id="Xxx999648" name="Xxx999648"></a></h4>
<p>Mit <span class="listing">F_GETFD</span> k&ouml;nnen Sie &uuml;berpr&uuml;fen, ob das close-on-exec-Bit gesetzt ist oder nicht. Dies ist momentan auch das einzige Flag des Filedeskriptors, das Sie &uuml;berpr&uuml;fen k&ouml;nnen. Die symbolische Konstante dazu lautet <span class="listing">FD_CLOEXEC<a id="Xxx999651" name="Xxx999651"></a></span>. Ist das Flag gesetzt, liefert <span class="listing">fcntl()</span> als R&uuml;ckgabewert 1 zur&uuml;ck, ansonsten wird bei einem Fehler -1 und, wenn nicht gesetzt, 0 zur&uuml;ckgeliefert.</p>
<pre>if( fcntl ( fd, F_GETFD, FD_CLOEXEC ) == 1 ) {
    /* Close-on-exec-Flag ist gesetzt */
} else {
    /* nicht gesetzt */
}</pre>
<h4 class="t4">Close-on-exec-Flag<a id="Xxx999653" name="Xxx999653"></a></h4>
<p>Wenn das Flag nicht gesetzt ist (Standard), bleiben alle bereits ge&ouml;ffneten Filedeskriptoren bei einem durch einen <span class="listing">exec()</span>-Aufruf neu gestarteten Programm offen. Ist das Flag gesetzt, werden die entsprechenden Filedeskriptoren beim <span class="listing">exec()</span>-Aufruf geschlossen. Wenn z. B. ein privilegiertes Programm einen neuen Prozess erzeugt, sollten Sie aus sicherheitsrelevanten Gr&uuml;nden alle Filedeskriptoren – auch Verzeichnisse, IPC-Handles und Sockets – schlie&szlig;en. Um hierbei auf Nummer sicher zu gehen, sollten Sie das close-on-exec-Flag f&uuml;r die sicherheitsrelevanten Filedeskriptoren direkt nach dem &Ouml;ffnen setzen (nat&uuml;rlich mit Vorbehalt).</p>
<p>Weiterhin ist das close-on-exec-Flag sinnvoll f&uuml;r Anwendungen, die generell nicht wollen, dass ihre ge&ouml;ffneten Dateien nur irgendwie an Subprozesse weitergegeben werden. Als Beispiel hierf&uuml;r bietet sich der so genannte »PID-Lock« an, wo eine Datei in /var/run/name erstellt wird, die PID eingeschrieben wird und offen bleibt. F&uuml;hrt man besagtes Programm nochmals aus, so kann die zweite Instanz &uuml;berpr&uuml;fen, ob es /var/run/name gibt und, wenn ja, ob auch der Prozess mit der darin enthaltenen PID z. Z. l&auml;uft. Aber zur&uuml;ck zum Thema: Man m&ouml;chte i. d. R. nicht, dass eine Subshell oder sonstige Anwendungen durch <span class="listing">fork()</span> und/oder <span class="listing">exec()</span> diesen Lock umgehen, indem die Datei schon ge&ouml;ffnet ist.</p>
<h4 class="t4">F_SETFD<a id="Xxx999657" name="Xxx999657"></a></h4>
<p>Wie auch schon bei <span class="listing">F_GETFD</span>, k&ouml;nnen Sie mit <span class="listing">F_SETFD</span> die Filedeskriptor-Flags setzen. Als m&ouml;gliches drittes Argument kommen auch hier nur <span class="listing">FD_CLOEXEC</span> zum Setzen oder <span class="listing">!FD_CLOEXEC</span> zum L&ouml;schen des Flags in Frage.</p>
<pre>if(fcntl(fd, F_GETFD, FD_CLOEXEC) == 0) {
    // Close-on-exec ist nicht gesetzt
    if(fcntl(fd, F_SETFD, FD_CLOEXEC) &gt; 0) {
        // Close-on-exec wurde gesetzt
    }
}</pre>
<h4 class="t4">F_GETFL<a id="Xxx999661" name="Xxx999661"></a></h4>
<p>Mit dem Kommando <span class="listing">F_GETFL</span> k&ouml;nnen Sie die File Status Flags erfragen. Folgende Statusm&ouml;glichkeiten k&ouml;nnen Sie hierbei abfragen:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 2.7   
    </b>File Status Flags, die mit F_GETFL abgefragt werden k&ouml;nnen</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Modus</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung </b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_RDONLY
</td>
<td class="tabellentext" bgcolor="#000000">nur lesen 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_WRONLY
</td>
<td class="tabellentext" bgcolor="#000000">nur schreiben 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_RDWR
</td>
<td class="tabellentext" bgcolor="#000000">lesen und schreiben 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_APPEND
</td>
<td class="tabellentext" bgcolor="#000000">zum Schreiben ans Dateiende &ouml;ffnen 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_NONBLOCK
</td>
<td class="tabellentext" bgcolor="#000000">kein Blockieren bei FIFOs und Ger&auml;tedateien 
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_SYNC
</td>
<td class="tabellentext" bgcolor="#000000">nach jedem Schreiben auf die Beendigung des physikalischen Schreibvorgangs warten
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">O_ASYNC<a id="Xxx999694" name="Xxx999694"></a>
</td>
<td class="tabellentext" bgcolor="#000000">asynchroner I/O (nur bei Linux und BSD) – Gegenteil zu O_SYNC
</td>
</tr>
</table><br>
<p>Wenn Sie den R&uuml;ckgabewert von <span class="listing">F_GETFL</span> haben wollen, m&uuml;ssen Sie das mit <span class="listing">fcntl()</span> ermittelte Flag durch die symbolische Konstante <span class="listing">O_ACCMODE<a id="Xxx999707" name="Xxx999707"></a></span> filtern:</p>
<pre>flag  = fcntl(fd, F_GETFL, 0);
modus = flag &amp; O_ACCMODE;
if(modus == O_RDWR) {
// Mit diesem Filedeskriptor ist Lesen und Schreiben m&ouml;glich
} else if(modus == O_RDONLY) {
    // Mit diesem Filedeskriptor ist nur Lesen m&ouml;glich
} else if(modus == O_WRONLY) {
    // Mit diesem Filedeskriptor k&ouml;nnen Sie nur schreiben
}</pre>
<h4 class="t4">F_SETFL<a id="Xxx999709" name="Xxx999709"></a></h4>
<p>Mit diesem Kommando k&ouml;nnen Sie folgende File Status Flags mit dem dritten Argument von <span class="listing">fcntl()</span> setzen: <span class="listing">O_APPEND</span>, <span class="listing">O_NONBLOCK</span>, <span class="listing">O_SYNC</span>, <span class="listing">O_ASYNC</span>. Um eines dieser File Status Flags zu setzen, geht man wie folgt vor:</p>
<pre>if(fcntl(fd, F_SETFL, O_APPEND) &gt; 0) {
    // Filestatus-Flag O_APPEND gesetzt
} else {
    // Filestatus-Flag O_APPEND konnte nicht gesetzt werden
}</pre>
<h4 class="t4">F_GETOWN<a id="Xxx999713" name="Xxx999713"></a></h4>
<p>Hierbei liefert <span class="listing">fcntl()</span> die PID oder PGID des Prozesses, der im Augenblick die Signale<a id="Xxx999715" name="Xxx999715"></a><a id="Xxx999716" name="Xxx999716"></a> <span class="listing">SIGIO</span> und <span class="listing">SIGURG</span> empf&auml;ngt.</p>
<h4 class="t4">F_SETOWN<a id="Xxx999718" name="Xxx999718"></a></h4>
<p>Damit legen Sie mit dem dritten Argument die PID oder PGID des Prozesses fest, der die Signale <span class="listing">SIGIO</span> und <span class="listing">SIGURG</span> empf&auml;ngt. Ein positiver Wert legt die PID, ein negativer die GID fest.</p>
<p>Jetzt ist es an der Zeit, ein Listing zu erstellen, das Ihnen einige dieser Kommandos in ihrer Anwendung zeigen soll:</p>
<pre><a id="Xxx999722" name="Xxx999722"></a>/* play_fd.c */
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd. h.&gt;
int main(int argc, char **argv) {
  int fd, fdup;
  int flags, modus;
  if(argc &lt; 2) {
      fprintf(stderr, "Usage: %s DATEI\n", *argv);
      exit(EXIT_FAILURE);
  }
  if((fd = open(argv[1], O_RDONLY)) == -1) {
      fprintf(stderr, "Konnte %s nicht &ouml;ffnen!\n", argv[1]);
      exit(EXIT_FAILURE);
  }
  if((fdup = fcntl(fd, F_DUPFD, 0)) != -1)
      printf("Fildeskriptor erfolgreich dupliziert\n");
  /* Wir &uuml;berpr&uuml;fen die Flags von fd und setzen,
   * falls noch nicht gesetzt, FD_CLOEXEC. 
   */
  if((fcntl(fd, F_GETFD, FD_CLOEXEC)) == 1)
      printf("Close-on-exec-Bit ist gesetzt\n");
  else if((fcntl(fd, F_SETFD, FD_CLOEXEC)) &lt; 0)
      printf("Konnte close-on-exec-Bit nicht setzen\n");
  else
      printf("Close-on-exec-Bit wurde gesetzt\n");
  // Wir &uuml;berpr&uuml;fen die Filestatus-Flags von fd
  flags = fcntl(fd, F_GETFL, 0);
  modus = flags &amp; O_ACCMODE;
  if(modus == O_RDWR)
      printf("Datei zum Lesen und Schreiben ge&ouml;ffnet\n");
  else if(modus == O_RDONLY)
      printf("Datei nur zum Lesen ge&ouml;ffnet\n");
  else if(modus == O_WRONLY)
      printf("Datei nur zum Schreiben ge&ouml;ffnet\n");
  /* Wir &uuml;berpr&uuml;fen weitere Statusflags von fd und
   * &auml;ndern, falls n&ouml;tig, die Flags. 
   */
  if(modus == O_APPEND)
      printf("Wir k&ouml;nnen am Dateiende schreiben\n");
  modus |= O_APPEND;
  if(fcntl(fd, F_SETFL, modus) &lt; 0)
      printf("Konnte Attribut O_APPEND nicht setzen\n");
  if(modus == O_APPEND)
      printf("O_APPEND gesetzt\n");
  flags = fcntl(fd, F_GETFD, 0);
  modus = flags &amp; O_ACCMODE;
  if(modus == O_NONBLOCK) {
      printf("O_NONBLOCK gesetzt\n");
  } else {
      modus |= O_NONBLOCK;
      fcntl(fd, F_SETFL, modus);
      if(modus == O_NONBLOCK)
          printf("O_NONBLOCK erfolgreich gesetzt\n");
      else
          printf("Konnte O_NONBLOCK nicht setzen\n");
  }
  return EXIT_SUCCESS;
}</pre>
<p>So k&ouml;nnte die Ausgabe aussehen:</p>
<pre>$ gcc -o play_fd play_fd.c
$ ./play_fd test.txt
Filedeskriptor erfolgreich dupliziert
close-on-exec-Bit wurde gesetzt
Datei nur zum Lesen ge&ouml;ffnet
...O_APPEND gesetzt...
...konnte O_NONBLOCK nicht setzen...</pre>
<a name="t39"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t310"></a><h3 class="t3">2.3.9 Record Locking<a id="Xxx999726" name="Xxx999726"></a> – Sperren von Dateien einrichte<a id="RxxKap02002040000CC1F023259" name="RxxKap02002040000CC1F023259"></a>n 
      <a href="#t2t311"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t39"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999728" name="Xxx999728"></a>Wenn zwei oder mehrere Prozesse gleichzeitig auf eine Datei schreibend zugreifen wollen, f&uuml;hrt dies unwiderruflich zu Problemen. Meistens kann man dabei mit einem Datensalat rechnen. Ein einfaches Beispiel, das dieses Problem demonstriert:</p>
<pre><a id="Xxx999730" name="Xxx999730"></a>/* trash.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd. h.&gt;
int main(void) {
  int fd = open("file", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  pid_t pid;
  int x, y;
  if(fd == -1) {
      perror("open()");
      exit(EXIT_FAILURE);
  }
  if((pid = fork()) == -1) {
      perror("fork()");
      exit(EXIT_FAILURE);
  } else if(pid &gt; 0) { // Elternprozess
      srand(time(NULL) ^ getpid());
      for(x = 0; x &lt; 10; ++x) {
          usleep(rand() % 10 * 10000);
          write(fd, "x", 1);
          write(STDOUT_FILENO, "x", 1);
      }
      wait(NULL);
      printf("\n");
  } else { // Kindprozess
      srand(time(NULL) ^ getpid());
      for(y = 0; y &lt; 10; ++y){
          usleep(rand() % 10 * 10000);
          write(fd, "X", 1);
          write(STDOUT_FILENO, "X", 1);
      }
  }
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o trash trash.c
$ ./trash
$ cat file
XxxXxXxXxXXxXxxXxXxX</pre>
<p>Es ist vorerst gar nicht so wichtig, dass Sie die einzelnen Funktionen des Programms verstehen. Hierbei wird mit dem Systemaufruf <span class="listing">fork()</span> ein zweiter Prozess gestartet. Zu diesem Thema werden Sie sp&auml;ter noch eine Menge erfahren. Wichtig ist nur, dass hier zwei Prozesse gleichzeitig in die Datei <span class="listing">file</span> schreiben. Ein Prozess schreibt dabei kleine <span class="listing">x</span>-Buchstaben und der andere gro&szlig;e <span class="listing">X</span> in die Datei. Bei beiden Prozessen wurde eine Zeitverz&ouml;gerung mit <span class="listing">usleep()</span> eingebaut. An der Ausgabe der Datei <span class="listing">file</span> k&ouml;nnen Sie feststellen, dass hier weder Zucht noch Ordnung herrschte. Denn anstatt</p>
<pre>XxxXxXxXxXXxXxxXxXxX</pre>
<p>h&auml;tte die Datei <span class="listing">file</span> eigentlich folgenden Inhalt haben sollen:</p>
<pre>xxxxxxxxxxXXXXXXXXXX
//oder
XXXXXXXXXXxxxxxxxxxx</pre>
<p>Stellen Sie sich nun vor, dass w&auml;ren Daten in einer Datenbank gewesen! Um solche Inkonsistenzen in gemeinsam benutzten Dateien zu vermeiden, gibt es einen POSIX-Mechanismus namens Record Locking.</p>
<p>Mit einem solchen Record Lock ist es m&ouml;glich, einen beliebigen (zusammenh&auml;ngenden) Teil einer Datei (nat&uuml;rlich auch eine komplette Datei) zu blockieren. Dabei gibt es so genannte »Shared« und »Exclusive« Locks (Sperren).</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> S<a id="Xxx999740" name="Xxx999740"></a>hared Locks – Mehrere Prozesse sperren Teile einer oder der kompletten Datei und greifen z. B. auf gleiche Dateibereiche lesend zu. Erst wenn hierbei die letzte Sperre entfernt wurde, ist ein Exclusive Lock m&ouml;glich, beide Locking-Typen schlie&szlig;en sich somit aus.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Exclusive Locks – Ein Prozess sperrt einen Teil oder eine komplette Datei. Auf den nun gesperrten Bereich ist kein weiterer Lock mehr m&ouml;glich, der Prozess kann nun schreibend zugreifen.</td>
</tr>
</table>
<p>Sie haben generell zwei M&ouml;glichkeiten (Funktionen) zum Erstellen eines Dateilocks:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> fcntl()<a id="Xxx999745" name="Xxx999745"></a></span> – Dies ist ein BSD-konformer Lock-Mechanismus, der hier auch etwas umfangreicher behandelt wird.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> lockf()<a id="Xxx999747" name="Xxx999747"></a></span> – (SYSV- und POSIX-konform) Dies ist letztendlich eine einfache, aber h&auml;ufig ausreichende Schnittstelle zu <span class="listing">fcntl()</span>.</td>
</tr>
</table>
<h4 class="t4">Advisory Locking<a id="Xxx999749" name="Xxx999749"></a> und Mandatory Locking<a id="Xxx999750" name="Xxx999750"></a></h4>
<p>Alle eben benannten M&ouml;glichkeiten, eine Datei zu sperren, geh&ouml;ren zu den so genannten Advisory Locks (freiwilliges Sperrverfahren; advise = avisieren/benachrichtigen; hier beraten/vorschlagen). Bei diesem Sperrverfahren versucht jeder Prozess, vor dem Zugriff auf einen bestimmten Bereich einer Datei diesen zu sperren. Existiert f&uuml;r diesen Bereich bereits eine Sperre, scheitert der Versuch, die Sperre zu setzen. Der Prozess wartet dann, bis dieser gesperrte Bereich wieder freigegeben wird. Das hei&szlig;t auch, dass ein f&uuml;r die Datei bearbeitender Prozess selbstst&auml;ndig daf&uuml;r Sorge tragen muss, dass es f&uuml;r den Fall, dass er schreibend zugreifen will, keinerlei Locks auf diese Datei gibt. Solange sich der Programmierer bei der Erstellung an diesen Test h&auml;lt, sind alle anderen Aktionen der Programme auf die gesperrte(n) Datei(en) unproblematisch – sprich, diese Art von Sperren h&auml;ngen im gro&szlig;en Ma&szlig;e von der Disziplin des Programmierers ab.</p>
<p>Auf der anderen Seite gibt es noch das Mandatory Locking (verbindliches Sperrverfahren). Der Unterschied zum Advisory Locking ist, dass hier nach dem Setzen einer verbindlichen Sperre durch einen Prozess ein Zugriff durch einen anderen Prozess mittels <span class="listing">open()</span>, <span class="listing">read()</span> oder <span class="listing">write()</span> zu einem Fehler f&uuml;hrt. Mandatory Locking (auch als Kernel Locking bekannt) ist nat&uuml;rlich die ideale Alternative. Das Setzen einer solchen Sperre wird beim Mandatory Locking &uuml;ber ein spezielles Setzen des SGID-Bits (in der Kommandozeile mit <span class="listing">chmod</span> <span class="listing">g+s-x</span> <span class="listing">myfile</span>) der Dateiattribute realisiert. Das Mandatory Locking ist im Gegensatz zum Advisory Locking erheblich aufw&auml;ndiger und damit logischerweise auch langsamer. Das Mandatory Locking ist bei Linux-Versionen allerdings erst ab einer Kernel-Version von 2.3.x implementiert. Ebenfalls vorhanden ist dieses Sperrverfahren unter Sun OS 4.1.x, Solaris 2.x, HP-UX 9.x-11.x und IRIX 6.5.</p>
<h4 class="t4">Mandatory Locking<a id="Xxx999754" name="Xxx999754"></a> unter Linux verwenden</h4>
<p>Sofern Sie das anschlie&szlig;ende Beispiel unter Linux mit einem verbindlichen Sperrverfahren ausf&uuml;hren wollen, m&uuml;ssen Sie sicherstellen, dass hier das Mandatory-Attribut f&uuml;r die Partition aktiviert ist, in der sich die Datei befindet. Hierzu muss praktisch nur ein Eintrag in <span class="listing">/etc/fstab</span> ver&auml;ndert werden. In der vierten Spalte der entsprechenden Partition muss man nur die <span class="listing">mand</span>-Option einf&uuml;gen und dem Kommando <span class="listing">mount</span> direkt &uuml;bergeben. Z. B. sieht ein Eintrag bei mir wie folgt aus:</p>
<pre># mount
/dev/hda5 on / type ext2 (rw)</pre>
<p>&Auml;ndern Sie nun diese Zeile wie folgt um:</p>
<p><span class="listing">/dev/hda5</span> <span class="listing">on</span> <span class="listing">/</span> <span class="listing">type</span> <span class="listing">ext2</span> <span class="listing">(rw,mand)</span></p>
<p>Um diese &Auml;nderungen wirksam zu machen, m&uuml;ssen Sie diese Partition eventuell neu mounten (f&uuml;r die root-Partition wird eventuell die Option <span class="listing">-n</span> n&ouml;tig):</p>
<pre># mount -o remount /dev/hda5</pre>
<p>oder auch:</p>
<pre># mount / -o remount</pre>
<p>Dieser Zusatzaufwand sollte generell nur unter Linux n&ouml;tig sein, da viele andere Systeme dieses Locken schon von Haus aus unterst&uuml;tzen.</p>
<h4 class="t4">Sperren von Dateien mit fcntl()<a id="Xxx999765" name="Xxx999765"></a> einrichten</h4>
<p>Der Sinn von Sperren ist es ja, dass immer nur ein Prozess in eine Datei schreiben darf. Dies wird realisiert, indem eine Schreibsperre eingerichtet wird. Sobald der Schreibvorgang beendet wurde, sollte diese Schreibsperre auch wieder aufgehoben werden. All dies l&auml;sst sich mit der Funktion <span class="listing">fcntl()</span> realisieren, die zus&auml;tzlich als drittes Argument einen Zeiger auf die Struktur <span class="listing">flock</span> bekommt:</p>
<pre>int fcntl( int fd, int kommando, ...
          /* struct flock *flockzeiger */ );</pre>
<p>Die Struktur <span class="listing">flock</span> ist wie folgt aufgebaut:</p>
<pre>struct flock {
   short l_type;       /*  F_RDLCK (Lesesperre)           */
                       /*  F_WRLCK (Schreibsperre)        */
                       /*  F_UNLCK (Sperre aufheben)      */
   off_t l_start;      /*  relatives Offset in Byte,      */
                       /*  abh&auml;ngig von l_whence          */
   short l_whence      /*  SEEK_SET,SEEK_CUR,SEEK_END     */
   off_t l_len;        /*  Gr&ouml;&szlig;e der Speicherung in       */
                       /*  Bytes,0=Sperren bis Dateiende  */
   pid_t l_pid;        /*  wird bei F_GETLK zur&uuml;ckgegeben */
};  </pre>
<p>Der im <span class="listing">flock</span>-Record mit <span class="listing">l_type</span> &uuml;bergebene Locking-Typ ist somit immer entweder <span class="listing">   F_RDLCK</span> f&uuml;r Shared Locks oder <span class="listing">F_WRLCK</span> f&uuml;r Exclusive Locks. Wird versucht, auf eine bereits exklusiv gesperrte Datei einen weiteren Lock zu setzen, kann man durch den <span class="listing">open()</span>-Befehl selbst entscheiden, ob man auf das Ende des blockierenden Locks warten will oder den Befehl mit einem Fehler abbrechen m&ouml;chte (bei Advisory Locking).</p>
<p>Wollen Sie z. B. die ganze Datei zum Lesen oder Schreiben sperren, was in der Regel am h&auml;ufigsten zutreffen wird, m&uuml;ssen Sie die Strukturvariablen <span class="listing">l_start</span> und <span class="listing">l_whence</span> an den Anfang der Datei setzen:</p>
<pre>flockzeiger.l_start  = 0;
flockzeiger.l_whence = SEEK_SET;  </pre>
<p>Wenn Sie jetzt noch eine geregelte Sperre immer bis zum Dateiende haben wollen, m&uuml;ssen Sie nur die Strukturvariablen <span class="listing">l_len</span> auf 0 setzen, die f&uuml;r eine Sperre bis zum Dateiende steht:</p>
<pre>flockzeiger.l_len  = 0;  </pre>
<p>Die Datei ist somit immer bis zum Dateiende gesperrt, unabh&auml;ngig davon, ob jetzt neuer Inhalt am Ende angef&uuml;gt wurde.</p>
<p>Jetzt zu den m&ouml;glichen Angaben der Kommandos, die als zweites Argument an die Funktion <span class="listing">fcntl()</span> &uuml;bergeben werden.</p>
<h4 class="t4">F_GETLK<a id="Xxx999778" name="Xxx999778"></a></h4>
<p>Mit <span class="listing">F_GETLK</span> k&ouml;nnen Sie &uuml;berpr&uuml;fen, ob bereits eine Sperre f&uuml;r die Datei (an einer gewissen Position) spezifiziert wurde. Diese Einstellung wird mithilfe des Filedeskriptors und des Kommandos <span class="listing">F_GETLK</span> mit der Funktion <span class="listing">fcntl()</span> an eine Adresse vom Typ <span class="listing">struct</span> <span class="listing">flock</span> &uuml;bergeben. Anschlie&szlig;end k&ouml;nnen Sie die Strukturvariable <span class="listing">l_type</span> auf folgende symbolische Konstanten auswerten:</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter">
<p><span class="tabunter"><b>Tabelle 2.8   
    </b>Konstanten, mit denen die Strukturvariable l_type belegt sein kann</span></p>
</caption>
<tr>
<td class="tabellenkopf" bgcolor="#000000"><b>Konstante</b>
</td>
<td class="tabellenkopf" bgcolor="#000000"><b>Bedeutung</b>
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">F_UNLCK<a id="Xxx999787" name="Xxx999787"></a>
</td>
<td class="tabellentext" bgcolor="#000000">keine Sperre vorhanden
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">F_RDLCK<a id="Xxx999792" name="Xxx999792"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Lesesperre
</td>
</tr>
<tr>
<td class="tabellentext" bgcolor="#000000">F_WRLCK<a id="Xxx999797" name="Xxx999797"></a>
</td>
<td class="tabellentext" bgcolor="#000000">Schreibsperre
</td>
</tr>
</table><br>
<p>In der Praxis sieht das dann in etwa so aus:</p>
<pre>struct flock sperre = {
  .type = F_RDLCK, .start = 0, .whence = SEEK_SET, .len = 0
 };
fd = open(datei, O_CREAT | O_WRONLY, 0666);
// Sperre abfragen
fcntl(fd, F_GETLK, &amp;sperre);
// Abfrage auswerten
if(sperre.l_type == F_UNLCK) {
    // Datei nicht gesperrt
} else if(sperre.l_type == F_RDLCK) {
    // Lesesperre
} else if(sperre.l_type == F_WRLCK) {
    // Schreibsperre
}</pre>
<p>Anschlie&szlig;end werden Sie sehen, wie man mit <span class="listing">F_SETLK</span> Sperren setzen kann. Nat&uuml;rlich ist es auch m&ouml;glich, Sperren an verschiedenen Stellen zu positionieren. Um einen solchen Lock mit <span class="listing">F_GETLK</span> wiederzubekommen, geht man folgenderma&szlig;en vor: Man bereitet einen <span class="listing">struct</span> <span class="listing">flock</span> so vor, als ob dieser f&uuml;r <span class="listing">F_SETLK</span> verwendet werden soll (folgt gleich), d. h. inklusive <span class="listing">l_type</span>, <span class="listing">l_start</span> und <span class="listing">l_whence</span>, und gibt diese f&uuml;r <span class="listing">F_GETLK</span> an, womit nat&uuml;rlich gepr&uuml;ft wird, ob bei »<span class="listing">l_start</span>/<span class="listing">l_whence</span>« ein <span class="listing">l_type</span> vorliegt.</p>
<h4 class="t4">F_SETLK<a id="Xxx999812" name="Xxx999812"></a></h4>
<p>Mit dem Kommando <span class="listing">F_SETLK</span> k&ouml;nnen Sie eine Lese- oder Schreibsperre einrichten und auch wieder entfernen. Einrichten k&ouml;nnen Sie eine Sperre, indem Sie zuerst die Strukturvariablen von <span class="listing">flock</span> mit entsprechenden Werten initialisieren und anschlie&szlig;end als drittes Argument mit dem Funktionsaufruf <span class="listing">fcntl()</span> verwenden. Gelingt es nicht, eine Sperre einzurichten, bricht <span class="listing">fcntl()</span> ab und setzt die Fehlervariable <span class="listing">errno</span> auf <span class="listing">EACCES</span> oder <span class="listing">EAGAIN</span>.</p>
<p>In der Praxis sieht das Einrichten einer Sperre so aus:</p>
<pre>sperre.l_start  = 0;
sperre.l_whence = SEEK_SET;
sperre.l_len    = 0;
sperre.l_type   = F_RDLCK;
if(fcntl(fd, F_SETLK, &amp;sperre) == 0) {
    // Lesesperre gesetzt
}
sperre.l_start  = 0;
sperre.l_whence = SEEK_SET;
sperre.l_len    = 0;
sperre.l_type   = F_WRLCK;
if(fcntl(fd, F_SETLK, &amp;sperre) == 0) {
    // Lesesperre gesetzt
}
sperre.l_type = F_UNLCK;
if(fcntl(fd, F_SETLK, &amp;sperre) == 0) {
    // Sperre aufgehoben
}
/* Oder im C99-Stil: ------------------------ */
struct flock sperre = {
    .l_start  = 0,
    .l_whence = SEEK_SET,
    .l_len    = 0,
    .l_type   = F_RDLCK,
};
if(fcntl(fd, F_SETLK, &amp;sperre) == 0) {
    // Lesesperre gesetzt
}</pre>
<h4 class="t4">F_SETLKW<a id="Xxx999817" name="Xxx999817"></a></h4>
<p>Mit diesem Kommando wird der Prozess so lange suspendiert, bis er die geforderte Sperre einrichten kann. Es handelt sich hierbei um die blockierende Version des Kommandos <span class="listing">F_SETLK</span>.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Wenn Sie eine Datei mit einer Schreibsperre (<span class="listing">F_WRLCK</span>) versehen wollen, muss die Datei auch zum Schreiben ge&ouml;ffnet (<span class="listing">O_WRONLY</span> oder <span class="listing">O_RDWR</span>) werden. Und umgekehrt (<span class="listing">F_RDLCK</span>), wenn Sie einer Datei eine Lesesperre anh&auml;ngen wollen, muss diese auch im Lesemodus (<span class="listing">O_RDONLY</span> oder <span class="listing">O_RDWR</span>) ge&ouml;ffnet werden. Das bedeutet auch, dass Sie nie zwei unterschiedliche Sperrtypen auf ein bestimmtes Byte festlegen k&ouml;nnen.</p>
</td>
</tr>
</table><br>
<p>Hierzu jetzt ein Listing, das die Sperren in Dateien demonstriert. In diesem Beispiel wurden drei Funktionen geschrieben. Eine, die den Status (<span class="listing">status()</span>) der Sperre &uuml;berpr&uuml;ft, eine weitere, die eine Schreibsperre einrichtet (<span class="listing">locki()</span>), und noch eine dritte, welche die Schreibsperre wieder aufl&ouml;st (<span class="listing">unlock()</span>).</p>
<pre><a id="Xxx999825" name="Xxx999825"></a>/* sperre.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd. h.&gt;
#define FNAME "locki.lck"
static void status(struct flock *lock) {
  printf("Status: ");
  switch(lock-&gt;l_type) {
    case F_UNLCK:
      printf("F_UNLCK (Sperre aufgehoben)\n");
      break;
    case F_RDLCK:
      printf("F_RDLCK (PID: %d) (Lesesperre)\n",
         lock-&gt;l_pid);
      break;
    case F_WRLCK:
      printf("F_WRLCK (PID: %d) (Schreibsperre)\n", 
         lock-&gt;l_pid);
      break;
  }
}
static void unlock(int fd, struct flock *lock) {
    memset(lock, 0, sizeof(struct flock));
    lock-&gt;l_type = F_UNLCK; /* Sperre aufheben */
    if(fcntl(fd, F_SETLK, lock) &lt; 0)
        perror("Fehler: fcntl(fd, F_SETLK, F_UNLCK)");
    else
        status(lock);
}
static void locki(int fd, struct flock *lock) {
    memset(lock, 0, sizeof(struct flock));
    lock-&gt;l_type   = F_WRLCK;  // Schreibsperre
    lock-&gt;l_start  = 0;        // kein Offset
    lock-&gt;l_whence = SEEK_SET; // vom Anfang der Datei
    lock-&gt;l_len    = 0;        // bis zum Ende der Datei
    lock-&gt;l_pid    = getpid(); // Prozessnummer der Sperre
    if(fcntl(fd, F_SETLK, lock) &lt; 0)
        perror("Fehler: fcntl(fd, F_SETLK, F_WRLCK)");
    else
        status(lock);
}
int main(int argc, char **argv) {
    struct flock lock;
    char puffer[100];
    int fd, n;
    fd=open(FNAME, O_WRONLY | O_CREAT | O_APPEND, S_IRWXU);
    memset(&amp;lock, 0, sizeof(struct flock));
    fcntl(fd, F_GETLK, &amp;lock);
    status(&amp;lock);
    printf("\nEingabe machen: ");
    fflush(stdout);
    while((n = read(STDIN_FILENO, puffer, 100)) &gt; 1) {
        locki(fd, &amp;lock);
        write(fd, puffer, n);
        unlock(fd, &amp;lock);
    }
    close(fd);
    return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei seiner Ausf&uuml;hrung:</p>
<pre>$ gcc -o sperre sperre.c
$ ./sperre
Eingabe machen: Hallo Welt
F_WRLCK (pid: 1072) (Schreibsperre)
F_UNLCK (Sperre aufgehoben)
Hallo nochmals
F_WRLCK (pid: 1072) (Schreibsperre)
F_UNLCK (Sperre aufgehoben)
ENTER</pre>
<p>Entscheidend sind in diesem Listing folgende Zeilen:</p>
<pre>    while((n = read(STDIN_FILENO, puffer, 100)) &gt; 1) {
        locki(fd, &amp;lock);
        write(fd, puffer, n);
        unlock(fd, &amp;lock);
    }</pre>
<p>Nachdem die Daten mit <span class="listing">read()</span> eingelesen wurden, wird erst eine Schreibsperre mit <span class="listing">locki()</span> eingerichtet. Somit kann im Augenblick kein anderer Prozess auf die Datei <span class="listing">locki.lck</span> schreibend zugreifen. Im n&auml;chsten Schritt kann also mit <span class="listing">write()</span> in diese Datei geschrieben werden. Nach dem Schreibvorgang kann die Datei wieder mit <span class="listing">unlock()</span> zum Schreiben f&uuml;r andere Prozesse freigegeben werden. Um Ihnen die Sperre in der Ausf&uuml;hrung zu demonstrieren, bauen Sie jetzt nochmals am besten hinter der Funktion <span class="listing">write()</span> ein <span class="listing">getchar()</span> ein:</p>
<pre>        write(fd,puffer,n);
        getchar();</pre>
<p>&Uuml;bersetzen Sie das Programm, und starten Sie es jetzt erneut:</p>
<pre>$ gcc -o sperre sperre.c
$ ./sperre
Eingabe machen: Eine sinnvolle Zeile mehr in diesem Buch
F_WRLCK (pid: 1079) (Schreibsperre)</pre>
<p>Jetzt wartet das Programm wegen dem <span class="listing">getchar()</span> auf das Dr&uuml;cken der <b>(ENTER)</b>-Taste. Dem Wunsch kommen Sie jetzt nicht nach, sondern &ouml;ffnen eine weitere Konsole und starten das Programm erneut:</p>
<pre>$ ./sperre
Eingabe machen: Was einem so einf&auml;llt
Fehler bei : fcntl(fd, F_SETLK, F_WRLCK)(Permission denied)
ENTER
Fehler : fcntl(fd, F_SETLK, F_UNLCK)  (Permission denied)
$ cat &gt; locki.lck
Mal mit cat versuchen, in locki zu schreiben
cat: write error: Permission denied</pre>
<p>Sie sehen, dass Sie keinen Zugriff auf die Datei <span class="listing">locki.lck</span> haben, solange der Prozess mit der PID 1079 den Schreibschutz nicht aufhebt. Wechseln Sie also wieder in die andere Konsole, und dr&uuml;cken Sie <b>(ENTER)</b>. Jetzt wird der Schreibschutz wieder aufgehoben, und in die Datei <span class="listing">locki.lck</span> kann wieder geschrieben werden.</p>
<p>Das Programm ist nat&uuml;rlich wenig anwenderfreundlich, denn anstatt zu versuchen, einfach einen Schreibschutz zu verh&auml;ngen, sollten Sie in der Praxis schon zuvor den Status abfragen, bevor Sie irgendwelche Ma&szlig;nahmen treffen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Sofern Sie bei dem Beispiel nicht Mandatory Locking<a id="Xxx999841" name="Xxx999841"></a> verwendet haben, wurden mit den Advisory Locks schwache Sperren verwendet. Bei diesen schwachen Sperren findet keine &Uuml;berpr&uuml;fung statt, ob die Systemfunktionen <span class="listing">open()</span>, <span class="listing">read()</span> und <span class="listing">write()</span> bei Ihrer Ausf&uuml;hrung durch eine Sperre verhindert werden konnten. In diesem Fall liegt der weitere Programmablauf bez&uuml;glich der Sperren in Ihren H&auml;nden. </p>
</td>
</tr>
</table><br>
<p>Wollen Sie sich noch tiefgr&uuml;ndiger mit diesem Thema befassen, finden Sie auf der Buch-CD noch zwei Kapitel extra dazu. Und zwar: Sperren bis zum Dateiende und Deadlocks.</p>
<h4 class="t4">Record Locking – Sperren einrichten mit lockf()<a id="Xxx999845" name="Xxx999845"></a></h4>
<p>Eine etwas einfachere Methode als &uuml;ber <span class="listing">fcntl()</span> bietet die SYSV/POSIX-Funktion <span class="listing">lockf()</span>. Unter Linux ist <span class="listing">lockf()</span> zwar nur eine Schnittstelle zu <span class="listing">fcntl()</span>, aber der Standard gibt keine Relation zwischen den beiden vor. Mit <span class="listing">lockf()</span> ist es nicht m&ouml;glich (so sehe ich das), zwischen Read und Write Locks zu unterscheiden; hier gibt es nur einen Typ: »Exclusive Locks«. Mit diesen kann man Segmente einer Datei f&uuml;r einen Prozess exklusiv sperren, das funktioniert aber nur so lange, wie alle Prozesse, die auf die Datei zugreifen, <span class="listing">lockf()</span> bzw. Exclusive Locks verwenden. Ein kleines Anwendungsbeispiel:</p>
<pre>#include &lt;unistd. h.&gt;
lseek(fd, start, SEEK_SET);
lockf(fd, F_LOCK, 0);</pre>
<p>Wobei <span class="listing">start</span> den <span class="listing">flockzeiger.l_start</span> und die 0 den <span class="listing">flockzeiger.l_len</span> aus obigem <span class="listing">fcntl()</span>-Unterkapitel entspricht. Mehr dazu entnehmen Sie bitte aus der Manual Page.</p>
<a name="t310"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t311"></a><h3 class="t3">2.3.10 Multiplexing<a id="Xxx999850" name="Xxx999850"></a> E/A – select(<a id="RxxKap02002040000CC1F0232AF" name="RxxKap02002040000CC1F0232AF"></a>)<a id="Xxx999851" name="Xxx999851"></a> 
      <a href="#t2t312"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t310"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Manchmal ist es n&ouml;tig, mehrere offene Filedeskriptoren (Kan&auml;le) abzufragen, ob Daten angekommen sind. Ein normales <span class="listing">read()</span> w&uuml;rde in diesem Fall nicht funktionieren, da dies das Programm so lange blockieren w&uuml;rde, bis eine Eingabe gelesen wurde. Sie k&ouml;nnten zwar <span class="listing">read()</span> im nicht blockierenden Modus (<span class="listing">O_NONBLOCK<a id="Xxx999854" name="Xxx999854"></a></span>) aufrufen und jeden Filedeskriptor einzeln &uuml;berpr&uuml;fen, ob Daten eingetroffen sind (was i. d. R. sehr CPU-intensiv ist), oder aber Sie verwenden die Funktion <span class="listing">select()</span>, die extra dazu konzipiert wurde.</p>
<p>Ein Beispiel in der Praxis w&auml;re ein Server, der mehrere Verbindungsendpunkte &uuml;ber ein FIFO oder eine named pipe gleichzeitig bedienen soll – oder gar ein Webserver, wie dieser im Kapitel zur Netzwerkprogrammierung auch erstellt wird. W&uuml;rden Sie hier z. B. blockierende Funktionen verwenden, kann es recht ineffizient sein und ein wenig dauern, bis Daten eintreffen. Und was ist mit den Verbindungsendpunkten (Filedeskriptoren), an denen schon l&auml;ngst Daten angekommen sind?</p>
<p>Hierzu die Syntax der Funktion <span class="listing">select()</span> und die dazugeh&ouml;renden Makros:</p>
<pre>#include &lt;sys/select.h&gt;
int select(int mp_fd, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
FD_CLR(int fd, fd_set *set)<a id="Xxx999858" name="Xxx999858"></a>;
FD_ISSET<a id="Xxx999859" name="Xxx999859"></a>(int fd, fd_set *set);
FD_SET<a id="Xxx999860" name="Xxx999860"></a>(int fd, fd_set *set);
FD_ZERO<a id="Xxx999861" name="Xxx999861"></a>(fd_set *set);</pre>
<p>Die Funktion <span class="listing">select()</span> wartet bei einer Reihe von Filedeskriptoren darauf, dass sich der Zustand von mindestens einem &auml;ndert. Dabei wird zwischen drei unabh&auml;ngigen Mengen von Filedeskriptoren unterschieden:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left">  <span class="listing">readfds</span> – Es wird gepr&uuml;ft, ob Zeichen zum Lesen angekommen sind.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left">  <span class="listing">writefds</span> – Es wird gepr&uuml;ft, ob Zeichen geschrieben werden k&ouml;nnen.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> exceptfds</span> – Es wird gepr&uuml;ft, ob ein au&szlig;ergew&ouml;hliches Ereignis vorgekommen ist.</td>
</tr>
</table>
<p>Die Makros werden zur Bearbeitung der drei Mengen verwendet. Vor jedem Aufruf von <span class="listing">select()</span> muss die Menge mit <span class="listing">FD_ZERO()</span> gel&ouml;scht werden. Einen Filedeskriptor zur Menge k&ouml;nnen Sie mit <span class="listing">FD_SET()</span> hinzuf&uuml;gen und mit <span class="listing">FD_CLR()</span>entfernen.</p>
<p>Nachdem Sie alle zu &uuml;berwachenden Deskriptoren den gew&uuml;nschten Mengen hinzugef&uuml;gt haben, k&ouml;nnen Sie die Funktion <span class="listing">select()</span> aufrufen. Diese &auml;ndert die Mengen, so dass nur noch die Deskriptoren darin vorhanden sind, von denen entweder gelesen oder zu denen geschrieben werden kann bzw. wo etwas passiert ist. Wollen Sie wissen, ob ein Deskriptor noch in der Menge vorhanden ist, k&ouml;nnen Sie dies mit dem Makro <span class="listing">FD_ISSET()</span> abfragen.</p>
<p>Neben den Mengen werden zwei weitere Parameter an <span class="listing">select()</span> &uuml;bergeben:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> n</span> – Hier geben Sie die h&ouml;chste Nummer (plus 1) des in der Menge vorhandenen Filedeskriptors an. Dabei sind alle drei Mengen gemeint. Es schadet nicht, eine h&ouml;here Nummer anzugeben (z. B. gleich <span class="listing">OPEN_MAX<a id="Xxx999870" name="Xxx999870"></a></span>), jedoch braucht der Kernel ein paar Ticks l&auml;nger, um die gr&ouml;&szlig;ere Anzahl an Deskriptoren zu &uuml;berpr&uuml;fen. Verfallen Sie daher nicht darauf, nur <span class="listing">OPEN_MAX</span> zu verwenden.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"><span class="listing"> timeout</span> – Damit geben Sie an, wie lange <span class="listing">select()</span> warten soll, bis sich einer der Deskriptoren geregt hat. Geben Sie hierbei <span class="listing">NULL</span> an, blockiert <span class="listing">select()</span> so lange, bis dies passiert ist. Geben Sie f&uuml;r beide Werte der Struktur <span class="listing">timeval</span> 0 an, kehrt <span class="listing">select()</span> nach dem &Uuml;berpr&uuml;fen aller vorhandenen Filedeskriptoren sofort wieder zur&uuml;ck. Hiermit wird praktisch echtes Polling ohne Blockieren erreicht. Die dritte M&ouml;glichkeit ist gegeben, wenn Sie eine oder beide Strukturvariablen mit einem Wert initialisieren. <span class="listing">select()</span> kehrt dann zur&uuml;ck, wenn die mit <span class="listing">timeout</span> angegebene Zeit abgelaufen ist oder wenn ein Filedeskriptor aus der Menge bereit f&uuml;r eine Ein-/Ausgabe ist (oder <span class="listing">select()</span> durch ein Signal unterbrochen wurde).</td>
</tr>
</table>
<p>Bei Erfolg gibt <span class="listing">select()</span> die Anzahl der Filedeskriptoren zur&uuml;ck, deren Status sich ge&auml;ndert hat. Wenn ein Fehler aufgetreten ist, wird -1 zur&uuml;ckgegeben und <span class="listing">errno</span> entsprechend gesetzt. Die Mengen und <span class="listing">timeout</span> befinden sich dann in einem undefinierten Zustand (sind z. B. nur teilweise gef&uuml;llt), auf deren Inhalt sollte man sich also bei einem Fehler nicht mehr verlassen. (<span class="listing">timeout</span> soll nach <span class="listing">select()</span> bis zu einer potenziellen Wiederbelegung f&uuml;r den n&auml;chsten <span class="listing">select()</span>-Aufruf nicht mehr gelesen werden. Siehe Manual –Page.) Wird hingegen 0 zur&uuml;ckgegeben, bedeutet dies, dass kein Filedeskriptor f&uuml;r die Ein-/Ausgabe bereit ist. 0 tritt auch auf, wenn der Timeout abgelaufen ist, bevor ein Filedeskriptor bereit war.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Bei richtiger Anwendung kann mit der Funktion <span class="listing">select()</span> ein einfaches Multiplexing erzeugt werden. Dies ist ansonsten nur m&ouml;glich, wenn man noch weitere Prozesse (mit <span class="listing">fork()</span>) oder Threads startet.</p>
</td>
</tr>
</table><br>
<p>Ein tiefgr&uuml;ndiges Listing hierzu w&uuml;rde dem Leser, der noch nicht mit dem Thema vertraut ist, bis zum jetzigen Kapitel ein wenig zu viel abverlangen. Hierauf wird im Kapitel der Netzwerkprogrammierung noch eingegangen. Das folgende Beispiel demonstriert, wie Sie die Standardeingabe »pollen« k&ouml;nnen. Dabei blockiert <span class="listing">select()</span> so lange, bis Sie (nach einer Eingabe) die <b>(ENTER)</b>-Taste gedr&uuml;ckt haben. Wenn die <b>(ENTER)</b>-Taste nicht binnen f&uuml;nf Sekunden gedr&uuml;ckt wurde, bricht der eingerichtete Timeout <span class="listing">select()</span> ab. Hier das Listing:</p>
<pre><a id="Xxx999878" name="Xxx999878"></a>/* poll_stdin_time.c */
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
static int poll_stdin_time(int sekunden) {
  struct timeval timeout;
  fd_set read_fds;
  FD_ZERO(&amp;read_fds);
  FD_SET(STDIN_FILENO, &amp;read_fds);
  timeout.tv_sec = sekunden;
  timeout.tv_usec = 0;
  return select( STDIN_FILENO + 1, &amp;read_fds, NULL,
                 NULL, &amp;timeout );
}
/* oder im C99-Standard:
static int poll_stdin_time(int sekunden) {
  struct timeval timeout={.tv_sec = sekunden, .tv_usec = 0};
  fd_set read_fds;
  FD_ZERO(&amp;read_fds);
  FD_SET(STDIN_FILENO, &amp;read_fds);
  return select( STDIN_FILENO + 1, &amp;read_fds, NULL,
                 NULL, &amp;timeout );
}
*/
int main(void) {
    int ret;
    printf("Warte 5 Sek. auf Eingabe (ENTER-Taste)!\n");
    ret = poll_stdin_time(5);
    if(ret == 0)
       printf("Zeit abgelaufen\n");
    else if(ret == 1)
       printf("Danke!!!\n");
    else
       perror("select()");
    return 0;
}</pre>
<p>Das Listing bei der Ausf&uuml;hrung:</p>
<pre>$ gcc -o poll_stdin_time poll_stdin_time.c
$ ./poll_stdin_time
Warte 5 Sek. auf Eingabe (ENTER-Taste)!
ENTER
Danke!!!
$ ./poll_stdin_time
Zeit abgelaufen</pre>
<a name="t311"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t312"></a><h3 class="t3">2.3.11 Unterschiedliche Operationen – ioctl()<a id="RxxKap02002040000CC1F0232C4" name="RxxKap02002040000CC1F0232C4"></a> 
      <a href="#t2t313"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t311"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999883" name="Xxx999883"></a>Der <span class="listing">ioctl()</span>-Systemaufruf ist eine Funktion, die f&uuml;r viele Arten von E/A-Operationen (und nicht nur daf&uuml;r) einsetzbar ist. Hier die Syntax dazu:</p>
<pre>#include &lt;unistd. h.&gt;     /* SVR4       */
#include &lt;sys/ioctl.h&gt;  /* Linux, BSD */
int ioctl( int fd, int operation ...);</pre>
<p>Als erstes Argument geben Sie den Filedeskriptor an, auf den die Operation durchgef&uuml;hrt werden soll, die als zweites Argument angegeben wird. Schl&auml;gt der Systemaufruf fehl, gibt <span class="listing">ioctl()</span> den Wert -1 zur&uuml;ck. Zu den wirklich unz&auml;hlig vielen Operationen m&ouml;chte ich Sie vorerst auf die Man-Pages (ioctl_list(2)) verweisen. Auf die Funktion <span class="listing">ioctl()</span> wird noch intensiver im Kapitel zu den Devices eingegangen.</p>
<p>Sie k&ouml;nnen mit dieser Funktion praktisch auf einfachste Weise auf die Hardware im System zugreifen, ohne direkt auf Hardware-Ebene programmieren zu m&uuml;ssen. Hierzu ein einfaches Beispiel, das demonstriert, wie Sie auf Ihr CD-ROM-Laufwerk zugreifen und die CD auswerfen (Eject) k&ouml;nnen.</p>
<pre><a id="Xxx999888" name="Xxx999888"></a>/* openCD.c */
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd. h.&gt;
#include &lt;linux/cdrom.h&gt;
/* Bitte anpassen, falls notwendig */
#define CDROM "/dev/cdrom"
int main(int argc, char **argv) {
    int fd, rc;
    if((fd = open(CDROM, O_RDONLY)) &lt; 0) {
        fprintf(stderr, "Konnte %s nicht &ouml;ffnen\n",CDROM);
        return 1;
    }
    if((rc = ioctl(fd, CDROMEJECT)) != 0) {
      perror("Konnte CD-ROM nicht auswerfen\n");
      return 1;
    }
    close(fd);
    return 0;
}</pre>
<p>Im Beispiel wird davon ausgegangen, dass sich das CD-ROM-Laufwerk an einem IDE-Anschluss befindet (<span class="listing">/dev/hdc</span> ). Sofern Sie &uuml;ber einen SCSI- oder sonstigen Anschluss das CD-ROM-Laufwerk betreiben, passen Sie die symbolische Konstante bitte Ihren Bed&uuml;rfnissen an.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b><span class="listing">ioctl()</span> ist nur Bestandteil von SVR4 und BSD, nicht aber von POSIX.1.</p>
</td>
</tr>
</table><br>
<a name="t312"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t313"></a><h3 class="t3">2.3.12 Lesen und Schreiben mehrerer Puffer – writev()<a id="Xxx999895" name="Xxx999895"></a> und readv(<a id="RxxKap02002040000CC1F0232CD" name="RxxKap02002040000CC1F0232CD"></a>)<a id="Xxx999896" name="Xxx999896"></a> 
      <a href="#t2t314"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t312"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999898" name="Xxx999898"></a><a id="Xxx999899" name="Xxx999899"></a>Spezielle Lese- und Schreibfunktionen stehen Ihnen mit den POSIX-Funktionen <span class="listing">readv()</span> und <span class="listing">writev()</span> zur Verf&uuml;gung. Mit diesen Funktionen ist es m&ouml;glich, mehrere nicht zusammenh&auml;ngende Puffer auf einmal zu schreiben oder zu lesen. Es liegt somit auf der Hand, dass ein einzelner <span class="listing">writev()</span>- oder <span class="listing">readv()</span>-Aufruf wesentlich schneller ist als zwei oder mehrere <span class="listing">write()</span>- oder <span class="listing">read()</span>-Aufrufe.</p>
<p>Das Prinzip dieser Funktion ist recht einfach und w&uuml;rde sich auch relativ leicht selbst nachbilden lassen. Beim Lesen mit <span class="listing">writev()</span> werden Daten in einem speziellen Puffer (genauer in der Struktur <span class="listing">iovec</span>) gesammelt und dann mit einem Rutsch mit <span class="listing">writev()</span> in eine Datei geschrieben.</p>
<p>&Auml;hnlich ist dies auch bei der Funktion <span class="listing">readv()</span>. Hierbei werden die einzelnen Daten aus einer Datei gelesen und nacheinander auf die einzelnen Puffer verteilt. Hierzu die Syntax dieser beiden Funktionen:</p>
<pre>#include &lt;sys/uio.h&gt;
ssize_t readv( int fd, const struct iovec *iov, 
               int anz_iov );
ssize_t writev( int fd, const struct iovec *iov,
                int anz_iov );</pre>
<p>Als erstes Argument &uuml;bergeben Sie diesen Funktionen einen ge&ouml;ffneten Filedeskriptor. Das zweite Argument ist die Adresse eines Arrays, genauer eines Strukturarrays mit dem Datentyp <span class="listing">struct</span> <span class="listing">iovec</span>, der wie folgt aussieht:</p>
<pre>struct iovec {
    void *iov_base; // Anfangsadresse des Puffers
    size_t iov_len; // L&auml;nge des Puffers
};</pre>
<p>Mit dieser Struktur ist es dann m&ouml;glich, Daten unterschiedlichen Typs (da <span class="listing">void*</span>) und L&auml;nge auf einmal zu schreiben bzw. zu lesen.</p>
<p>Beide Funktionen geben die Anzahl erfolgreich gelesener bzw. geschriebener Bytes zur&uuml;ck. Bei einem Fehler wird -1 zur&uuml;ckgeliefert. Erreicht <span class="listing">readv()</span> das Dateiende oder sind keine Daten mehr zum Lesen vorhanden, wird 0 zur&uuml;ckgegeben.</p>
<p>Hierzu ein einfaches Beispiel, das demonstriert, wie Sie den Puffer mit Daten f&uuml;llen und auf einmal in eine Datei schreiben k&ouml;nnen.</p>
<pre><a id="Xxx999909" name="Xxx999909"></a>/* write_vec.c */
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd. h.&gt;
#define MAX 3 // Anzahl der Elemente
int main(int argc, char **argv) {
  mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
  const char *str[] = {"Ein Teststring\n", "Noch einer\n",
    "Der Letzte im Bunde\n"};
  struct iovec vec[MAX];
  ssize_t length = 0;
  int fd, i;
   
  //unlink("test");
  umask(0);  
  fd = open("test", O_WRONLY | O_CREAT | O_EXCL, mode);
  if(fd == -1) {
      perror("open()");
      return EXIT_FAILURE;
  }
  // Einzelne Daten in die Struktur legen
  for(i = 0; i &lt; MAX; ++i) {
      vec[i].iov_base = (void *)str[i];
      vec[i].iov_len  = strlen(str[i]);
      length += strlen(str[i]);
  }
  // Jetzt in die Datei schreiben
  if(writev(fd, vec, MAX) != length) {
      perror("writev()");
      return EXIT_FAILURE;
  }
  close(fd);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei seiner Ausf&uuml;hrung:</p>
<pre>$ gcc -o write_vec write_vec.c
$ ./write_vec
$ cat test
Ein Teststring
Noch einer
Der Letzte im Bunde</pre>
<a name="t313"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing"></a></div><a name="t2t314"></a><h3 class="t3">2.3.13 &Uuml;bersicht zu weiteren Funktionen, die den Filedeskriptor verwenden<a id="RxxKap02002040000CC1F0232DA" name="RxxKap02002040000CC1F0232DA"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t313"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Die Low-Level-Funktionen im Kapitel zuvor wurden zwar schon recht flott durchgenommen, aber jetzt ist es an der Zeit, noch ein wenig mehr auf das Gaspedal zu treten. Die wichtigsten kennen Sie jetzt zumindest ansatzweise und wissen, wozu diese zu verwenden sind – was auch zur Voraussetzung der weiteren Kapitel n&ouml;tig ist. Aber schlie&szlig;lich wollen Sie noch mehr lernen, als nur die trockene Theorie zu pauken. Au&szlig;erdem hat Linux noch eine ganze Menge mehr zu bieten.</p>
<h4 class="t4">fsync()<a id="Xxx999915" name="Xxx999915"></a></h4>
<p>Verwenden Sie beim Systemaufruf <span class="listing">open()</span> das Flag <span class="listing">O_SYNC</span>, wird bei jedem Schreiben aller sich noch in Puffercaches befindlichen Daten auf die Beendigung des Schreibvorgangs gewartet. Gleiches gilt f&uuml;r nachtr&auml;gliches Setzen des Flags <span class="listing">O_SYNC<a id="Xxx999918" name="Xxx999918"></a></span> mit <span class="listing">fcntl()</span>. Wollen Sie allerdings nicht, dass auf jeden Schreibvorgang gewartet wird, sondern nur dann, wenn Sie es wollen (z. B. bei extrem kritischen Daten), k&ouml;nnen Sie die Funktion <span class="listing">fsync()</span> verwenden. Damit wird nur zum Zeitpunkt des Aufrufs einmal so verfahren, vorausgesetzt, Sie haben die Datei nicht im <span class="listing">O_SYNC</span>-Modus ge&ouml;ffnet. Hierzu die Syntax der Funktion:</p>
<pre>#include &lt;unistd. h.&gt;
int fsync(int fd) ;</pre>
<p>Die Funktion <span class="listing">fsync()</span> ben&ouml;tigt als Argument den Filedeskriptor, auf dem die Aktion ausgef&uuml;hrt werden soll. Ist der Aufruf erfolgreich, wird 0 zur&uuml;ckgegeben, ansonsten bei einem Fehler -1.</p>
<h4 class="t4">ftruncate()<a id="Xxx999921" name="Xxx999921"></a></h4>
<p><a id="Xxx999923" name="Xxx999923"></a>Um eine Datei zu beschneiden, steht Ihnen die Funktion <span class="listing">ftruncat()</span> zur Verf&uuml;gung.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;unistd. h.&gt;
int ftruncate( int fd, off_t cut );</pre>
<p>Damit wird die Datei mit dem Filedeskriptor auf <span class="listing">cut</span> Bytes beschnitten. Hat die Datei mehr als <span class="listing">cut</span> Bytes, wird diese Datei gek&uuml;rzt. Der Rest der Datei ist somit nicht mehr verf&uuml;gbar. Hat die Datei weniger als <span class="listing">cut</span> Bytes, ist das Verhalten systemabh&auml;ngig. In SVR4 z. B. wird die Datei um <span class="listing">cut</span> Bytes verl&auml;ngert. Bei BSD hingegen passiert in diesem Fall gar nichts. Linux f&uuml;llt die Datei mit Null-Bytes auf (also &auml;hnlich wie bei SVR4), jedoch beansprucht eine solch erweiterte Datei (noch) keinen weiteren Festplattenplatz:</p>
<pre>ftruncate(fd, 1048576 * 100);</pre>
<p>Angenommen, man w&uuml;rde eine Datei unter 100 MB mit diesem Befehl bearbeiten, so w&uuml;rde »ls« die 100 MB anzeigen, »du« jedoch immer noch den tats&auml;chlichen verbrauchten Platz. Dies ist m&ouml;glich, da per Definition ein Erweitern &uuml;ber <span class="listing">ftruncate()</span> mit Null-Bytes gepaddet wird. Da Sie dies wissen, k&ouml;nnen Sie diese Bytes auch einsparen, bis sie mit etwas anderem gef&uuml;llt werden. Diese Technik nennt sich »Sparse Files« (die einzige M&ouml;glichkeit, eine »478-GB«-Datei auf einem 20-GB-Datentr&auml;ger anzulegen). Dabei k&ouml;nnen solche »L&uuml;cken« nicht nur am Dateiende existieren, z. B. durch:</p>
<pre>/* fangen wir mit irgendeiner 0-bytigen Datei an */
ftruncate(fd, 0);
ftruncate(fd, 1048576 * 100);
lseek(fd, 1048576, SEEK_SET);
putc('x', fd);</pre>
<p>Somit h&auml;tten Sie von 0–1048575 und von 1048577 (in Wirklichkeit 1048576 + ein bisschen weiter) bis zum Dateiende eine L&uuml;cke.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Oben genannte 478 GB sind nat&uuml;rlich Wahnsinn und sollten allein dem Zweck dienen, die Funktionalit&auml;t von <span class="listing">ftruncate()</span> zu erl&auml;utern. Kids, don't do this at home, denn auch eine Datei von tats&auml;chlicher Gr&ouml;&szlig;e 0 belegt ein paar administrative Inodes, die beim L&ouml;schen erst durchsucht und analysiert werden m&uuml;ssen.</p>
</td>
</tr>
</table><br>
<p>Bei einem Fehler liefert diese Funktion -1 und bei Erfolg 0 zur&uuml;ck.</p>
<p>Der Aufruf der Funktion im Stile</p>
<pre>ftruncate(fd , 0);</pre>
<p>kommt einem Aufruf der Funktion <span class="listing">open()</span> mit dem Flag <span class="listing">O_TRUNC<a id="Xxx999938" name="Xxx999938"></a></span> gleich. In beiden F&auml;llen wird der Inhalt der Datei gel&ouml;scht. <span class="listing">ftruncate()</span> ist jedoch vorzuziehen, wenn die Datei nur einmal ge&ouml;ffnet werden kann (z. B. aus speziellen Locking-Gr&uuml;nden oder Race Conditions).</p>
<p>Mit Race Conditions ist z. B. gemeint, wenn man ein Ger&auml;t (wie /dev/dsp) nur einmal &ouml;ffnen kann (gilt nur f&uuml;r OSS, nicht ALSA), man es aber nicht riskieren kann, den <span class="listing">fd</span> zu verlieren, weil andere potenzielle Anwendungen <span class="listing">open()</span>versuchen.</p>
<h4 class="t4">truncate()<a id="Xxx999941" name="Xxx999941"></a></h4>
<p>Nebst <span class="listing">ftruncate()</span> gibt es auch noch <span class="listing">truncate()</span>, das als ersten Parameter statt eines Deskriptors einen Dateinamen erwartet.</p>
<h4 class="t4">fstat() und fchmod(), chmod()</h4>
<p>Das Erfragen von Dateiattributen k&ouml;nnen Sie mit der Funktion <span class="listing">fstat()<a id="Xxx999945" name="Xxx999945"></a></span> realisieren. Die Funktion wird in einem extra vorgesehenen Kapitel (Kapitel 3) behandelt. Es wird dann zwar die Version der h&ouml;heren Ebene verwendet, aber au&szlig;er dem ersten Argument, was bei der niedrigeren Ebene ein Filedeskriptor und bei der h&ouml;heren Ebene ein Pfadname ist, besteht dabei kein Unterschied. Hierzu die Syntax der Funktion:</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
int fstat(int fd, struct stat *sb);</pre>
<p>Verlief der Funktionsaufruf erfolgreich, wird 0, ansonsten bei einem Fehler -1 zur&uuml;ckgegeben.</p>
<p><a id="Xxx999949" name="Xxx999949"></a>Um die Zugriffsrechte einer Datei zu &auml;ndern, stehen Ihnen die Funktionen <span class="listing">fchmod()<a id="Xxx999950" name="Xxx999950"></a></span> und <span class="listing">chmod()<a id="Xxx999952" name="Xxx999952"></a></span> zur Verf&uuml;gung.</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
int fchmod(int fd, mode_t mode);
int chmod(const char *name, mode_t mode);</pre>
<p>Damit &auml;ndern Sie die Zugriffsrechte auf dem offenen Filedeskriptor, die Sie mit <span class="listing">mode</span> angeben. Dabei k&ouml;nnen Sie zum Ver&auml;ndern der Zugriffsrechte dieselben Konstanten und dieselbe Vorgehensweise verwenden, die Sie bereits bei der Funktion <span class="listing">open()</span> (Abs. 2.3.1) kennen gelernt haben. Beim erfolgreichen Ver&auml;ndern der Rechte wird 0, ansonsten bei einem Fehler -1 zur&uuml;ckgegeben. <span class="listing">chmod()</span> funktioniert genauso wie <span class="listing">fchmod()</span>, nur wird als erstes Argument der Dateiname (eventuell mitsamt Pfad) anstatt eines Filedeskriptors angegeben.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Nat&uuml;rlich d&uuml;rfen echte <span class="listing">chmod</span>’er anstatt der symbolischen Konstanten auch die oktale Version der Zugriffsrechte verwenden, z. B.: <span class="listing">fchmod(fd,</span> <span class="listing">0644)</span></p>
</td>
</tr>
</table><br>
<h4 class="t4">fileno()<a id="Xxx999959" name="Xxx999959"></a></h4>
<p>Ben&ouml;tigen Sie zu einem offenen <span class="listing">FILE</span>-Stream einen Filedeskriptor, k&ouml;nnen Sie die Funktion <span class="listing">fileno()</span> verwenden:</p>
<pre>#include &lt;stdio.h&gt;
int fileno(FILE *fp);</pre>
<p>Bei erfolgreicher Ausf&uuml;hrung von <span class="listing">fileno()</span> erhalten Sie den Integer-Filedeskriptor zum Stream. <span class="listing">fp</span>. <span class="listing">fileno()</span> ist z. B. erforderlich, falls eine Datei mit <span class="listing">fopen()</span> ge&ouml;ffnet wurde, um den Stream f&uuml;r Funktionen einzusetzen, die einen Filedeskriptor ben&ouml;tigen.</p>
<p>Bei <span class="listing">fileno()</span> handelt es sich nat&uuml;rlich um eine Funktion der h&ouml;heren Ebene (High Level).</p>
<h4 class="t4">fdopen()<a id="Xxx999965" name="Xxx999965"></a></h4>
<p>Die Funktion <span class="listing">fdopen()</span> ist das Gegenst&uuml;ck der Funktion <span class="listing">fileno()</span>. Damit erhalten Sie aus einem ge&ouml;ffneten Filedeskriptor einen <span class="listing">FILE</span>-Stream. Die Syntax hierzu:</p>
<pre>#include &lt;stdio.h&gt;
FILE *fdopen(int fd, const char *modus);</pre>
<p>Als <span class="listing">modus</span>, wie die Datei ge&ouml;ffnet wird, k&ouml;nnen dieselben Modi wie bei der Funktion <span class="listing">open()</span> verwendet werden.</p>
<p><span class="listing">fdopen()</span> wird gew&ouml;hnlich auf Filedeskriptoren verwendet, die von Funktionen, die Pipes und Kommunikationskan&auml;le in Netzwerken einrichten, zur&uuml;ckgegeben werden. Das kommt daher, weil einige Funktionen <span class="listing">(open()</span>, <span class="listing">dup()</span>, <span class="listing">dup2()</span>, <span class="listing">fcntl()</span>, <span class="listing">pipe()</span> ...) in Netzwerken nichts mit Streams anfangen k&ouml;nnen und Filedeskriptoren ben&ouml;tigen. Um aber wieder aus Deskriptoren einen Stream (<span class="listing">FILE</span>-Zeiger) zu erzeugen, ist die Funktion <span class="listing">fdopen()</span> erforderlich.</p>
<p>Im Gegensatz zu <span class="listing">fileno()</span>, der »nur« den FD-Integer zur&uuml;ckgibt, erstellt <span class="listing">fdopen()</span> ein neues <span class="listing">FILE</span>-Objekt, weshalb man <span class="listing">fdopen()</span> nur einmal aufrufen sollte, da es ja die Parallelfunktion zu <span class="listing">fopen()</span> ist.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20%"><a class="navnav" href="Kap02-001.html"> &lt;&lt; zur&uuml;ck</a></td>
<td width="59%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="20%">
<div align="right"><a class="navnav" href="Kap02-003.html">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="https://www.rheinwerk-verlag.de/linux-unix-programmierung_1137/?GPP=oplup">
                                        <img src="common/749.gif"  border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung">
                                        <br /><strong>Linux-UNIX-<br />Programmierung</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="https://www.rheinwerk-verlag.de/feedback/"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=oplup" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-server_3685/?GPP=oplup">
                        <img src="common/3020.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Server" title="Zum Katalog: Linux-Server"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-Server</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/das-komplettpaket-lpic-1-lpic-2_3782/?GPP=oplup">
                        <img src="common/3529.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2" title="Zum Katalog: Das Komplettpaket LPIC-1 &amp; LPIC-2"><br /><br /><br /><br /><br /><br /><br />&nbsp;Das Komplettpaket<br />&nbsp;LPIC-1 &amp; LPIC-2</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux-hochverfugbarkeit_3420/?GPP=oplup">
                        <img src="common/2542.gif" width="70" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-Hochverfügbarkeit" title="Zum Katalog: Linux-Hochverfügbarkeit"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-<br />&nbsp;Hochverfügbarkeit</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/shell-programmierung_3345/?GPP=oplup">
                        <img src="common/2310.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-<br />&nbsp;Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="https://www.rheinwerk-verlag.de/linux_3436/?GPP=oplup">
                        <img src="common/2591.gif" width="79" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux Handbuch" title="Zum Katalog: Linux Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux Handbuch</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=oplup"><img src="common/pfeil_rechts5.gif" border="0" alt="">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center">
<br />
<div align="center">
    <p class="standard">
        <strong>Copyright © Rheinwerk Verlag GmbH 2006</strong>
        <br />F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich 
        ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, 
        wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist 
        urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der 
        Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und 
        Verarbeitung in elektronischen Systemen.
    </p>
    <br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a>
    <br /><br />Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, 
    Tel.: 0228.42150.0, Fax 0228.42150.77, 
    <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a>
</div>
<br /><br />
</body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/linux_unix_programmierung/Kap02-002.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 19 May 2017 19:44:26 GMT -->
</html>
