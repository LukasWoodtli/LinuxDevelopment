p. 325
8 Signale
8.1 Grundlage zu den Signalen
  8.1.1 Signalmaske
  8.1.2 Signale und fork()
  8.1.3 Signale und exec
  8.1.4 Übersicht zu den Signalen
8.2 Das neue Signalkonzept
  8.2.1 Wozu ein »neues« Signalkonzept?
8.3 Signalmenge initialisieren
8.4 Signalmenge hinzufügen oder löschen
8.5 Signale einrichten oder erfragen
  8.5.1 Einen Signalhandler einrichten, der zurückkehrt
8.6 Signal an den eigenen Prozess senden – raise()
8.7 Signale an andere Prozesse senden – kill()
8.8 Zeitschaltuhr einrichten – alarm()
8.9 Prozesse stoppen, bis ein Signal eintritt – pause()
8.10 Prozesse für eine bestimmte Zeit stoppen – sleep() und usleep()
8.11 Signalmaske erfragen oder ändern – sigprocmask()
8.12 Prozess während einer Änderung der Signalmaske stoppen – sigsuspend()
8.13 Prozesse synchronisieren
p. 349
9 IPC – Interprozesskommunikation
9.1 Unterschiedliche Interprozesskommunikations-Techniken im Überblick
  9.1.1 (Namenlose) Pipes
  9.1.2 Benannte Pipes (FIFO-Pipes)
  9.1.3 Message Queue (Nachrichtenspeicher)
  9.1.4 Semaphore
  9.1.5 Shared Memory (gemeinsamer Speicher)
  9.1.6 STREAMS
  9.1.7 Sockets
  9.1.8 Lock Files (Sperrdateien)
  9.1.9 Dateisperren (Record Locking)
9.2 Gründe für IPC
9.3 Pipes
  9.3.1 Eigenschaften von Pipes
  9.3.2 Pipes einrichten – pipe()
  9.3.3 Eigenschaften von elementaren E/A-Funktionen bei Pipes
  9.3.4 Standard-E/A-Funktionen mit pipe
  9.3.5 Pipes in einen anderen Prozess umleiten
  9.3.6 Filterprogramm erstellen mithilfe einer Pipe
  9.3.7 Einrichten einer Pipe zu einem anderen Prozess – popen()
  9.3.8 Mail versenden mit Pipes und Sendmail
  9.3.9 Drucken über eine Pipe mit lpr
  9.3.10 Benannte Pipes – FIFOs
9.4 System-V-Interprozesskommunikation
  9.4.1 Gemeinsamkeiten der SysV-Mechanismen
  9.4.2 Ein Objekt einrichten, eine Verbindung herstellen und das Objekt wieder löschen
  9.4.3 Datenaustausch zwischen nicht verwandten Prozessen
9.5 Semaphore
  9.5.1 Lebenszyklus eines Semaphors
  9.5.2 Ein Semaphor öffnen oder erstellen – semget()
  9.5.3 Abfragen, Ändern oder Löschen der Semaphormenge – semctl()
  9.5.4 Operationen auf Semaphormengen – semop()
  9.5.5 Semaphore im Vergleich mit Sperren
9.6 Message Queues
  9.6.1 Eine Message Queue öffnen oder erzeugen – msgget()
  9.6.2 Nachrichten versenden – msgsnd()
  9.6.3 Eine Nachricht empfangen – msgrcv()
  9.6.4 Abfragen, Ändern oder Löschen einer Message Queue – msgctl()
9.7 Shared Memory
  9.7.1 Ein Shared-Memory-Segment erstellen oder öffnen – shmget()
  9.7.2 Ein Shared-Memory-Segment abfragen, ändern oder löschen – shmctl()
  9.7.3 Ein Shared-Memory-Segment anbinden (attach) – shmat()
  9.7.4 Ein Shared-Memory-Segment loslösen – shmdt()
  9.7.5 Client-Server-Beispiel – Shared Memory
p. 439
10 Threads
10.1 Unterschiede zwischen Threads und Prozessen
10.2 Thread-Bibliotheken
10.3 Kernel- und User-Threads
10.4 Scheduling und Zustände von Threads
10.5 Die grundlegenden Funktionen zur Thread–Programmierung
  10.5.1 pthread_create – einen neuen Thread erzeugen
  10.5.2 pthread_exit – einen Thread beenden
  10.5.3 pthread_join – auf das Ende eines Threads warten
  10.5.4 pthread_self – die ID von Threads ermitteln
  10.5.5 pthread_equal – die ID von zwei Threads vergleichen
  10.5.6 pthread_detach – einen Thread unabhängig machen
10.6 Die Attribute von Threads und das Scheduling
10.7 Threads synchronisieren
  10.7.1 Mutexe
  10.7.2 Condition-Variablen (Bedingungsvariablen)
  10.7.3 Semaphore
  10.7.4 Weitere Synchronisationstechniken im Überblick
10.8 Threads abbrechen (canceln)
10.9 Erzeugen von Thread-spezifischen Daten (TSD-Data)
10.10 pthread_once – Codeabschnitt einmal ausführen
10.11 Thread-safe (thread-sichere Funktionen)
10.12 Threads und Signale
10.13 Zusammenfassung und Ausblick
p. 505
...
p. 533
11 Netzwerkprogrammierung
11.1 Einführung
11.2 Aufbau von Netzwerken
  11.2.1 ISO/OSI und TCP/IP – Referenzmodell
  11.2.2 Das World Wide Web (Internet)
11.3 TCP/IP – Aufbau und Struktur
  11.3.1 Netzwerkschicht (Datenübertragung)
  11.3.2 Internetschicht
  11.3.3 Transportschicht (TCP, UDP)
  11.3.4 Anwendungsschicht
11.4 TCP Socket
11.5 Kommunikationsmodell
11.6 Grundlegende Funktionen zum Zugriff auf die Socket-Schnittstelle
  11.6.1 Ein Socket anlegen – socket()
  11.6.2 Verbindungsaufbau – connect()
  11.6.3 Socket mit einer Adresse verknüpfen – bind()
  11.6.4 Auf Verbindungen warten – listen() und accept()
  11.6.5 Senden und Empfangen von Daten (1) – write() und read()
  11.6.6 Senden und Empfangen von Daten (2) – send() und recv()
  11.6.7 Verbindung schließen – close()
11.7 Aufbau eines Clientprogramms
  11.7.1 Zusammenfassung: Clientanwendung und Quellcode
11.8 Aufbau des Serverprogramms
  11.8.1 Zusammenfassung: Serveranwendung und Quellcode
11.9 IP-Adressen konvertieren, manipulieren und extrahieren
  11.9.1 inet_aton(), inet_pton() und inet_addr()
  11.9.2 inet_ntoa() und inet_ntop()
  11.9.3 inet_network()
  11.9.4 inet_netof()
  11.9.5 inet_lnaof()
  11.9.6 inet_makeaddr()
11.10 Namen und IP-Adressen umwandeln
  11.10.1 Name-Server
  11.10.2 Informationen zum Rechner im Netz – gethostbyname und gethostbyaddr
  11.10.3 Service-Informationen – getservbyname() und getservbyport()
11.11 Der Puffer
11.12 Standard-E/A-Funktionen verwenden
  11.12.1 Pufferung von Standard-E/A-Funktionen
11.13 Parallele Server
11.14 Syncrones Multiplexing – select()
11.15 POSIX-Threads und Netzwerkprogrammierung
11.16 Optionen für Sockets setzen bzw. erfragen
  11.16.1 setsockopt()
  11.16.2 getsockopt()
  11.16.3 Socket-Optionen
11.17 UDP
  11.17.1 Clientanwendung
  11.17.2 Serveranwendung
  11.17.3 recvfrom() und sendto()
  11.17.4 bind() verwenden oder weglassen
11.18 UNIX-Domain-Sockets (IPC)
  11.18.1 Die Adressstruktur von UNIX-Domain-Sockets
  11.18.2 Lokale Sockets erzeugen – socketpair()
11.19 Multicast-Socket
  11.19.1 Anwendungsgebiete von Multicast-Verbindungen
11.20 Nicht blockierende I/O-Sockets
11.21 Etwas zu Streams und TLI, Raw Socket, XTI
  11.21.1 Raw Socket
  11.21.2 TLI und XTI
  11.21.3 RPC (Remote Procedure Call)
11.22 IPv4 und IPv6
  11.22.1 IPv6 – ein wenig genauer
11.23 Netzwerksoftware nach IPv6 portieren
  11.23.1 Konstanten
  11.23.2 Strukturen
  11.23.3 Funktionen
11.24 Sicherheit und Verschlüsselung
p. 666
...
13 Terminal E/A und Benutzerschnittstellen für die Konsole
13.1 termios
  13.1.1 Terminalattribute bearbeiten
  13.1.2 Flags setzen und löschen
  13.1.3 Terminalidentifizierung
  13.1.4 Geschwindigkeitskontrolle – Baudrate von Terminals einstellen
13.2 terminfo
  13.2.1 terminfo verwenden
  13.2.2 terminfo initialisieren – setupterm()
  13.2.3 Eigenschaften eines Terminals (Finden von capnames) – tigetflag(), tigetnum() und tigetstr()
  13.2.4 Mit terminfo-Eigenschaften arbeiten – putp(), tputs(), tparm()
13.3 ncurses – Halbgrafik
  13.3.1 ncurses initialisieren
  13.3.2 Tastaturmodus und Ein- und Ausgabe
  13.3.3 Eigenschaft der Fenster
  13.3.4 Scrolling
  13.3.5 Attribute und Farben setzen
  13.3.6 Fensterroutinen
  13.3.7 Mausprogrammierung mit ncurses
...
p. 983
17 Werkzeuge für Programmierer
  17.0.1 Der Compiler gcc
  17.0.2 Standardgebrauch des gcc
  17.0.3 Linken von Programmbibliotheken
  17.0.4 Dateien, die GCC kennt
  17.0.5 Ausgabedateien bei jedem einzelnen Schritt der Übersetzung erstellen
  17.0.6 Noch mehr Optionen
  17.0.7 Optionen für Warnmeldungen
  17.0.8 Präprozessor-Optionen
  17.0.9 Debuggen und Profiling
  17.0.10 Optimierungsflags
17.1 Make
  17.1.1 Erzeugen eines Makefiles
  17.1.2 Variablen, Makros und Abkürzungen
  17.1.3 Implizite Regeln
  17.1.4 Musterregeln
  17.1.5 make zur Installation verwenden
  17.1.6 make-Optionen
  17.1.7 Ausblick
17.2 Bibliotheken erstellen
  17.2.1 Statische Bibliotheken erstellen
  17.2.2 Dynamische Bibliotheken (Shared Libraries) erstellen
  17.2.3 Dynamisches Nachladen von Bibliotheken
17.3 RPM
  17.3.1 Verzeichnisse, die RPM benötigt
  17.3.2 Ein eigenes RPM-Paket erstellen
  17.3.3 Sources
  17.3.4 Die Spec-Datei
  17.3.5 Paket erstellen
  17.3.6 Das Paket installieren
17.4 RCS und CVS
  17.4.1 Software-Configuration-Management-Systeme (SCM)
  17.4.2 RCS
  17.4.3 CVS
17.5 Zeitmessung von Programmen
  17.5.1 Einfache Zeitmessung mit TIME – Laufzeit von Prozessen
  17.5.2 Profiling mit GPROF – Laufzeit von Funktionen
  17.5.3 Analyse mit GCOV
17.6 Debuggen mit gdb und ddd
17.7 STRACE – Systemaufrufe verfolgen
17.8 Memory Leaks und unerlaubte Speicherzugriffe
  17.8.1 efence
  17.8.2 valgrind
17.9 Ausblick
p. 1072
...
p. 1213
A Sicherheit unter Linux
A.1 Viren und Trojaner
A.2 Der Superuser (su)
A.3 Überlaufen von Logfiles
A.4 Zugriffsrechte auf Dateien
A.5 Das SUID-Bit
A.6 Programme ohne Ausführrechte
A.7 Buffer Overflow (Pufferüberlauf)
A.8 Race Condition
A.9 Temporäre Dateien
A.10 chroot
A.11 Umgebungsvariablen
A.12 Zugriffsrechte – häufig gemachte Fehler
A.13 system() und popen()
A.14 Offene Filedeskriptoren
A.15 Core Dump
A.16 SQL Injection
A.17 Filedeskriptor-Überlauf mit select()
p. 1239
B Funktionsreferenz
B.1 ANSI C
  B.1.1 <assert.h> – Testmöglichkeiten in einem Programm
  B.1.2 <ctype.h> – Zeichenklassifizierung/Umwandlung
  B.1.3 <errno.h> – Fehler-Konstanten
  B.1.4 <float.h> – Eigenschaften und Limits für Gleitpunkttypen
  B.1.5 <limits.h> – Limits, Konstanten
  B.1.6 <locale.h> – Länderspezifische Eigenheiten
  B.1.7 <math.h> – Mathematische Funktionen
  B.1.8 <setjmp.h> – Nicht-lokale Sprünge
  B.1.9 <signal.h> – Signale
  B.1.10 <stdarg.h> – Variabel lange Argumentenliste
  B.1.11 <stddef.h> – Standarddefinitionen
  B.1.12 <stdio.h> – Standard Ein-/Ausgabe-Funktionen
  B.1.13 <stdlib.h> – Nützliche Funktionen (gemischt)
  B.1.14 <string.h> – String-Bearbeitungsfunktionen
  B.1.15 <time.h> – Datum und Uhrzeit
B.2 ANSI C99
  B.2.1 <iso646.h> – Zur Verwendung von Zeichensätze im ISO646-Format (NA1)
  B.2.2 <wchar.h> – (NA1)
  B.2.3 <wctype.h> (NA1)
  B.2.4 <complex.h> – Funktionen zur Manipulation komplexer Zahlen
  B.2.5 <fenv.h> – Kontrolle der Gleitpunkzahlen-Umgebung
  B.2.6 <inttypes.h> – Für genauere Integertypen
  B.2.7 <stdbool.h> – Boolesche Datentypen in C
  B.2.8 <stdint.h> – Definiert verschieden Integertypen
  B.2.9 <math.h> – Neue Funktionen
  B.2.10 <tgmath.h> – Typengenerische Mathematik-Funktionen
A.3 Elementare E/A-Funktionen
  B.3.1 Limits-Konstanten
  B.3.2 Elementare E/A-Funktionen
B.4 Fortgeschrittene Ein-/Ausgabe-Funktionen
  B.4.1 Multiplexing Ein-/Ausgabe – select()
  B.4.2 Memory Mapped Ein-/Ausgabe
B.5 Verzeichnisse
B.6 Attribute von Dateien und Verzeichnissen
  B.6.1 Funktionen zum Erfragen der Dateiattribute
  B.6.2 Funktionen zum Erfragen oder Setzen bestimmter Zugriffsrechte
B.7 Links
B.8 Prozess und Prozessverwaltungsfunktionen
  B.8.1 Umgebungsvariablen (Environment) eines Prozesses
  B.8.2 Ressourcen-Limits eines Prozesses abfragen oder setzen
  B.8.3 Prozesserkennung erfragen bzw. setzen
  B.8.4 Prozesssteuerung
B.9 Signale – Das neue Signalkonzept
  B.9.1 Signalmengen
  B.9.2 (POSIX) Signalhandler-Funktionen
  B.9.3 Übersicht zu den Signalen
  B.9.4 Signale senden und Prozesse suspendieren
B.10 Interprozesskommunikationen
  B.10.1 Pipes
  B.10.2 FIFO (Benannte Pipe) erzeugen
B.11 Sys-V-Interprozesskommnunikationen
  B.11.1 Message Queue
  B.11.2 Semaphor
  B.11.3 Shared Memory
B.12 Threadprogrammierung
  B.12.1 Thread-Verwaltung
  B.12.2 Attribute von Threads und das Scheduling erfragen
  B.12.3 Attribute und das Scheduling von Threads setzen
  B.12.4 Mutex-Variablen
  B.12.5 Attribute von Mutexe
  B.12.6 Condition Variablen
  B.12.7 Threads beenden
B.13 Netzwerkprogrammierung
  B.13.1 Grundlegende Socket-Funktionen
  B.13.2 Konvertieren zur richtigen Byteanordnung
  B.13.3 Abfragen von Netzwerknummern und Internetadressen
  B.13.4 Hostnamen aus der Host-Datenbank ermitteln
  B.13.5 Service-Datenbank
p. 1321


